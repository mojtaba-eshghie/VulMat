{
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/LoansInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in LoansInterface.sol:\n\t- pragma solidity^0.5.10 (LoansInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function secretHashes(bytes32) external view returns (bytes32, bytes32, bytes32, bytes32, bytes32, bool);\n",
                    "message": "Parameter '' of LoansInterface.secretHashes (LoansInterface.sol#6) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pubKeys(bytes32) external view returns (bytes memory, bytes memory, bytes memory);\n",
                    "message": "Parameter '' of LoansInterface.pubKeys (LoansInterface.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidationExpiration(bytes32) external view returns (uint256);\n",
                    "message": "Parameter '' of LoansInterface.liquidationExpiration (LoansInterface.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function seizureExpiration(bytes32) external view returns (uint256);\n",
                    "message": "Parameter '' of LoansInterface.seizureExpiration (LoansInterface.sol#9) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function secretHashes(bytes32) external view returns (bytes32, bytes32, bytes32, bytes32, bytes32, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pubKeys(bytes32) external view returns (bytes memory, bytes memory, bytes memory);\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/P2WSHInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in P2WSHInterface.sol:\n\t- pragma solidity^0.5.10 (P2WSHInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getP2WSH(bytes32 loan, bool sez) external view returns (bytes memory, bytes32);\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/FundsInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in FundsInterface.sol:\n\t- pragma solidity^0.5.10 (FundsInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function lender(bytes32) external view returns (address);\n",
                    "message": "Parameter '' of FundsInterface.lender (FundsInterface.sol#6) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function custom(bytes32) external view returns (bool);\n",
                    "message": "Parameter '' of FundsInterface.custom (FundsInterface.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deposit(bytes32, uint256) external;\n",
                    "message": "Parameter '' of FundsInterface.deposit (FundsInterface.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function deposit(bytes32, uint256) external;\n",
                    "message": "Parameter '_scope_0' of FundsInterface.deposit (FundsInterface.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decreaseTotalBorrow(uint256) external;\n",
                    "message": "Parameter '' of FundsInterface.decreaseTotalBorrow (FundsInterface.sol#9) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "  function setCompleted(uint completed) public restricted {\n\n    last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#17-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n\n    Migrations upgraded = Migrations(new_address);\n\n    upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#21-24) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity^0.5.10 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function upgrade(address new_address) public restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/SalesInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_16"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in SalesInterface.sol:\n\t- pragma solidity^0.5.10 (SalesInterface.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function saleIndexByLoan(bytes32, uint256) external returns(bytes32);\n",
                    "message": "Parameter '' of SalesInterface.saleIndexByLoan (SalesInterface.sol#6) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function saleIndexByLoan(bytes32, uint256) external returns(bytes32);\n",
                    "message": "Parameter '_scope_0' of SalesInterface.saleIndexByLoan (SalesInterface.sol#6) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function settlementExpiration(bytes32) external view returns (uint256);\n",
                    "message": "Parameter '' of SalesInterface.settlementExpiration (SalesInterface.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function accepted(bytes32) external view returns (bool);\n",
                    "message": "Parameter '' of SalesInterface.accepted (SalesInterface.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function next(bytes32) external view returns (uint256);\n",
                    "message": "Parameter '' of SalesInterface.next (SalesInterface.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_0' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_1' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_2' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_3' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_4' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_5' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_6' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_7' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(bytes32, address, address, address, address, bytes32, bytes32, bytes32, bytes32, bytes20) external returns(bytes32);\n",
                    "message": "Parameter '_scope_8' of SalesInterface.create (SalesInterface.sol#10) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Bytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-optimal-variables-swap",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            byte c = b[i];\n",
                    "message": "Consider swapping variables using `(b[i], b[a - i - 1]) = (b[a - i - 1], b[i])` to save gas"
                },
                {
                    "name": "non-optimal-variables-swap",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b[i] = b[a - i - 1];\n",
                    "message": "Consider swapping variables using `(b[i], b[a - i - 1]) = (b[a - i - 1], b[i])` to save gas"
                },
                {
                    "name": "non-optimal-variables-swap",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b[a - i - 1] = c;\n",
                    "message": "Consider swapping variables using `(b[i], b[a - i - 1]) = (b[a - i - 1], b[i])` to save gas"
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < a; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < (a/2); i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < a; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < (a/2); i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": 17,
                    "vulnerability_code": "    function scriptNumSizeHex(uint256 i) public pure returns (bytes memory) {\n\n        return toBytes(scriptNumSize(i));\n",
                    "message": "Bytes.scriptNumSizeHex (Bytes.sol#15-17) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": 36,
                    "vulnerability_code": "    function scriptNumEncode(uint256 num) public pure returns (bytes memory) {\n\n        uint a = scriptNumSize(num);\n\n        bytes memory b = toBytes(num);\n\n        for (uint i = 0; i < (a/2); i++) {\n\n            byte c = b[i];\n\n            b[i] = b[a - i - 1];\n\n            b[a - i - 1] = c;\n\n        }\n\n        return b;\n",
                    "message": "Bytes.scriptNumEncode (Bytes.sol#27-36) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in Bytes.sol:\n\t- pragma solidity^0.5.10 (Bytes.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if      (i > 0x7fffffff) { return 5; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x7fffff  ) { return 4; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x7fff    ) { return 3; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x7f      ) { return 2; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x00      ) { return 1; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/DSMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function cmul(uint x, uint y) public pure returns (uint z) {\n\n        z = add(mul(x, y), COL / 2) / COL;\n",
                    "message": "DSMath.cmul (DSMath.sol#37-39) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in DSMath.sol:\n\t- pragma solidity^0.5.10 (DSMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant COL  = 10 ** 8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant WAD  = 10 ** 18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant RAY  = 10 ** 27;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/ALCompound.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < markets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < markets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(cToken.redeemUnderlying(tokenToReturn) == 0, \"something went wrong\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(cToken.redeem(toBurn) == 0, \"something went wrong\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < markets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public comptroller;\n",
                    "message": "Helpers.comptroller (ALCompound.sol#135) is never initialized. It is used in:\n\t- getComptrollerAddress (ALCompound.sol#140-145)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 108,
                    "vulnerability_code": "interface CTokenInterface {\n\n    function redeem(uint redeemTokens) external returns (uint);\n\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n    function borrow(uint borrowAmount) external returns (uint);\n\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\n\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\n\n    function exchangeRateCurrent() external returns (uint);\n\n    function getCash() external view returns (uint);\n\n    function totalBorrowsCurrent() external returns (uint);\n\n    function borrowRatePerBlock() external view returns (uint);\n\n    function supplyRatePerBlock() external view returns (uint);\n\n    function totalReserves() external view returns (uint);\n\n    function reserveFactorMantissa() external view returns (uint);\n\n\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function allowance(address, address) external view returns (uint);\n\n    function approve(address, uint) external;\n\n    function transfer(address, uint) external returns (bool);\n\n    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "CTokenInterface (ALCompound.sol#88-108) has incorrect ERC20 function interface(s):\n\t-approve (ALCompound.sol#105)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 123,
                    "vulnerability_code": "interface ERC20Interface {\n\n    function allowance(address, address) external view returns (uint);\n\n    function balanceOf(address) external view returns (uint);\n\n    function approve(address, uint) external;\n\n    function transfer(address, uint) external returns (bool);\n\n    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "ERC20Interface (ALCompound.sol#117-123) has incorrect ERC20 function interface(s):\n\t-approve (ALCompound.sol#120)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function mintCToken(address erc20, address cErc20, uint tokenAmt) internal {\n\n        enterMarket(cErc20);\n\n        ERC20Interface token = ERC20Interface(erc20);\n\n        uint toDeposit = token.balanceOf(address(this));\n\n        if (toDeposit > tokenAmt) {\n\n            toDeposit = tokenAmt;\n\n        }\n\n        CERC20Interface cToken = CERC20Interface(cErc20);\n\n        setApproval(erc20, toDeposit, cErc20);\n\n        assert(cToken.mint(toDeposit) == 0);\n",
                    "message": "ALCompound.mintCToken (ALCompound.sol#181-191) uses a dangerous strict equality:\n\t- assert(bool)(cToken.mint(toDeposit) == 0)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function mintCToken(address erc20, address cErc20, uint tokenAmt) internal {\n\n        enterMarket(cErc20);\n\n        ERC20Interface token = ERC20Interface(erc20);\n\n        uint toDeposit = token.balanceOf(address(this));\n\n        if (toDeposit > tokenAmt) {\n\n            toDeposit = tokenAmt;\n\n        }\n\n        CERC20Interface cToken = CERC20Interface(cErc20);\n\n        setApproval(erc20, toDeposit, cErc20);\n\n        assert(cToken.mint(toDeposit) == 0);\n",
                    "message": "ALCompound.mintCToken (ALCompound.sol#181-191) uses a dangerous strict equality:\n\t- assert(bool)(cToken.mint(toDeposit) == 0)\nALCompound.redeemCToken (ALCompound.sol#212-220) uses a dangerous strict equality:\n\t- require(bool,string)(cToken.redeem(toBurn) == 0,something went wrong)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function mintCToken(address erc20, address cErc20, uint tokenAmt) internal {\n\n        enterMarket(cErc20);\n\n        ERC20Interface token = ERC20Interface(erc20);\n\n        uint toDeposit = token.balanceOf(address(this));\n\n        if (toDeposit > tokenAmt) {\n\n            toDeposit = tokenAmt;\n\n        }\n\n        CERC20Interface cToken = CERC20Interface(cErc20);\n\n        setApproval(erc20, toDeposit, cErc20);\n\n        assert(cToken.mint(toDeposit) == 0);\n",
                    "message": "ALCompound.mintCToken (ALCompound.sol#181-191) uses a dangerous strict equality:\n\t- assert(bool)(cToken.mint(toDeposit) == 0)\nALCompound.redeemCToken (ALCompound.sol#212-220) uses a dangerous strict equality:\n\t- require(bool,string)(cToken.redeem(toBurn) == 0,something went wrong)\nALCompound.redeemUnderlying (ALCompound.sol#197-206) uses a dangerous strict equality:\n\t- require(bool,string)(cToken.redeemUnderlying(tokenToReturn) == 0,something went wrong)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 161,
                    "vulnerability_code": "    function enterMarket(address cErc20) internal {\n\n        TrollerInterface troller = TrollerInterface(getComptrollerAddress());\n\n        address[] memory markets = troller.getAssetsIn(address(this));\n\n        bool isEntered = false;\n\n        for (uint i = 0; i < markets.length; i++) {\n\n            if (markets[i] == cErc20) {\n\n                isEntered = true;\n\n            }\n\n        }\n\n        if (!isEntered) {\n\n            address[] memory toEnter = new address[](1);\n\n            toEnter[0] = cErc20;\n\n            troller.enterMarkets(toEnter);\n\n        }\n",
                    "message": "Helpers.enterMarket (ALCompound.sol#147-161) does not use the value returned by external calls:\n\t-troller.enterMarkets(toEnter) (ALCompound.sol#159)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public comptroller;\n",
                    "message": "Helpers.comptroller should be constant (ALCompound.sol#135)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function cmul(uint x, uint y) public pure returns (uint z) {\n\n        z = add(mul(x, y), COL / 2) / COL;\n",
                    "message": "DSMath.cmul (ALCompound.sol#37-39) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ALCompound.sol:\n\t- pragma solidity^0.5.10 (ALCompound.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (ALCompound.sol#86): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address, address) external view returns (uint);\n",
                    "message": "Parameter '' of CTokenInterface.allowance (ALCompound.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address, address) external view returns (uint);\n",
                    "message": "Parameter '_scope_0' of CTokenInterface.allowance (ALCompound.sol#104) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint) external;\n",
                    "message": "Parameter '' of CTokenInterface.approve (ALCompound.sol#105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint) external;\n",
                    "message": "Parameter '_scope_0' of CTokenInterface.approve (ALCompound.sol#105) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of CTokenInterface.transfer (ALCompound.sol#106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of CTokenInterface.transfer (ALCompound.sol#106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "Parameter '' of CTokenInterface.transferFrom (ALCompound.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of CTokenInterface.transferFrom (ALCompound.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_1' of CTokenInterface.transferFrom (ALCompound.sol#107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address, address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20Interface.allowance (ALCompound.sol#118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address, address) external view returns (uint);\n",
                    "message": "Parameter '_scope_0' of ERC20Interface.allowance (ALCompound.sol#118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20Interface.balanceOf (ALCompound.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint) external;\n",
                    "message": "Parameter '' of ERC20Interface.approve (ALCompound.sol#120) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint) external;\n",
                    "message": "Parameter '_scope_0' of ERC20Interface.approve (ALCompound.sol#120) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20Interface.transfer (ALCompound.sol#121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20Interface.transfer (ALCompound.sol#121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20Interface.transferFrom (ALCompound.sol#122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20Interface.transferFrom (ALCompound.sol#122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address, address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_1' of ERC20Interface.transferFrom (ALCompound.sol#122) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < markets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < markets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant COL  = 10 ** 8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant WAD  = 10 ** 18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant RAY  = 10 ** 27;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/P2WSH.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-optimal-variables-swap",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            byte c = b[i];\n",
                    "message": "Consider swapping variables using `(b[i], b[a - i - 1]) = (b[a - i - 1], b[i])` to save gas"
                },
                {
                    "name": "non-optimal-variables-swap",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b[i] = b[a - i - 1];\n",
                    "message": "Consider swapping variables using `(b[i], b[a - i - 1]) = (b[a - i - 1], b[i])` to save gas"
                },
                {
                    "name": "non-optimal-variables-swap",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b[a - i - 1] = c;\n",
                    "message": "Consider swapping variables using `(b[i], b[a - i - 1]) = (b[a - i - 1], b[i])` to save gas"
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(LoansInterface loans_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    loans = loans_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < a; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < (a/2); i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < a; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < (a/2); i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 169,
                    "vulnerability_code": "  function getP2WSH(bytes32 loan, bool sez) public view returns (bytes memory, bytes32) {\n\n    bytes memory script = loanPeriodP2WSH(loan, biddingPeriodP2WSH(loan, seizurePeriodP2WSH(loan, refundablePeriodP2WSH(loan), sez)));\n\n    bytes32 pubkh = sha256(script);\n\n\n\n    return (script, pubkh);\n",
                    "message": "P2WSH.getP2WSH (P2WSH.sol#164-169) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in P2WSH.sol:\n\t- pragma solidity^0.5.10 (P2WSH.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (P2WSH.sol#41): it allows old versions\n\t- pragma solidity^0.5.10 (P2WSH.sol#52): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function secretHashes(bytes32) external view returns (bytes32, bytes32, bytes32, bytes32, bytes32, bool);\n",
                    "message": "Parameter '' of LoansInterface.secretHashes (P2WSH.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pubKeys(bytes32) external view returns (bytes memory, bytes memory, bytes memory);\n",
                    "message": "Parameter '' of LoansInterface.pubKeys (P2WSH.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidationExpiration(bytes32) external view returns (uint256);\n",
                    "message": "Parameter '' of LoansInterface.liquidationExpiration (P2WSH.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function seizureExpiration(bytes32) external view returns (uint256);\n",
                    "message": "Parameter '' of LoansInterface.seizureExpiration (P2WSH.sol#47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if      (i > 0x7fffffff) { return 5; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x7fffff  ) { return 4; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x7fff    ) { return 3; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x7f      ) { return 2; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        else if (i > 0x00      ) { return 1; }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function secretHashes(bytes32) external view returns (bytes32, bytes32, bytes32, bytes32, bytes32, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pubKeys(bytes32) external view returns (bytes memory, bytes memory, bytes memory);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getP2WSH(bytes32 loan, bool sez) public view returns (bytes memory, bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  LoansInterface loans;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/ISPVInterfaces.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ISPVInterfaces.sol:\n\t- pragma solidity^0.5.10 (ISPVInterfaces.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function spv(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _vin,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _vout,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _vout,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _requestID,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8 _inputIndex,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8 _outputIndex) external;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/EIP20NonStandardInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (EIP20NonStandardInterface.sol#10-72) has incorrect ERC20 function interface(s):\n\t-transfer (EIP20NonStandardInterface.sol#36)\n\t-transferFrom (EIP20NonStandardInterface.sol#50)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in EIP20NonStandardInterface.sol:\n\t- pragma solidity^0.5.10 (EIP20NonStandardInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/ComptrollerInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ComptrollerInterface.sol:\n\t- pragma solidity^0.5.10 (ComptrollerInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/ETHInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRate_, uint multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "ETHInterestRateModel.getBorrowRate (ETHInterestRateModel.sol#455-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": "InterestRateModel.getBorrowRate (ETHInterestRateModel.sol#23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ETHInterestRateModel.sol:\n\t- pragma solidity^0.5.10 (ETHInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (ETHInterestRateModel.sol#35): it allows old versions\n\t- pragma solidity^0.5.10 (ETHInterestRateModel.sol#123): it allows old versions\n\t- pragma solidity^0.5.10 (ETHInterestRateModel.sol#344): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (ETHInterestRateModel.sol#134) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (ETHInterestRateModel.sol#135) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (ETHInterestRateModel.sol#136) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'ETHInterestRateModel.isInterestRateModel' (ETHInterestRateModel.sol#355) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'ETHInterestRateModel.blocksPerYear' (ETHInterestRateModel.sol#370) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/ReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ReentrancyGuard.sol:\n\t- pragma solidity^0.5.10 (ReentrancyGuard.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Comptroller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (accountAssets[msg.sender].length >= maxAssets)  {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 2654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Market storage marketToJoin = markets[address(cToken)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(changeStatus == 0, \"change not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 2742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_81"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2522,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback (Comptroller.sol#2506-2522) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (Comptroller.sol#2508-2510)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2331,
                    "vulnerability_to_line": 2334,
                    "vulnerability_code": "    address public comptrollerImplementation;\n\n\n\n    /**\n",
                    "message": "UnitrollerAdminStorage.comptrollerImplementation (Comptroller.sol#2331-2334) is never initialized. It is used in:\n\t- adminOrInitializing (Comptroller.sol#3501-3511)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (Comptroller.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (Comptroller.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (Comptroller.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Comptroller.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (Comptroller.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (Comptroller.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Comptroller.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (Comptroller.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (Comptroller.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Comptroller.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (Comptroller.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (Comptroller.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Comptroller.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3451,
                    "vulnerability_to_line": 3468,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller._supportMarket (Comptroller.sol#3451-3468):\n\tExternal calls:\n\t- cToken.isCToken() (Comptroller.sol#3460)\n\tState variables written after the call(s):\n\t- markets (Comptroller.sol#3462-3463)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Comptroller.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Comptroller.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1371-1372)\n\t- totalReserves (Comptroller.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (Comptroller.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (Comptroller.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2697,
                    "vulnerability_to_line": 2749,
                    "vulnerability_code": "    function exitMarket(address cTokenAddress) external returns (uint) {\n\n        CToken cToken = CToken(cTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(cToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set cToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete cToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == cToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        CToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(cToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller.exitMarket (Comptroller.sol#2697-2749):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = cToken.getAccountSnapshot(msg.sender) (Comptroller.sol#2700-2701)\n\t- allowed = redeemAllowedInternal(cTokenAddress,msg.sender,tokensHeld) (Comptroller.sol#2709-2710)\n\tState variables written after the call(s):\n\t- accountAssets (Comptroller.sol#2741-2742)\n\t- accountAssets (Comptroller.sol#2743-2744)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (Comptroller.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (Comptroller.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Comptroller.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Comptroller.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Comptroller.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (Comptroller.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Comptroller.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Comptroller.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (Comptroller.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Comptroller.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (Comptroller.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (Comptroller.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (Comptroller.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (Comptroller.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (Comptroller.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 3451,
                    "vulnerability_to_line": 3468,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Comptroller._supportMarket (Comptroller.sol#3451-3468) does not use the value returned by external calls:\n\t-cToken.isCToken() (Comptroller.sol#3460)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3180,
                    "vulnerability_to_line": 3181,
                    "vulnerability_code": "            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- (oErr,vars.cTokenBalance,vars.borrowBalance,vars.exchangeRateMantissa) = asset.getAccountSnapshot(account) (Comptroller.sol#3180-3181)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3188,
                    "vulnerability_to_line": 3189,
                    "vulnerability_code": "            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset) (Comptroller.sol#3188-3189)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Comptroller.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Comptroller.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Comptroller.sol#1369-1370)\n\t- borrowIndex (Comptroller.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (Comptroller.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Comptroller.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (Comptroller.sol#1721-1722)\n\t- accountBorrows (Comptroller.sol#1722-1723)\n\t- totalBorrows (Comptroller.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Comptroller.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Comptroller.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Comptroller.sol#938)\n\t- borrowIndex (Comptroller.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Comptroller.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Comptroller.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Comptroller.sol#942)\n\tState variables written after the call(s):\n\t- decimals (Comptroller.sol#947)\n\t- name (Comptroller.sol#945)\n\t- symbol (Comptroller.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (Comptroller.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Comptroller.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1479-1481)\n\t- totalSupply (Comptroller.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Comptroller.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Comptroller.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (Comptroller.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Comptroller.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (Comptroller.sol#1848-1849)\n\t- accountBorrows (Comptroller.sol#1849-1850)\n\t- totalBorrows (Comptroller.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (Comptroller.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Comptroller.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#2002-2003)\n\t- accountTokens (Comptroller.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (Comptroller.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Comptroller.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1004)\n\t- accountTokens (Comptroller.sol#1005)\n\t- transferAllowances (Comptroller.sol#1009)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2522,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback uses assembly (Comptroller.sol#2506-2522)\n\t- Comptroller.sol#2512-2522\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (Comptroller.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2407,
                    "vulnerability_to_line": 2423,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (Comptroller.sol#2407-2423) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2449,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (Comptroller.sol#2427-2449) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2475,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (Comptroller.sol#2456-2475) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (Comptroller.sol#2479-2502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2648,
                    "vulnerability_to_line": 2691,
                    "vulnerability_code": "    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n\n            if (accountAssets[msg.sender].length >= maxAssets)  {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.enterMarkets (Comptroller.sol#2648-2691) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": 629,
                    "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n",
                    "message": "ComptrollerInterface.enterMarkets (Comptroller.sol#628-629) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3136,
                    "vulnerability_to_line": 3143,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.getAccountLiquidity (Comptroller.sol#3136-3143) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3297,
                    "vulnerability_to_line": 3319,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._setPriceOracle (Comptroller.sol#3297-3319) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": 3496,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._become (Comptroller.sol#3468-3496) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in Comptroller.sol:\n\t- pragma solidity^0.5.10 (Comptroller.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2313-2317): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2370-2374): it allows old versions\n\t- pragma solidity^0.5.10 (Comptroller.sol#2524-2527): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2522,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Low level call in Unitroller.fallback (Comptroller.sol#2506-2522):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) Comptroller.sol#2508-2510\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Comptroller.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Comptroller.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Comptroller.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (Comptroller.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (Comptroller.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (Comptroller.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (Comptroller.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (Comptroller.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (Comptroller.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (Comptroller.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (Comptroller.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (Comptroller.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (Comptroller.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (Comptroller.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (Comptroller.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2407,
                    "vulnerability_to_line": 2423,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (Comptroller.sol#2407-2423) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2449,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (Comptroller.sol#2427-2449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2475,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (Comptroller.sol#2456-2475) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (Comptroller.sol#2479-2502) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3297,
                    "vulnerability_to_line": 3319,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setPriceOracle' (Comptroller.sol#3297-3319) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3324,
                    "vulnerability_to_line": 3349,
                    "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCloseFactor' (Comptroller.sol#3324-3349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3355,
                    "vulnerability_to_line": 3391,
                    "vulnerability_code": "    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(cToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCollateralFactor' (Comptroller.sol#3355-3391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3396,
                    "vulnerability_to_line": 3410,
                    "vulnerability_code": "    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n\n        }\n\n\n\n        uint oldMaxAssets = maxAssets;\n\n        maxAssets = newMaxAssets;\n\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setMaxAssets' (Comptroller.sol#3396-3410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3415,
                    "vulnerability_to_line": 3446,
                    "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setLiquidationIncentive' (Comptroller.sol#3415-3446) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3451,
                    "vulnerability_to_line": 3468,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'Comptroller._supportMarket' (Comptroller.sol#3451-3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": 3496,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._become' (Comptroller.sol#3468-3496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_oracle' of Comptroller._become (Comptroller.sol#3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_closeFactorMantissa' of Comptroller._become (Comptroller.sol#3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_maxAssets' of Comptroller._become (Comptroller.sol#3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2599,
                    "vulnerability_to_line": 2601,
                    "vulnerability_code": "    bool public constant isComptroller = true;\n\n\n",
                    "message": "Constant 'Comptroller.isComptroller' (Comptroller.sol#2599-2601) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2602,
                    "vulnerability_to_line": 2604,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMinMantissa' (Comptroller.sol#2602-2604) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2605,
                    "vulnerability_to_line": 2607,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMaxMantissa' (Comptroller.sol#2605-2607) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2608,
                    "vulnerability_to_line": 2610,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (Comptroller.sol#2608-2610) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2611,
                    "vulnerability_to_line": 2613,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMinMantissa' (Comptroller.sol#2611-2613) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": 2616,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMaxMantissa' (Comptroller.sol#2614-2616) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (Comptroller.sol#166) is never used in Comptroller\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 2742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 2838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint repayAmount) external view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_TX_ORIGIN",
                    "vulnerability_from_line": 3506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tx.origin == admin\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/CErc20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_46"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 2300,
                    "vulnerability_to_line": 2364,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n}\n\n\n",
                    "message": "EIP20NonStandardInterface (CErc20.sol#2300-2364) has incorrect ERC20 function interface(s):\n\t-transfer (CErc20.sol#2326-2329)\n\t-transferFrom (CErc20.sol#2340-2343)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CErc20.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (CErc20.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CErc20.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CErc20.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (CErc20.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CErc20.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CErc20.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CErc20.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CErc20.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CErc20.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CErc20.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1371-1372)\n\t- totalReserves (CErc20.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CErc20.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (CErc20.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CErc20.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (CErc20.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CErc20.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (CErc20.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CErc20.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CErc20.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CErc20.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CErc20.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CErc20.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CErc20.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CErc20.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CErc20.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CErc20.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2391,
                    "vulnerability_to_line": 2404,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (CErc20.sol#2391-2404) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (CErc20.sol#2401)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20.sol#1369-1370)\n\t- borrowIndex (CErc20.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CErc20.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CErc20.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20.sol#1721-1722)\n\t- accountBorrows (CErc20.sol#1722-1723)\n\t- totalBorrows (CErc20.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20.sol#938)\n\t- borrowIndex (CErc20.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CErc20.sol#942)\n\tState variables written after the call(s):\n\t- decimals (CErc20.sol#947)\n\t- name (CErc20.sol#945)\n\t- symbol (CErc20.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CErc20.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CErc20.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1479-1481)\n\t- totalSupply (CErc20.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CErc20.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CErc20.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20.sol#1848-1849)\n\t- accountBorrows (CErc20.sol#1849-1850)\n\t- totalBorrows (CErc20.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CErc20.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CErc20.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#2002-2003)\n\t- accountTokens (CErc20.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CErc20.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CErc20.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1004)\n\t- accountTokens (CErc20.sol#1005)\n\t- transferAllowances (CErc20.sol#1009)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2515,
                    "vulnerability_to_line": 2544,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (CErc20.sol#2515-2544)\n\t- CErc20.sol#2523-2536\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2552,
                    "vulnerability_to_line": 2579,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n",
                    "message": "CErc20.doTransferOut uses assembly (CErc20.sol#2552-2579)\n\t- CErc20.sol#2560-2573\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CErc20.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in CErc20.sol:\n\t- pragma solidity^0.5.10 (CErc20.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (CErc20.sol#2366-2370): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CErc20.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CErc20.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CErc20.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CErc20.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CErc20.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CErc20.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CErc20.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CErc20.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CErc20.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CErc20.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CErc20.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CErc20.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CErc20.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CErc20.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CErc20.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Exponential.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in Exponential.sol:\n\t- pragma solidity^0.5.10 (Exponential.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (Exponential.sol#91): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Exponential.sol#102) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Exponential.sol#103) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Exponential.sol#104) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (Exponential.sol#104) is never used in Exponential\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/PriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_42"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (PriceOracle.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (PriceOracle.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (PriceOracle.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (PriceOracle.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (PriceOracle.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (PriceOracle.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (PriceOracle.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracle.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (PriceOracle.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (PriceOracle.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracle.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (PriceOracle.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (PriceOracle.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracle.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracle.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1371-1372)\n\t- totalReserves (PriceOracle.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (PriceOracle.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (PriceOracle.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (PriceOracle.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (PriceOracle.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (PriceOracle.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracle.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracle.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (PriceOracle.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (PriceOracle.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (PriceOracle.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (PriceOracle.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (PriceOracle.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (PriceOracle.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (PriceOracle.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (PriceOracle.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (PriceOracle.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (PriceOracle.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracle.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracle.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracle.sol#1369-1370)\n\t- borrowIndex (PriceOracle.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (PriceOracle.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (PriceOracle.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracle.sol#1721-1722)\n\t- accountBorrows (PriceOracle.sol#1722-1723)\n\t- totalBorrows (PriceOracle.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracle.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracle.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracle.sol#938)\n\t- borrowIndex (PriceOracle.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracle.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracle.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (PriceOracle.sol#942)\n\tState variables written after the call(s):\n\t- decimals (PriceOracle.sol#947)\n\t- name (PriceOracle.sol#945)\n\t- symbol (PriceOracle.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (PriceOracle.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (PriceOracle.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1479-1481)\n\t- totalSupply (PriceOracle.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracle.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracle.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (PriceOracle.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (PriceOracle.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracle.sol#1848-1849)\n\t- accountBorrows (PriceOracle.sol#1849-1850)\n\t- totalBorrows (PriceOracle.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (PriceOracle.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (PriceOracle.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#2002-2003)\n\t- accountTokens (PriceOracle.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (PriceOracle.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (PriceOracle.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1004)\n\t- accountTokens (PriceOracle.sol#1005)\n\t- transferAllowances (PriceOracle.sol#1009)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (PriceOracle.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in PriceOracle.sol:\n\t- pragma solidity^0.5.10 (PriceOracle.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracle.sol#2293-2296): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (PriceOracle.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (PriceOracle.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (PriceOracle.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (PriceOracle.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (PriceOracle.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (PriceOracle.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (PriceOracle.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (PriceOracle.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (PriceOracle.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (PriceOracle.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (PriceOracle.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (PriceOracle.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (PriceOracle.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (PriceOracle.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (PriceOracle.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/CToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_42"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CToken.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (CToken.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CToken.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CToken.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (CToken.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CToken.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CToken.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (CToken.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CToken.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CToken.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (CToken.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CToken.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CToken.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CToken.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CToken.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1371-1372)\n\t- totalReserves (CToken.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CToken.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (CToken.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CToken.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (CToken.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CToken.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CToken.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CToken.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (CToken.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CToken.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CToken.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CToken.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CToken.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CToken.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CToken.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CToken.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CToken.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CToken.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CToken.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CToken.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CToken.sol#1369-1370)\n\t- borrowIndex (CToken.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CToken.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CToken.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (CToken.sol#1721-1722)\n\t- accountBorrows (CToken.sol#1722-1723)\n\t- totalBorrows (CToken.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CToken.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CToken.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CToken.sol#938)\n\t- borrowIndex (CToken.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CToken.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CToken.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CToken.sol#942)\n\tState variables written after the call(s):\n\t- decimals (CToken.sol#947)\n\t- name (CToken.sol#945)\n\t- symbol (CToken.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CToken.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CToken.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1479-1481)\n\t- totalSupply (CToken.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CToken.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CToken.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CToken.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CToken.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (CToken.sol#1848-1849)\n\t- accountBorrows (CToken.sol#1849-1850)\n\t- totalBorrows (CToken.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CToken.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CToken.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#2002-2003)\n\t- accountTokens (CToken.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CToken.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CToken.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1004)\n\t- accountTokens (CToken.sol#1005)\n\t- transferAllowances (CToken.sol#1009)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CToken.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in CToken.sol:\n\t- pragma solidity^0.5.10 (CToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (CToken.sol#726-727): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CToken.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CToken.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CToken.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CToken.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CToken.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CToken.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CToken.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CToken.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CToken.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CToken.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CToken.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CToken.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CToken.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CToken.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CToken.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/PriceOracleProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (accountAssets[msg.sender].length >= maxAssets)  {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address comptroller_, address v1PriceOracle_, address cEtherAddress_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3846,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        comptroller = Comptroller(comptroller_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        cEtherAddress = cEtherAddress_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 2654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Market storage marketToJoin = markets[address(cToken)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(changeStatus == 0, \"change not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 2742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_88"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2522,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback (PriceOracleProxy.sol#2506-2522) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (PriceOracleProxy.sol#2508-2510)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2331,
                    "vulnerability_to_line": 2334,
                    "vulnerability_code": "    address public comptrollerImplementation;\n\n\n\n    /**\n",
                    "message": "UnitrollerAdminStorage.comptrollerImplementation (PriceOracleProxy.sol#2331-2334) is never initialized. It is used in:\n\t- adminOrInitializing (PriceOracleProxy.sol#3501-3513)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 3522,
                    "vulnerability_to_line": 3586,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n}\n\n\n",
                    "message": "EIP20NonStandardInterface (PriceOracleProxy.sol#3522-3586) has incorrect ERC20 function interface(s):\n\t-transfer (PriceOracleProxy.sol#3548-3551)\n\t-transferFrom (PriceOracleProxy.sol#3562-3565)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (PriceOracleProxy.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (PriceOracleProxy.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (PriceOracleProxy.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (PriceOracleProxy.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (PriceOracleProxy.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (PriceOracleProxy.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (PriceOracleProxy.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracleProxy.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (PriceOracleProxy.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (PriceOracleProxy.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracleProxy.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (PriceOracleProxy.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (PriceOracleProxy.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3451,
                    "vulnerability_to_line": 3468,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller._supportMarket (PriceOracleProxy.sol#3451-3468):\n\tExternal calls:\n\t- cToken.isCToken() (PriceOracleProxy.sol#3460)\n\tState variables written after the call(s):\n\t- markets (PriceOracleProxy.sol#3462-3463)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracleProxy.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracleProxy.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1371-1372)\n\t- totalReserves (PriceOracleProxy.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (PriceOracleProxy.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (PriceOracleProxy.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2697,
                    "vulnerability_to_line": 2749,
                    "vulnerability_code": "    function exitMarket(address cTokenAddress) external returns (uint) {\n\n        CToken cToken = CToken(cTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(cToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set cToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete cToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == cToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        CToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(cToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller.exitMarket (PriceOracleProxy.sol#2697-2749):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = cToken.getAccountSnapshot(msg.sender) (PriceOracleProxy.sol#2700-2701)\n\t- allowed = redeemAllowedInternal(cTokenAddress,msg.sender,tokensHeld) (PriceOracleProxy.sol#2709-2710)\n\tState variables written after the call(s):\n\t- accountAssets (PriceOracleProxy.sol#2741-2742)\n\t- accountAssets (PriceOracleProxy.sol#2743-2744)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (PriceOracleProxy.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (PriceOracleProxy.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (PriceOracleProxy.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracleProxy.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracleProxy.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (PriceOracleProxy.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (PriceOracleProxy.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (PriceOracleProxy.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (PriceOracleProxy.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (PriceOracleProxy.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (PriceOracleProxy.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (PriceOracleProxy.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (PriceOracleProxy.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (PriceOracleProxy.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (PriceOracleProxy.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 3451,
                    "vulnerability_to_line": 3468,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Comptroller._supportMarket (PriceOracleProxy.sol#3451-3468) does not use the value returned by external calls:\n\t-cToken.isCToken() (PriceOracleProxy.sol#3460)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 3613,
                    "vulnerability_to_line": 3626,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (PriceOracleProxy.sol#3613-3626) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (PriceOracleProxy.sol#3623)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3180,
                    "vulnerability_to_line": 3181,
                    "vulnerability_code": "            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- (oErr,vars.cTokenBalance,vars.borrowBalance,vars.exchangeRateMantissa) = asset.getAccountSnapshot(account) (PriceOracleProxy.sol#3180-3181)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3188,
                    "vulnerability_to_line": 3189,
                    "vulnerability_code": "            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset) (PriceOracleProxy.sol#3188-3189)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracleProxy.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracleProxy.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracleProxy.sol#1369-1370)\n\t- borrowIndex (PriceOracleProxy.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (PriceOracleProxy.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (PriceOracleProxy.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracleProxy.sol#1721-1722)\n\t- accountBorrows (PriceOracleProxy.sol#1722-1723)\n\t- totalBorrows (PriceOracleProxy.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracleProxy.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracleProxy.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracleProxy.sol#938)\n\t- borrowIndex (PriceOracleProxy.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracleProxy.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracleProxy.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (PriceOracleProxy.sol#942)\n\tState variables written after the call(s):\n\t- decimals (PriceOracleProxy.sol#947)\n\t- name (PriceOracleProxy.sol#945)\n\t- symbol (PriceOracleProxy.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (PriceOracleProxy.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (PriceOracleProxy.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#1479-1481)\n\t- totalSupply (PriceOracleProxy.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracleProxy.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracleProxy.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (PriceOracleProxy.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (PriceOracleProxy.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracleProxy.sol#1848-1849)\n\t- accountBorrows (PriceOracleProxy.sol#1849-1850)\n\t- totalBorrows (PriceOracleProxy.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (PriceOracleProxy.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (PriceOracleProxy.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#2002-2003)\n\t- accountTokens (PriceOracleProxy.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (PriceOracleProxy.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (PriceOracleProxy.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#1004)\n\t- accountTokens (PriceOracleProxy.sol#1005)\n\t- transferAllowances (PriceOracleProxy.sol#1009)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2522,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback uses assembly (PriceOracleProxy.sol#2506-2522)\n\t- PriceOracleProxy.sol#2512-2522\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3737,
                    "vulnerability_to_line": 3766,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (PriceOracleProxy.sol#3737-3766)\n\t- PriceOracleProxy.sol#3745-3758\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3774,
                    "vulnerability_to_line": 3803,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n}\n\n\n",
                    "message": "CErc20.doTransferOut uses assembly (PriceOracleProxy.sol#3774-3803)\n\t- PriceOracleProxy.sol#3782-3795\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (PriceOracleProxy.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2407,
                    "vulnerability_to_line": 2423,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (PriceOracleProxy.sol#2407-2423) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2449,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (PriceOracleProxy.sol#2427-2449) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2475,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (PriceOracleProxy.sol#2456-2475) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (PriceOracleProxy.sol#2479-2502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2648,
                    "vulnerability_to_line": 2691,
                    "vulnerability_code": "    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n\n            if (accountAssets[msg.sender].length >= maxAssets)  {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.enterMarkets (PriceOracleProxy.sol#2648-2691) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": 629,
                    "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n",
                    "message": "ComptrollerInterface.enterMarkets (PriceOracleProxy.sol#628-629) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3136,
                    "vulnerability_to_line": 3143,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.getAccountLiquidity (PriceOracleProxy.sol#3136-3143) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3297,
                    "vulnerability_to_line": 3319,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._setPriceOracle (PriceOracleProxy.sol#3297-3319) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": 3496,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._become (PriceOracleProxy.sol#3468-3496) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3856,
                    "vulnerability_to_line": 3872,
                    "vulnerability_code": "    function getUnderlyingPrice(CToken cToken) public view returns (uint) {\n\n        address cTokenAddress = address(cToken);\n\n        (bool isListed, ) = comptroller.markets(cTokenAddress);\n\n\n\n        if (!isListed) {\n\n            // not listed, worthless\n\n            return 0;\n\n        } else if (cTokenAddress == cEtherAddress) {\n\n            // ether always worth 1\n\n            return 1e18;\n\n        } else {\n\n            // read from v1 oracle\n\n            address underlying = CErc20(cTokenAddress).underlying();\n\n            return v1PriceOracle.assetPrices(underlying);\n\n        }\n\n    }\n",
                    "message": "PriceOracleProxy.getUnderlyingPrice (PriceOracleProxy.sol#3856-3872) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2308,
                    "vulnerability_to_line": 2311,
                    "vulnerability_code": "    function getUnderlyingPrice(CToken cToken) external view returns (uint);\n\n}\n\n\n",
                    "message": "PriceOracle.getUnderlyingPrice (PriceOracleProxy.sol#2308-2311) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in PriceOracleProxy.sol:\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#2313-2317): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#2370-2374): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#2524-2527): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#3515-3518): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#3588-3592): it allows old versions\n\t- pragma solidity^0.5.10 (PriceOracleProxy.sol#3805-3807): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2522,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Low level call in Unitroller.fallback (PriceOracleProxy.sol#2506-2522):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) PriceOracleProxy.sol#2508-2510\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (PriceOracleProxy.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (PriceOracleProxy.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (PriceOracleProxy.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (PriceOracleProxy.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (PriceOracleProxy.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (PriceOracleProxy.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (PriceOracleProxy.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (PriceOracleProxy.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (PriceOracleProxy.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (PriceOracleProxy.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (PriceOracleProxy.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (PriceOracleProxy.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (PriceOracleProxy.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (PriceOracleProxy.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (PriceOracleProxy.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2407,
                    "vulnerability_to_line": 2423,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (PriceOracleProxy.sol#2407-2423) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2449,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (PriceOracleProxy.sol#2427-2449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2475,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (PriceOracleProxy.sol#2456-2475) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (PriceOracleProxy.sol#2479-2502) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3297,
                    "vulnerability_to_line": 3319,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setPriceOracle' (PriceOracleProxy.sol#3297-3319) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3324,
                    "vulnerability_to_line": 3349,
                    "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCloseFactor' (PriceOracleProxy.sol#3324-3349) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3355,
                    "vulnerability_to_line": 3391,
                    "vulnerability_code": "    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(cToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCollateralFactor' (PriceOracleProxy.sol#3355-3391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3396,
                    "vulnerability_to_line": 3410,
                    "vulnerability_code": "    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n\n        }\n\n\n\n        uint oldMaxAssets = maxAssets;\n\n        maxAssets = newMaxAssets;\n\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setMaxAssets' (PriceOracleProxy.sol#3396-3410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3415,
                    "vulnerability_to_line": 3446,
                    "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setLiquidationIncentive' (PriceOracleProxy.sol#3415-3446) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3451,
                    "vulnerability_to_line": 3468,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'Comptroller._supportMarket' (PriceOracleProxy.sol#3451-3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": 3496,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._become' (PriceOracleProxy.sol#3468-3496) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_oracle' of Comptroller._become (PriceOracleProxy.sol#3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_closeFactorMantissa' of Comptroller._become (PriceOracleProxy.sol#3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_maxAssets' of Comptroller._become (PriceOracleProxy.sol#3468) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2599,
                    "vulnerability_to_line": 2601,
                    "vulnerability_code": "    bool public constant isComptroller = true;\n\n\n",
                    "message": "Constant 'Comptroller.isComptroller' (PriceOracleProxy.sol#2599-2601) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2602,
                    "vulnerability_to_line": 2604,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMinMantissa' (PriceOracleProxy.sol#2602-2604) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2605,
                    "vulnerability_to_line": 2607,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMaxMantissa' (PriceOracleProxy.sol#2605-2607) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2608,
                    "vulnerability_to_line": 2610,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (PriceOracleProxy.sol#2608-2610) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2611,
                    "vulnerability_to_line": 2613,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMinMantissa' (PriceOracleProxy.sol#2611-2613) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": 2616,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMaxMantissa' (PriceOracleProxy.sol#2614-2616) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3835,
                    "vulnerability_to_line": 3838,
                    "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n\n    /**\n",
                    "message": "Constant 'PriceOracleProxy.isPriceOracle' (PriceOracleProxy.sol#3835-3838) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (PriceOracleProxy.sol#166) is never used in Comptroller\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 2742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 2838,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint repayAmount) external view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_TX_ORIGIN",
                    "vulnerability_from_line": 3506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tx.origin == admin\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/ErrorReporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ErrorReporter.sol:\n\t- pragma solidity^0.5.10 (ErrorReporter.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Unitroller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2403,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2404,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_54"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2520,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n",
                    "message": "Unitroller.fallback (Unitroller.sol#2506-2520) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (Unitroller.sol#2508-2510)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (Unitroller.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (Unitroller.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (Unitroller.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Unitroller.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (Unitroller.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (Unitroller.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Unitroller.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (Unitroller.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (Unitroller.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Unitroller.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (Unitroller.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (Unitroller.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Unitroller.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Unitroller.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Unitroller.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1371-1372)\n\t- totalReserves (Unitroller.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (Unitroller.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (Unitroller.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (Unitroller.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (Unitroller.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Unitroller.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Unitroller.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Unitroller.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (Unitroller.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Unitroller.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Unitroller.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (Unitroller.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Unitroller.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (Unitroller.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (Unitroller.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (Unitroller.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (Unitroller.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (Unitroller.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Unitroller.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Unitroller.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Unitroller.sol#1369-1370)\n\t- borrowIndex (Unitroller.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (Unitroller.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Unitroller.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (Unitroller.sol#1721-1722)\n\t- accountBorrows (Unitroller.sol#1722-1723)\n\t- totalBorrows (Unitroller.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Unitroller.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Unitroller.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Unitroller.sol#938)\n\t- borrowIndex (Unitroller.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Unitroller.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Unitroller.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Unitroller.sol#942)\n\tState variables written after the call(s):\n\t- decimals (Unitroller.sol#947)\n\t- name (Unitroller.sol#945)\n\t- symbol (Unitroller.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (Unitroller.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Unitroller.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1479-1481)\n\t- totalSupply (Unitroller.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Unitroller.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Unitroller.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (Unitroller.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Unitroller.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (Unitroller.sol#1848-1849)\n\t- accountBorrows (Unitroller.sol#1849-1850)\n\t- totalBorrows (Unitroller.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (Unitroller.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Unitroller.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#2002-2003)\n\t- accountTokens (Unitroller.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (Unitroller.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Unitroller.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1004)\n\t- accountTokens (Unitroller.sol#1005)\n\t- transferAllowances (Unitroller.sol#1009)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2520,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n",
                    "message": "Unitroller.fallback uses assembly (Unitroller.sol#2506-2520)\n\t- Unitroller.sol#2512-2520\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2349,
                    "vulnerability_to_line": 2352,
                    "vulnerability_code": "    uint public closeFactorMantissa;\n\n\n\n    /**\n",
                    "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (Unitroller.sol#2349-2352)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (Unitroller.sol#2354-2357)\nComptrollerV1Storage.maxAssets should be constant (Unitroller.sol#2359-2362)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (Unitroller.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2407,
                    "vulnerability_to_line": 2423,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (Unitroller.sol#2407-2423) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2449,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (Unitroller.sol#2427-2449) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2475,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (Unitroller.sol#2456-2475) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (Unitroller.sol#2479-2502) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in Unitroller.sol:\n\t- pragma solidity^0.5.10 (Unitroller.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#2313-2317): it allows old versions\n\t- pragma solidity^0.5.10 (Unitroller.sol#2370-2374): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": 2520,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n",
                    "message": "Low level call in Unitroller.fallback (Unitroller.sol#2506-2520):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) Unitroller.sol#2508-2510\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Unitroller.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Unitroller.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Unitroller.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (Unitroller.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (Unitroller.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (Unitroller.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (Unitroller.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (Unitroller.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (Unitroller.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (Unitroller.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (Unitroller.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (Unitroller.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (Unitroller.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (Unitroller.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (Unitroller.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2407,
                    "vulnerability_to_line": 2423,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (Unitroller.sol#2407-2423) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": 2449,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (Unitroller.sol#2427-2449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": 2475,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (Unitroller.sol#2456-2475) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (Unitroller.sol#2479-2502) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/CarefulMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in CarefulMath.sol:\n\t- pragma solidity^0.5.10 (CarefulMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/DAIInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRate_, uint multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "DAIInterestRateModel.getBorrowRate (DAIInterestRateModel.sol#455-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": "InterestRateModel.getBorrowRate (DAIInterestRateModel.sol#23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in DAIInterestRateModel.sol:\n\t- pragma solidity^0.5.10 (DAIInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (DAIInterestRateModel.sol#35): it allows old versions\n\t- pragma solidity^0.5.10 (DAIInterestRateModel.sol#123): it allows old versions\n\t- pragma solidity^0.5.10 (DAIInterestRateModel.sol#344): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (DAIInterestRateModel.sol#134) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (DAIInterestRateModel.sol#135) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (DAIInterestRateModel.sol#136) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'DAIInterestRateModel.isInterestRateModel' (DAIInterestRateModel.sol#355) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'DAIInterestRateModel.blocksPerYear' (DAIInterestRateModel.sol#370) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/EIP20Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in EIP20Interface.sol:\n\t- pragma solidity^0.5.10 (EIP20Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/InterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in InterestRateModel.sol:\n\t- pragma solidity^0.5.10 (InterestRateModel.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/ComptrollerStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_43"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (ComptrollerStorage.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerStorage.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (ComptrollerStorage.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ComptrollerStorage.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (ComptrollerStorage.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (ComptrollerStorage.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ComptrollerStorage.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (ComptrollerStorage.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ComptrollerStorage.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (ComptrollerStorage.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ComptrollerStorage.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1371-1372)\n\t- totalReserves (ComptrollerStorage.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (ComptrollerStorage.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (ComptrollerStorage.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (ComptrollerStorage.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (ComptrollerStorage.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (ComptrollerStorage.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (ComptrollerStorage.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (ComptrollerStorage.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ComptrollerStorage.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (ComptrollerStorage.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ComptrollerStorage.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (ComptrollerStorage.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (ComptrollerStorage.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (ComptrollerStorage.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (ComptrollerStorage.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (ComptrollerStorage.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#1369-1370)\n\t- borrowIndex (ComptrollerStorage.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (ComptrollerStorage.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ComptrollerStorage.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1721-1722)\n\t- accountBorrows (ComptrollerStorage.sol#1722-1723)\n\t- totalBorrows (ComptrollerStorage.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#938)\n\t- borrowIndex (ComptrollerStorage.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ComptrollerStorage.sol#942)\n\tState variables written after the call(s):\n\t- decimals (ComptrollerStorage.sol#947)\n\t- name (ComptrollerStorage.sol#945)\n\t- symbol (ComptrollerStorage.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (ComptrollerStorage.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ComptrollerStorage.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1479-1481)\n\t- totalSupply (ComptrollerStorage.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (ComptrollerStorage.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ComptrollerStorage.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1848-1849)\n\t- accountBorrows (ComptrollerStorage.sol#1849-1850)\n\t- totalBorrows (ComptrollerStorage.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (ComptrollerStorage.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (ComptrollerStorage.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#2002-2003)\n\t- accountTokens (ComptrollerStorage.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (ComptrollerStorage.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ComptrollerStorage.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1004)\n\t- accountTokens (ComptrollerStorage.sol#1005)\n\t- transferAllowances (ComptrollerStorage.sol#1009)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2349,
                    "vulnerability_to_line": 2352,
                    "vulnerability_code": "    uint public closeFactorMantissa;\n\n\n\n    /**\n",
                    "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (ComptrollerStorage.sol#2349-2352)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (ComptrollerStorage.sol#2354-2357)\nComptrollerV1Storage.maxAssets should be constant (ComptrollerStorage.sol#2359-2362)\nUnitrollerAdminStorage.admin should be constant (ComptrollerStorage.sol#2321-2324)\nUnitrollerAdminStorage.comptrollerImplementation should be constant (ComptrollerStorage.sol#2331-2334)\nUnitrollerAdminStorage.pendingAdmin should be constant (ComptrollerStorage.sol#2326-2329)\nUnitrollerAdminStorage.pendingComptrollerImplementation should be constant (ComptrollerStorage.sol#2336-2339)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (ComptrollerStorage.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in ComptrollerStorage.sol:\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (ComptrollerStorage.sol#2313-2317): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (ComptrollerStorage.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (ComptrollerStorage.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (ComptrollerStorage.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (ComptrollerStorage.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (ComptrollerStorage.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (ComptrollerStorage.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (ComptrollerStorage.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (ComptrollerStorage.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (ComptrollerStorage.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (ComptrollerStorage.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (ComptrollerStorage.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (ComptrollerStorage.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (ComptrollerStorage.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (ComptrollerStorage.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (ComptrollerStorage.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/WhitePaperInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRate_, uint multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "WhitePaperInterestRateModel.getBorrowRate (WhitePaperInterestRateModel.sol#455-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": "InterestRateModel.getBorrowRate (WhitePaperInterestRateModel.sol#23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in WhitePaperInterestRateModel.sol:\n\t- pragma solidity^0.5.10 (WhitePaperInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (WhitePaperInterestRateModel.sol#35): it allows old versions\n\t- pragma solidity^0.5.10 (WhitePaperInterestRateModel.sol#123): it allows old versions\n\t- pragma solidity^0.5.10 (WhitePaperInterestRateModel.sol#344): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (WhitePaperInterestRateModel.sol#134) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (WhitePaperInterestRateModel.sol#135) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (WhitePaperInterestRateModel.sol#136) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'WhitePaperInterestRateModel.isInterestRateModel' (WhitePaperInterestRateModel.sol#355) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'WhitePaperInterestRateModel.blocksPerYear' (WhitePaperInterestRateModel.sol#370) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/CEther.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 921,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 924,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1319,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1946,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2083,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1717,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_44"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 2300,
                    "vulnerability_to_line": 2364,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n}\n\n\n",
                    "message": "EIP20NonStandardInterface (CEther.sol#2300-2364) has incorrect ERC20 function interface(s):\n\t-transfer (CEther.sol#2326-2329)\n\t-transferFrom (CEther.sol#2340-2343)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 2473,
                    "vulnerability_to_line": 2480,
                    "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n\n    /**\n",
                    "message": "CEther.getCashPrior (CEther.sol#2473-2480) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CEther.sol#2144-2154):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2145-2146)\n\tState variables written after the call(s):\n\t- totalReserves (CEther.sol#2151-2154)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CEther.sol#2075-2094):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CEther.sol#2083-2085)\n\tState variables written after the call(s):\n\t- comptroller (CEther.sol#2086-2088)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CEther.sol#2214-2225):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2215-2216)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CEther.sol#2221-2224)\n\tState variables written after the call(s):\n\t- interestRateModel (CEther.sol#2221-2224)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CEther.sol#2230-2261):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CEther.sol#2250-2252)\n\tState variables written after the call(s):\n\t- interestRateModel (CEther.sol#2253-2255)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CEther.sol#2099-2109):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2100-2101)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CEther.sol#2106-2107)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CEther.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CEther.sol#1318-1319)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1371-1372)\n\t- totalReserves (CEther.sol#1372-1374)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": 1654,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CEther.sol#1644-1654):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1645-1646)\n\t- borrowFresh(msg.sender,borrowAmount) (CEther.sol#1651-1652)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1651-1652)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": 1886,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CEther.sol#1869-1886):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1870-1871)\n\t- error = cTokenCollateral.accrueInterest() (CEther.sol#1876-1877)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CEther.sol#1883-1884)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1883-1884)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CEther.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CEther.sol#1581-1582)\n\tState variables written after the call(s):\n\t- totalSupply (CEther.sol#1626-1627)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": 1765,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CEther.sol#1755-1765):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1756-1757)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CEther.sol#1762-1763)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1762-1763)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1739,
                    "vulnerability_to_line": 1749,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CEther.sol#1739-1749):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1740-1741)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CEther.sol#1746-1747)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1746-1747)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1315,
                    "vulnerability_to_line": 1317,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CEther.sol#1315-1317) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": 1686,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CEther.sol#1684-1686) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": 1426,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CEther.sol#1424-1426) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1794,
                    "vulnerability_to_line": 1796,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CEther.sol#1794-1796) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1546,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CEther.sol#1544-1546) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1314,
                    "vulnerability_to_line": 1380,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CEther.sol#1314-1380):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CEther.sol#1318-1319)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CEther.sol#1369-1370)\n\t- borrowIndex (CEther.sol#1370-1371)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1667,
                    "vulnerability_to_line": 1734,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CEther.sol#1667-1734):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CEther.sol#1669-1670)\n\tState variables written after the call(s):\n\t- accountBorrows (CEther.sol#1721-1722)\n\t- accountBorrows (CEther.sol#1722-1723)\n\t- totalBorrows (CEther.sol#1723-1725)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CEther.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CEther.sol#934)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CEther.sol#938)\n\t- borrowIndex (CEther.sol#939)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": 949,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CEther.sol#920-949):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CEther.sol#934)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CEther.sol#942)\n\tState variables written after the call(s):\n\t- decimals (CEther.sol#947)\n\t- name (CEther.sol#945)\n\t- symbol (CEther.sol#946)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": 1491,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CEther.sol#1412-1491):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CEther.sol#1414-1415)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#1479-1481)\n\t- totalSupply (CEther.sol#1478-1479)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": 1639,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CEther.sol#1541-1639):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CEther.sol#1581-1582)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#1627-1629)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1782,
                    "vulnerability_to_line": 1861,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CEther.sol#1782-1861):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CEther.sol#1784-1785)\n\tState variables written after the call(s):\n\t- accountBorrows (CEther.sol#1848-1849)\n\t- accountBorrows (CEther.sol#1849-1850)\n\t- totalBorrows (CEther.sol#1850-1852)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1966,
                    "vulnerability_to_line": 2015,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hook */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CEther.sol#1966-2015):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CEther.sol#1968-1969)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#2002-2003)\n\t- accountTokens (CEther.sol#2003-2005)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": 1020,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hook (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CEther.sol#959-1020):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CEther.sol#961)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#1004)\n\t- accountTokens (CEther.sol#1005)\n\t- transferAllowances (CEther.sol#1009)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CEther.sol#2214-2225) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in CEther.sol:\n\t- pragma solidity^0.5.10 (CEther.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#65): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#153): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#374): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#581): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#616-617): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#694-695): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#726-727): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#2293-2296): it allows old versions\n\t- pragma solidity^0.5.10 (CEther.sol#2366-2370): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CEther.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CEther.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CEther.sol#166) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2025,
                    "vulnerability_to_line": 2043,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CEther.sol#2025-2043) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2048,
                    "vulnerability_to_line": 2070,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CEther.sol#2048-2070) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2075,
                    "vulnerability_to_line": 2094,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CEther.sol#2075-2094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2099,
                    "vulnerability_to_line": 2109,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CEther.sol#2099-2109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2114,
                    "vulnerability_to_line": 2139,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CEther.sol#2114-2139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2144,
                    "vulnerability_to_line": 2154,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CEther.sol#2144-2154) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": 2209,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CEther.sol#2160-2209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2214,
                    "vulnerability_to_line": 2225,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CEther.sol#2214-2225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2230,
                    "vulnerability_to_line": 2261,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CEther.sol#2230-2261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CEther.sol#737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CEther.sol#757) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CEther.sol#762) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CEther is CToken {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1095,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        to.transfer(amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return Error.NO_ERROR;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/USDCInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRate_, uint multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "USDCInterestRateModel.getBorrowRate (USDCInterestRateModel.sol#455-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": "InterestRateModel.getBorrowRate (USDCInterestRateModel.sol#23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in USDCInterestRateModel.sol:\n\t- pragma solidity^0.5.10 (USDCInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (USDCInterestRateModel.sol#35): it allows old versions\n\t- pragma solidity^0.5.10 (USDCInterestRateModel.sol#123): it allows old versions\n\t- pragma solidity^0.5.10 (USDCInterestRateModel.sol#344): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (USDCInterestRateModel.sol#134) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (USDCInterestRateModel.sol#135) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (USDCInterestRateModel.sol#136) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'USDCInterestRateModel.isInterestRateModel' (USDCInterestRateModel.sol#355) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'USDCInterestRateModel.blocksPerYear' (USDCInterestRateModel.sol#370) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/SAIInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRate_, uint multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "SAIInterestRateModel.getBorrowRate (SAIInterestRateModel.sol#455-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": "InterestRateModel.getBorrowRate (SAIInterestRateModel.sol#23) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in SAIInterestRateModel.sol:\n\t- pragma solidity^0.5.10 (SAIInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (SAIInterestRateModel.sol#35): it allows old versions\n\t- pragma solidity^0.5.10 (SAIInterestRateModel.sol#123): it allows old versions\n\t- pragma solidity^0.5.10 (SAIInterestRateModel.sol#344): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (SAIInterestRateModel.sol#134) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (SAIInterestRateModel.sol#135) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (SAIInterestRateModel.sol#136) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'SAIInterestRateModel.isInterestRateModel' (SAIInterestRateModel.sol#355) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'SAIInterestRateModel.blocksPerYear' (SAIInterestRateModel.sol#370) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Oracles/_ErrorReporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in _ErrorReporter.sol:\n\t- pragma solidity^0.5.10 (_ErrorReporter.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "contract _ErrorReporter {\n\n\n\n    /**\n\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n\n      **/\n\n    event Failure(uint error, uint info, uint detail);\n\n\n\n    enum Error {\n\n        NO_ERROR,\n\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n\n        UNAUTHORIZED,\n\n        INTEGER_OVERFLOW,\n\n        INTEGER_UNDERFLOW,\n\n        DIVISION_BY_ZERO,\n\n        BAD_INPUT,\n\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n\n        TOKEN_INSUFFICIENT_BALANCE,\n\n        TOKEN_TRANSFER_FAILED,\n\n        MARKET_NOT_SUPPORTED,\n\n        SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_RATE_CALCULATION_FAILED,\n\n        TOKEN_INSUFFICIENT_CASH,\n\n        TOKEN_TRANSFER_OUT_FAILED,\n\n        INSUFFICIENT_LIQUIDITY,\n\n        INSUFFICIENT_BALANCE,\n\n        INVALID_COLLATERAL_RATIO,\n\n        MISSING_ASSET_PRICE,\n\n        EQUITY_INSUFFICIENT_BALANCE,\n\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n\n        ASSET_NOT_PRICED,\n\n        INVALID_LIQUIDATION_DISCOUNT,\n\n        INVALID_COMBINED_RISK_PARAMETERS\n\n    }\n\n\n\n    /*\n\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n\n     *       This is because FailureInfo grows significantly faster, and\n\n     *       the order of Error has some meaning, while the order of FailureInfo\n\n     *       is entirely arbitrary.\n\n     */\n\n    enum FailureInfo {\n\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        BORROW_MARKET_NOT_SUPPORTED,\n\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n\n        BORROW_TRANSFER_OUT_FAILED,\n\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_TRANSFER_IN_FAILED,\n\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n\n        SET_ADMIN_OWNER_CHECK,\n\n        SET_ASSET_PRICE_CHECK_ORACLE,\n\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n\n        SET_ORACLE_OWNER_CHECK,\n\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_VALIDATION,\n\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_MARKET_NOT_SUPPORTED,\n\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        SUPPLY_TRANSFER_IN_FAILED,\n\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n\n        SUPPORT_MARKET_OWNER_CHECK,\n\n        SUPPORT_MARKET_PRICE_CHECK,\n\n        SUSPEND_MARKET_OWNER_CHECK,\n\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n\n      */\n\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n\n        emit Failure(uint(err), uint(info), 0);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n\n      */\n\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n\n\n        return uint(Error.OPAQUE_ERROR);\n\n    }\n\n\n",
                    "message": "Contract '_ErrorReporter' (_ErrorReporter.sol#5-152) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Oracles/_Exponential.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in _Exponential.sol:\n\t- pragma solidity^0.5.10 (_Exponential.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (_Exponential.sol#156): it allows old versions\n\t- pragma solidity^0.5.10 (_Exponential.sol#228): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "contract _ErrorReporter {\n\n\n\n    /**\n\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n\n      **/\n\n    event Failure(uint error, uint info, uint detail);\n\n\n\n    enum Error {\n\n        NO_ERROR,\n\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n\n        UNAUTHORIZED,\n\n        INTEGER_OVERFLOW,\n\n        INTEGER_UNDERFLOW,\n\n        DIVISION_BY_ZERO,\n\n        BAD_INPUT,\n\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n\n        TOKEN_INSUFFICIENT_BALANCE,\n\n        TOKEN_TRANSFER_FAILED,\n\n        MARKET_NOT_SUPPORTED,\n\n        SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_RATE_CALCULATION_FAILED,\n\n        TOKEN_INSUFFICIENT_CASH,\n\n        TOKEN_TRANSFER_OUT_FAILED,\n\n        INSUFFICIENT_LIQUIDITY,\n\n        INSUFFICIENT_BALANCE,\n\n        INVALID_COLLATERAL_RATIO,\n\n        MISSING_ASSET_PRICE,\n\n        EQUITY_INSUFFICIENT_BALANCE,\n\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n\n        ASSET_NOT_PRICED,\n\n        INVALID_LIQUIDATION_DISCOUNT,\n\n        INVALID_COMBINED_RISK_PARAMETERS\n\n    }\n\n\n\n    /*\n\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n\n     *       This is because FailureInfo grows significantly faster, and\n\n     *       the order of Error has some meaning, while the order of FailureInfo\n\n     *       is entirely arbitrary.\n\n     */\n\n    enum FailureInfo {\n\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        BORROW_MARKET_NOT_SUPPORTED,\n\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n\n        BORROW_TRANSFER_OUT_FAILED,\n\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_TRANSFER_IN_FAILED,\n\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n\n        SET_ADMIN_OWNER_CHECK,\n\n        SET_ASSET_PRICE_CHECK_ORACLE,\n\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n\n        SET_ORACLE_OWNER_CHECK,\n\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_VALIDATION,\n\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_MARKET_NOT_SUPPORTED,\n\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        SUPPLY_TRANSFER_IN_FAILED,\n\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n\n        SUPPORT_MARKET_OWNER_CHECK,\n\n        SUPPORT_MARKET_PRICE_CHECK,\n\n        SUSPEND_MARKET_OWNER_CHECK,\n\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n\n      */\n\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n\n        emit Failure(uint(err), uint(info), 0);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n\n      */\n\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n\n\n        return uint(Error.OPAQUE_ERROR);\n\n    }\n\n\n",
                    "message": "Contract '_ErrorReporter' (_Exponential.sol#5-152) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "contract _CarefulMath is _ErrorReporter {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, returns an error on overflow.\n\n    */\n\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (a == 0) {\n\n            return (Error.NO_ERROR, 0);\n\n        }\n\n\n\n        uint c = a * b;\n\n\n\n        if (c / a != b) {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        } else {\n\n            return (Error.NO_ERROR, c);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b == 0) {\n\n            return (Error.DIVISION_BY_ZERO, 0);\n\n        }\n\n\n\n        return (Error.NO_ERROR, a / b);\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b <= a) {\n\n            return (Error.NO_ERROR, a - b);\n\n        } else {\n\n            return (Error.INTEGER_UNDERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, returns an error on overflow.\n\n    */\n\n    function add(uint a, uint b) internal pure returns (Error, uint) {\n\n        uint c = a + b;\n\n\n\n        if (c >= a) {\n\n            return (Error.NO_ERROR, c);\n\n        } else {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev add a and b and then subtract c\n\n    */\n\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n\n        (Error err0, uint sum) = add(a, b);\n\n\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, 0);\n\n        }\n\n\n\n        return sub(sum, c);\n\n    }\n",
                    "message": "Contract '_CarefulMath' (_Exponential.sol#158-224) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "contract _Exponential is _ErrorReporter, _CarefulMath {\n\n\n\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\n\n    uint constant expScale = 10**18;\n\n\n\n    // See TODO on expScale\n\n    uint constant halfExpScale = expScale/2;\n\n\n\n    struct Exp {\n\n        uint mantissa;\n\n    }\n\n\n\n    uint constant mantissaOne = 10**18;\n\n    uint constant mantissaOneTenth = 10**17;\n\n\n\n    /**\n\n    * @dev Creates an exponential from numerator and denominator values.\n\n    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n\n    *            or if `denom` is zero.\n\n    */\n\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        (Error err1, uint rational) = div(scaledNumerator, denom);\n\n        if (err1 != Error.NO_ERROR) {\n\n            return (err1, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two exponentials, returning a new exponential.\n\n    */\n\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\n\n\n\n        return (error, Exp({mantissa: result}));\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two exponentials, returning a new exponential.\n\n    */\n\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n\n\n\n        return (error, Exp({mantissa: result}));\n\n    }\n\n\n\n    /**\n\n    * @dev Multiply an Exp by a scalar, returning a new Exp.\n\n    */\n\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n\n    }\n\n\n\n    /**\n\n    * @dev Divide an Exp by a scalar, returning a new Exp.\n\n    */\n\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n\n    }\n\n\n\n    /**\n\n    * @dev Divide a scalar by an Exp, returning a new Exp.\n\n    */\n\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\n\n        /*\n\n            We are doing this as:\n\n            getExp(mul(expScale, scalar), divisor.mantissa)\n\n\n\n            How it works:\n\n            Exp = a / b;\n\n            Scalar = s;\n\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n\n        */\n\n        (Error err0, uint numerator) = mul(expScale, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n        return getExp(numerator, divisor.mantissa);\n\n    }\n\n\n\n    /**\n\n    * @dev Multiplies two exponentials, returning a new exponential.\n\n    */\n\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n\n\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n\n        if (err1 != Error.NO_ERROR) {\n\n            return (err1, Exp({mantissa: 0}));\n\n        }\n\n\n\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n\n        assert(err2 == Error.NO_ERROR);\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: product}));\n\n    }\n\n\n\n    /**\n\n      * @dev Divides two exponentials, returning a new exponential.\n\n      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n\n      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n\n      */\n\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        return getExp(a.mantissa, b.mantissa);\n\n    }\n\n\n\n    /**\n\n      * @dev Truncates the given exp to a whole number value.\n\n      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n\n      */\n\n    function truncate(Exp memory exp) pure internal returns (uint) {\n\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n\n        return exp.mantissa / 10**18;\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if first Exp is less than second Exp.\n\n      */\n\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if left Exp <= right Exp.\n\n      */\n\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa <= right.mantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if first Exp is greater than second Exp.\n\n      */\n\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa > right.mantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev returns true if Exp is exactly zero\n\n      */\n\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n\n        return value.mantissa == 0;\n\n    }\n",
                    "message": "Contract '_Exponential' (_Exponential.sol#230-398) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 10**18;\n",
                    "message": "Constant '_Exponential.expScale' (_Exponential.sol#235) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant '_Exponential.halfExpScale' (_Exponential.sol#238) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
                    "message": "Constant '_Exponential.mantissaOne' (_Exponential.sol#244) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
                    "message": "Constant '_Exponential.mantissaOneTenth' (_Exponential.sol#245) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
                    "message": "_Exponential.mantissaOne (_Exponential.sol#244) is never used in _Exponential\n_Exponential.mantissaOneTenth (_Exponential.sol#245) is never used in _Exponential\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 10**18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Oracles/_PriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _poster, address addr0, address reader0, address addr1, address reader1) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        anchorAdmin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        poster = _poster;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        maxSwing = Exp({mantissa : maxSwingMantissa});\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Make sure the assets are zero or different\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assert(addr0 == address(0) || (addr0 != addr1));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (addr0 != address(0)) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assert(reader0 != address(0));\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numAssets; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numAssets; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_32"
            ],
            "vulnerability_findings": [
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": 874,
                    "vulnerability_code": "    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\n\n        Exp memory numerator;\n\n        Error err;\n\n\n\n        if (greaterThanExp(anchorPrice, price)) {\n\n            (err, numerator) = subExp(anchorPrice, price);\n\n            // can't underflow\n\n            assert(err == Error.NO_ERROR);\n\n        } else {\n\n            (err, numerator) = subExp(price, anchorPrice);\n\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\n\n            assert(err == Error.NO_ERROR);\n\n        }\n\n\n\n        return divExp(numerator, anchorPrice);\n",
                    "message": "_PriceOracle.calculateSwing (_PriceOracle.sol#859-874) uses a dangerous strict equality:\n\t- assert(bool)(err == Error.NO_ERROR)\n\t- assert(bool)(err == Error.NO_ERROR)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": 874,
                    "vulnerability_code": "    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\n\n        Exp memory numerator;\n\n        Error err;\n\n\n\n        if (greaterThanExp(anchorPrice, price)) {\n\n            (err, numerator) = subExp(anchorPrice, price);\n\n            // can't underflow\n\n            assert(err == Error.NO_ERROR);\n\n        } else {\n\n            (err, numerator) = subExp(price, anchorPrice);\n\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\n\n            assert(err == Error.NO_ERROR);\n\n        }\n\n\n\n        return divExp(numerator, anchorPrice);\n",
                    "message": "_PriceOracle.calculateSwing (_PriceOracle.sol#859-874) uses a dangerous strict equality:\n\t- assert(bool)(err == Error.NO_ERROR)\n\t- assert(bool)(err == Error.NO_ERROR)\n_PriceOracle.capToMax (_PriceOracle.sol#876-919) uses a dangerous strict equality:\n\t- assert(bool)(err == Error.NO_ERROR)\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": 476,
                    "vulnerability_code": "    function() payable external {\n\n        revert();\n",
                    "message": "Contract locking ether found in _PriceOracle.sol:\n\tContract _PriceOracle has payable functions:\n\t - fallback (_PriceOracle.sol#474-476)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        SetPriceLocalVars memory localVars;\n",
                    "message": "localVars in _PriceOracle.setPriceInternal (_PriceOracle.sol#767) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function peek() public view returns (bytes32, bool);\n",
                    "message": "_DSValue.peek (_PriceOracle.sol#406) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function read() public view returns (bytes32);\n",
                    "message": "_DSValue.read (_PriceOracle.sol#408) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": 592,
                    "vulnerability_code": "    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n\n        }\n\n\n\n        uint oldScaledPrice = pendingAnchors[asset];\n\n        pendingAnchors[asset] = newScaledPrice;\n\n\n\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n\n\n\n        return uint(OracleError.NO_ERROR);\n",
                    "message": "_PriceOracle._setPendingAnchor (_PriceOracle.sol#580-592) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 625,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function _setPaused(bool requestedState) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\n\n        }\n\n\n\n        paused = requestedState;\n\n        emit SetPaused(requestedState);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "_PriceOracle._setPaused (_PriceOracle.sol#625-635) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": 659,
                    "vulnerability_code": "    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // save current value, if any, for inclusion in log\n\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n\n        // Store pendingAdmin = newPendingAdmin\n\n        pendingAnchorAdmin = newPendingAnchorAdmin;\n\n\n\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "_PriceOracle._setPendingAnchorAdmin (_PriceOracle.sol#645-659) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": 683,
                    "vulnerability_code": "    function _acceptAnchorAdmin() public returns (uint) {\n\n        // Check caller = pendingAnchorAdmin\n\n        // msg.sender can't be zero\n\n        if (msg.sender != pendingAnchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldAnchorAdmin = anchorAdmin;\n\n        // Store admin = pendingAnchorAdmin\n\n        anchorAdmin = pendingAnchorAdmin;\n\n        // Clear the pending value\n\n        pendingAnchorAdmin = address(0);\n\n\n\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "_PriceOracle._acceptAnchorAdmin (_PriceOracle.sol#666-683) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function getPrice(address asset) public view returns (uint) {\n\n        return assetPrices(asset);\n",
                    "message": "_PriceOracle.getPrice (_PriceOracle.sol#733-735) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 755,
                    "vulnerability_to_line": 762,
                    "vulnerability_code": "    function setPrice(address asset, uint requestedPriceMantissa) public returns (uint) {\n\n        // Fail when msg.sender is not poster\n\n        if (msg.sender != poster) {\n\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n\n        }\n\n\n\n        return setPriceInternal(asset, requestedPriceMantissa);\n",
                    "message": "_PriceOracle.setPrice (_PriceOracle.sol#755-762) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": 953,
                    "vulnerability_code": "    function setPrices(address[] memory assets, uint[] memory requestedPriceMantissas) public returns (uint[] memory) {\n\n        uint numAssets = assets.length;\n\n        uint numPrices = requestedPriceMantissas.length;\n\n        uint[] memory result;\n\n\n\n        // Fail when msg.sender is not poster\n\n        if (msg.sender != poster) {\n\n            result = new uint[](1);\n\n            result[0] = failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n\n            return result;\n\n        }\n\n\n\n        if ((numAssets == 0) || (numPrices != numAssets)) {\n\n            result = new uint[](1);\n\n            result[0] = failOracle(address(0), OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICES_PARAM_VALIDATION);\n\n            return result;\n\n        }\n\n\n\n        result = new uint[](numAssets);\n\n\n\n        for (uint i = 0; i < numAssets; i++) {\n\n            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\n\n        }\n\n\n\n        return result;\n",
                    "message": "_PriceOracle.setPrices (_PriceOracle.sol#928-953) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in _PriceOracle.sol:\n\t- pragma solidity^0.5.10 (_PriceOracle.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (_PriceOracle.sol#156): it allows old versions\n\t- pragma solidity^0.5.10 (_PriceOracle.sol#228): it allows old versions\n\t- pragma solidity^0.5.10 (_PriceOracle.sol#402): it allows old versions\n\t- pragma solidity^0.5.10 (_PriceOracle.sol#413): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "contract _ErrorReporter {\n\n\n\n    /**\n\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n\n      **/\n\n    event Failure(uint error, uint info, uint detail);\n\n\n\n    enum Error {\n\n        NO_ERROR,\n\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n\n        UNAUTHORIZED,\n\n        INTEGER_OVERFLOW,\n\n        INTEGER_UNDERFLOW,\n\n        DIVISION_BY_ZERO,\n\n        BAD_INPUT,\n\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n\n        TOKEN_INSUFFICIENT_BALANCE,\n\n        TOKEN_TRANSFER_FAILED,\n\n        MARKET_NOT_SUPPORTED,\n\n        SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_RATE_CALCULATION_FAILED,\n\n        TOKEN_INSUFFICIENT_CASH,\n\n        TOKEN_TRANSFER_OUT_FAILED,\n\n        INSUFFICIENT_LIQUIDITY,\n\n        INSUFFICIENT_BALANCE,\n\n        INVALID_COLLATERAL_RATIO,\n\n        MISSING_ASSET_PRICE,\n\n        EQUITY_INSUFFICIENT_BALANCE,\n\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n\n        ASSET_NOT_PRICED,\n\n        INVALID_LIQUIDATION_DISCOUNT,\n\n        INVALID_COMBINED_RISK_PARAMETERS\n\n    }\n\n\n\n    /*\n\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n\n     *       This is because FailureInfo grows significantly faster, and\n\n     *       the order of Error has some meaning, while the order of FailureInfo\n\n     *       is entirely arbitrary.\n\n     */\n\n    enum FailureInfo {\n\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        BORROW_MARKET_NOT_SUPPORTED,\n\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n\n        BORROW_TRANSFER_OUT_FAILED,\n\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_TRANSFER_IN_FAILED,\n\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n\n        SET_ADMIN_OWNER_CHECK,\n\n        SET_ASSET_PRICE_CHECK_ORACLE,\n\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n\n        SET_ORACLE_OWNER_CHECK,\n\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_VALIDATION,\n\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_MARKET_NOT_SUPPORTED,\n\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        SUPPLY_TRANSFER_IN_FAILED,\n\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n\n        SUPPORT_MARKET_OWNER_CHECK,\n\n        SUPPORT_MARKET_PRICE_CHECK,\n\n        SUSPEND_MARKET_OWNER_CHECK,\n\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n\n      */\n\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n\n        emit Failure(uint(err), uint(info), 0);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n\n      */\n\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n\n\n        return uint(Error.OPAQUE_ERROR);\n\n    }\n\n\n",
                    "message": "Contract '_ErrorReporter' (_PriceOracle.sol#5-152) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "contract _CarefulMath is _ErrorReporter {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, returns an error on overflow.\n\n    */\n\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (a == 0) {\n\n            return (Error.NO_ERROR, 0);\n\n        }\n\n\n\n        uint c = a * b;\n\n\n\n        if (c / a != b) {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        } else {\n\n            return (Error.NO_ERROR, c);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b == 0) {\n\n            return (Error.DIVISION_BY_ZERO, 0);\n\n        }\n\n\n\n        return (Error.NO_ERROR, a / b);\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b <= a) {\n\n            return (Error.NO_ERROR, a - b);\n\n        } else {\n\n            return (Error.INTEGER_UNDERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, returns an error on overflow.\n\n    */\n\n    function add(uint a, uint b) internal pure returns (Error, uint) {\n\n        uint c = a + b;\n\n\n\n        if (c >= a) {\n\n            return (Error.NO_ERROR, c);\n\n        } else {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev add a and b and then subtract c\n\n    */\n\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n\n        (Error err0, uint sum) = add(a, b);\n\n\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, 0);\n\n        }\n\n\n\n        return sub(sum, c);\n\n    }\n",
                    "message": "Contract '_CarefulMath' (_PriceOracle.sol#158-224) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 398,
                    "vulnerability_code": "contract _Exponential is _ErrorReporter, _CarefulMath {\n\n\n\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\n\n    uint constant expScale = 10**18;\n\n\n\n    // See TODO on expScale\n\n    uint constant halfExpScale = expScale/2;\n\n\n\n    struct Exp {\n\n        uint mantissa;\n\n    }\n\n\n\n    uint constant mantissaOne = 10**18;\n\n    uint constant mantissaOneTenth = 10**17;\n\n\n\n    /**\n\n    * @dev Creates an exponential from numerator and denominator values.\n\n    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n\n    *            or if `denom` is zero.\n\n    */\n\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        (Error err1, uint rational) = div(scaledNumerator, denom);\n\n        if (err1 != Error.NO_ERROR) {\n\n            return (err1, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two exponentials, returning a new exponential.\n\n    */\n\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\n\n\n\n        return (error, Exp({mantissa: result}));\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two exponentials, returning a new exponential.\n\n    */\n\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n\n\n\n        return (error, Exp({mantissa: result}));\n\n    }\n\n\n\n    /**\n\n    * @dev Multiply an Exp by a scalar, returning a new Exp.\n\n    */\n\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n\n    }\n\n\n\n    /**\n\n    * @dev Divide an Exp by a scalar, returning a new Exp.\n\n    */\n\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n\n    }\n\n\n\n    /**\n\n    * @dev Divide a scalar by an Exp, returning a new Exp.\n\n    */\n\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\n\n        /*\n\n            We are doing this as:\n\n            getExp(mul(expScale, scalar), divisor.mantissa)\n\n\n\n            How it works:\n\n            Exp = a / b;\n\n            Scalar = s;\n\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n\n        */\n\n        (Error err0, uint numerator) = mul(expScale, scalar);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n        return getExp(numerator, divisor.mantissa);\n\n    }\n\n\n\n    /**\n\n    * @dev Multiplies two exponentials, returning a new exponential.\n\n    */\n\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n\n\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, Exp({mantissa: 0}));\n\n        }\n\n\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n\n        if (err1 != Error.NO_ERROR) {\n\n            return (err1, Exp({mantissa: 0}));\n\n        }\n\n\n\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n\n        assert(err2 == Error.NO_ERROR);\n\n\n\n        return (Error.NO_ERROR, Exp({mantissa: product}));\n\n    }\n\n\n\n    /**\n\n      * @dev Divides two exponentials, returning a new exponential.\n\n      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n\n      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n\n      */\n\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        return getExp(a.mantissa, b.mantissa);\n\n    }\n\n\n\n    /**\n\n      * @dev Truncates the given exp to a whole number value.\n\n      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n\n      */\n\n    function truncate(Exp memory exp) pure internal returns (uint) {\n\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n\n        return exp.mantissa / 10**18;\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if first Exp is less than second Exp.\n\n      */\n\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if left Exp <= right Exp.\n\n      */\n\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa <= right.mantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev Checks if first Exp is greater than second Exp.\n\n      */\n\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n\n        return left.mantissa > right.mantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev returns true if Exp is exactly zero\n\n      */\n\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n\n        return value.mantissa == 0;\n\n    }\n",
                    "message": "Contract '_Exponential' (_PriceOracle.sol#230-398) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 10**18;\n",
                    "message": "Constant '_Exponential.expScale' (_PriceOracle.sol#235) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant '_Exponential.halfExpScale' (_PriceOracle.sol#238) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
                    "message": "Constant '_Exponential.mantissaOne' (_PriceOracle.sol#244) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
                    "message": "Constant '_Exponential.mantissaOneTenth' (_PriceOracle.sol#245) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 404,
                    "vulnerability_to_line": 409,
                    "vulnerability_code": "contract _DSValue {\n\n    // TODO: View or constant? It's clearly a view...\n\n    function peek() public view returns (bytes32, bool);\n\n\n\n    function read() public view returns (bytes32);\n",
                    "message": "Contract '_DSValue' (_PriceOracle.sol#404-409) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 954,
                    "vulnerability_code": "contract _PriceOracle is _Exponential {\n\n\n\n    /**\n\n      * @dev flag for whether or not contract is paused\n\n      *\n\n      */\n\n    bool public paused;\n\n\n\n    uint public constant numBlocksPerPeriod = 240; // approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds\n\n\n\n    uint public constant maxSwingMantissa = (10 ** 17); // 0.1\n\n\n\n    /**\n\n      * @dev Mapping of asset addresses to DSValue price oracle contracts. The price contracts\n\n      *      should be DSValue contracts whose value is the `eth:asset` price scaled by 1e18.\n\n      *      That is, 1 eth is worth how much of the asset (e.g. 1 eth = 100 USD). We want\n\n      *      to know the inverse, which is how much eth is one asset worth. This `asset:eth`\n\n      *      is the multiplicative inverse (in that example, 1/100). The math is a bit trickier\n\n      *      since we need to descale the number by 1e18, inverse, and then rescale the number.\n\n      *      We perform this operation to return the `asset:eth` price for these reader assets.\n\n      *\n\n      * map: assetAddress -> DSValue price oracle\n\n      */\n\n    mapping(address => _DSValue) public readers;\n\n\n\n    /**\n\n      * @dev Mapping of asset addresses and their corresponding price in terms of Eth-Wei\n\n      *      which is simply equal to AssetWeiPrice * 10e18. For instance, if OMG token was\n\n      *      worth 5x Eth then the price for OMG would be 5*10e18 or Exp({mantissa: 5000000000000000000}).\n\n      * map: assetAddress -> Exp\n\n      */\n\n    mapping(address => Exp) public _assetPrices;\n\n\n\n    constructor(address _poster, address addr0, address reader0, address addr1, address reader1) public {\n\n        anchorAdmin = msg.sender;\n\n        poster = _poster;\n\n        maxSwing = Exp({mantissa : maxSwingMantissa});\n\n\n\n        // Make sure the assets are zero or different\n\n        assert(addr0 == address(0) || (addr0 != addr1));\n\n\n\n        if (addr0 != address(0)) {\n\n            assert(reader0 != address(0));\n\n            readers[addr0] = _DSValue(reader0);\n\n        } else {\n\n            assert(reader0 == address(0));\n\n        }\n\n\n\n        if (addr1 != address(0)) {\n\n            assert(reader1 != address(0));\n\n            readers[addr1] = _DSValue(reader1);\n\n        } else {\n\n            assert(reader1 == address(0));\n\n        }\n\n    }\n\n\n\n    /**\n\n      * @notice Do not pay into PriceOracle\n\n      */\n\n    function() payable external {\n\n        revert();\n\n    }\n\n\n\n    enum OracleError {\n\n        NO_ERROR,\n\n        UNAUTHORIZED,\n\n        FAILED_TO_SET_PRICE\n\n    }\n\n\n\n    enum OracleFailureInfo {\n\n        ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK,\n\n        SET_PAUSED_OWNER_CHECK,\n\n        SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK,\n\n        SET_PENDING_ANCHOR_PERMISSION_CHECK,\n\n        SET_PRICE_CALCULATE_SWING,\n\n        SET_PRICE_CAP_TO_MAX,\n\n        SET_PRICE_MAX_SWING_CHECK,\n\n        SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO,\n\n        SET_PRICE_PERMISSION_CHECK,\n\n        SET_PRICE_ZERO_PRICE,\n\n        SET_PRICES_PARAM_VALIDATION,\n\n        SET_PRICE_IS_READER_ASSET\n\n    }\n\n\n\n    /**\n\n      * @dev `msgSender` is msg.sender; `error` corresponds to enum OracleError; `info` corresponds to enum OracleFailureInfo, and `detail` is an arbitrary\n\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n\n      **/\n\n    event OracleFailure(address msgSender, address asset, uint error, uint info, uint detail);\n\n\n\n    /**\n\n      * @dev use this when reporting a known error from the price oracle or a non-upgradeable collaborator\n\n      *      Using Oracle in name because we already inherit a `fail` function from ErrorReporter.sol via Exponential.sol\n\n      */\n\n    function failOracle(address asset, OracleError err, OracleFailureInfo info) internal returns (uint) {\n\n        emit OracleFailure(msg.sender, asset, uint(err), uint(info), 0);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n    /**\n\n      * @dev Use this when reporting an error from the money market. Give the money market result as `details`\n\n      */\n\n    function failOracleWithDetails(address asset, OracleError err, OracleFailureInfo info, uint details) internal returns (uint) {\n\n        emit OracleFailure(msg.sender, asset, uint(err), uint(info), details);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n    /**\n\n      * @dev An administrator who can set the pending anchor value for assets.\n\n      *      Set in the constructor.\n\n      */\n\n    address public anchorAdmin;\n\n\n\n    /**\n\n      * @dev pending anchor administrator for this contract.\n\n      */\n\n    address public pendingAnchorAdmin;\n\n\n\n    /**\n\n      * @dev Address of the price poster.\n\n      *      Set in the constructor.\n\n      */\n\n    address public poster;\n\n\n\n    /**\n\n      * @dev maxSwing the maximum allowed percentage difference between a new price and the anchor's price\n\n      *      Set only in the constructor\n\n      */\n\n    Exp public maxSwing;\n\n\n\n    struct Anchor {\n\n        // floor(block.number / numBlocksPerPeriod) + 1\n\n        uint period;\n\n\n\n        // Price in ETH, scaled by 10**18\n\n        uint priceMantissa;\n\n    }\n\n\n\n    /**\n\n      * @dev anchors by asset\n\n      */\n\n    mapping(address => Anchor) public anchors;\n\n\n\n    /**\n\n      * @dev pending anchor prices by asset\n\n      */\n\n    mapping(address => uint) public pendingAnchors;\n\n\n\n    /**\n\n      * @dev emitted when a pending anchor is set\n\n      * @param asset Asset for which to set a pending anchor\n\n      * @param oldScaledPrice if an unused pending anchor was present, its value; otherwise 0.\n\n      * @param newScaledPrice the new scaled pending anchor price\n\n      */\n\n    event NewPendingAnchor(address anchorAdmin, address asset, uint oldScaledPrice, uint newScaledPrice);\n\n\n\n    /**\n\n      * @notice provides ability to override the anchor price for an asset\n\n      * @dev Admin function to set the anchor price for an asset\n\n      * @param asset Asset for which to override the anchor price\n\n      * @param newScaledPrice New anchor price\n\n      * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n\n      */\n\n    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n\n        }\n\n\n\n        uint oldScaledPrice = pendingAnchors[asset];\n\n        pendingAnchors[asset] = newScaledPrice;\n\n\n\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n\n\n\n        return uint(OracleError.NO_ERROR);\n\n    }\n\n\n\n    /**\n\n      * @dev emitted for all price changes\n\n      */\n\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n\n\n    /**\n\n      * @dev emitted if this contract successfully posts a capped-to-max price to the money market\n\n      */\n\n    event CappedPricePosted(address asset, uint requestedPriceMantissa, uint anchorPriceMantissa, uint cappedPriceMantissa);\n\n\n\n    /**\n\n      * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n\n      */\n\n    event SetPaused(bool newState);\n\n\n\n    /**\n\n      * @dev emitted when pendingAnchorAdmin is changed\n\n      */\n\n    event NewPendingAnchorAdmin(address oldPendingAnchorAdmin, address newPendingAnchorAdmin);\n\n\n\n    /**\n\n      * @dev emitted when pendingAnchorAdmin is accepted, which means anchor admin is updated\n\n      */\n\n    event NewAnchorAdmin(address oldAnchorAdmin, address newAnchorAdmin);\n\n\n\n    /**\n\n      * @notice set `paused` to the specified state\n\n      * @dev Admin function to pause or resume the market\n\n      * @param requestedState value to assign to `paused`\n\n      * @return uint 0=success, otherwise a failure\n\n      */\n\n    function _setPaused(bool requestedState) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\n\n        }\n\n\n\n        paused = requestedState;\n\n        emit SetPaused(requestedState);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n\n      * @notice Begins transfer of anchor admin rights. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\n\n      * @dev Admin function to begin change of anchor admin. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\n\n      * @param newPendingAnchorAdmin New pending anchor admin.\n\n      * @return uint 0=success, otherwise a failure\n\n      *\n\n      * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\n\n      */\n\n    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // save current value, if any, for inclusion in log\n\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n\n        // Store pendingAdmin = newPendingAdmin\n\n        pendingAnchorAdmin = newPendingAnchorAdmin;\n\n\n\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n\n      * @notice Accepts transfer of anchor admin rights. msg.sender must be pendingAnchorAdmin\n\n      * @dev Admin function for pending anchor admin to accept role and update anchor admin\n\n      * @return uint 0=success, otherwise a failure\n\n      */\n\n    function _acceptAnchorAdmin() public returns (uint) {\n\n        // Check caller = pendingAnchorAdmin\n\n        // msg.sender can't be zero\n\n        if (msg.sender != pendingAnchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldAnchorAdmin = anchorAdmin;\n\n        // Store admin = pendingAnchorAdmin\n\n        anchorAdmin = pendingAnchorAdmin;\n\n        // Clear the pending value\n\n        pendingAnchorAdmin = address(0);\n\n\n\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n\n      * @notice retrieves price of an asset\n\n      * @dev function to get price for an asset\n\n      * @param asset Asset for which to get the price\n\n      * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\n\n      */\n\n    function assetPrices(address asset) public view returns (uint) {\n\n        // Note: zero is treated by the money market as an invalid\n\n        //       price and will cease operations with that asset\n\n        //       when zero.\n\n        //\n\n        // We get the price as:\n\n        //\n\n        //  1. If the contract is paused, return 0.\n\n        //  2. If the asset is a reader asset:\n\n        //    a. If the reader has a value set, invert it and return.\n\n        //    b. Else, return 0.\n\n        //  3. Return price in `_assetPrices`, which may be zero.\n\n\n\n        if (paused) {\n\n            return 0;\n\n        } else {\n\n            if (address(readers[asset]) != address(0)) {\n\n                (bytes32 readValue, bool foundValue) = readers[asset].peek();\n\n\n\n                if (foundValue) {\n\n                    (Error error, Exp memory invertedVal) = getExp(mantissaOne, uint256(readValue));\n\n\n\n                    if (error != Error.NO_ERROR) {\n\n                        return 0;\n\n                    }\n\n\n\n                    return invertedVal.mantissa;\n\n                } else {\n\n                    return 0;\n\n                }\n\n            } else {\n\n                return _assetPrices[asset].mantissa;\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n\n      * @notice retrieves price of an asset\n\n      * @dev function to get price for an asset\n\n      * @param asset Asset for which to get the price\n\n      * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\n\n      */\n\n    function getPrice(address asset) public view returns (uint) {\n\n        return assetPrices(asset);\n\n    }\n\n\n\n    struct SetPriceLocalVars {\n\n        Exp price;\n\n        Exp swing;\n\n        Exp anchorPrice;\n\n        uint anchorPeriod;\n\n        uint currentPeriod;\n\n        bool priceCapped;\n\n        uint cappingAnchorPriceMantissa;\n\n        uint pendingAnchorMantissa;\n\n    }\n\n\n\n    /**\n\n      * @notice entry point for updating prices\n\n      * @dev function to set price for an asset\n\n      * @param asset Asset for which to set the price\n\n      * @param requestedPriceMantissa requested new price, scaled by 10**18\n\n      * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n\n      */\n\n    function setPrice(address asset, uint requestedPriceMantissa) public returns (uint) {\n\n        // Fail when msg.sender is not poster\n\n        if (msg.sender != poster) {\n\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n\n        }\n\n\n\n        return setPriceInternal(asset, requestedPriceMantissa);\n\n    }\n\n\n\n    function setPriceInternal(address asset, uint requestedPriceMantissa) internal returns (uint) {\n\n        // re-used for intermediate errors\n\n        Error err;\n\n        SetPriceLocalVars memory localVars;\n\n        // We add 1 for currentPeriod so that it can never be zero and there's no ambiguity about an unset value.\n\n        // (It can be a problem in tests with low block numbers.)\n\n        localVars.currentPeriod = (block.number / numBlocksPerPeriod) + 1;\n\n        localVars.pendingAnchorMantissa = pendingAnchors[asset];\n\n        localVars.price = Exp({mantissa : requestedPriceMantissa});\n\n\n\n        if (address(readers[asset]) != address(0)) {\n\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_IS_READER_ASSET);\n\n        }\n\n\n\n        if (localVars.pendingAnchorMantissa != 0) {\n\n            // let's explicitly set to 0 rather than relying on default of declaration\n\n            localVars.anchorPeriod = 0;\n\n            localVars.anchorPrice = Exp({mantissa : localVars.pendingAnchorMantissa});\n\n\n\n            // Verify movement is within max swing of pending anchor (currently: 10%)\n\n            (err, localVars.swing) = calculateSwing(localVars.anchorPrice, localVars.price);\n\n            if (err != Error.NO_ERROR) {\n\n                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CALCULATE_SWING, uint(err));\n\n            }\n\n\n\n            // Fail when swing > maxSwing\n\n            if (greaterThanExp(localVars.swing, maxSwing)) {\n\n                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_MAX_SWING_CHECK, localVars.swing.mantissa);\n\n            }\n\n        } else {\n\n            localVars.anchorPeriod = anchors[asset].period;\n\n            localVars.anchorPrice = Exp({mantissa : anchors[asset].priceMantissa});\n\n\n\n            if (localVars.anchorPeriod != 0) {\n\n                (err, localVars.priceCapped, localVars.price) = capToMax(localVars.anchorPrice, localVars.price);\n\n                if (err != Error.NO_ERROR) {\n\n                    return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CAP_TO_MAX, uint(err));\n\n                }\n\n                if (localVars.priceCapped) {\n\n                    // save for use in log\n\n                    localVars.cappingAnchorPriceMantissa = localVars.anchorPrice.mantissa;\n\n                }\n\n            } else {\n\n                // Setting first price. Accept as is (already assigned above from requestedPriceMantissa) and use as anchor\n\n                localVars.anchorPrice = Exp({mantissa : requestedPriceMantissa});\n\n            }\n\n        }\n\n\n\n        // Fail if anchorPrice or price is zero.\n\n        // zero anchor represents an unexpected situation likely due to a problem in this contract\n\n        // zero price is more likely as the result of bad input from the caller of this function\n\n        if (isZeroExp(localVars.anchorPrice)) {\n\n            // If we get here price could also be zero, but it does not seem worthwhile to distinguish the 3rd case\n\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO);\n\n        }\n\n\n\n        if (isZeroExp(localVars.price)) {\n\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_ZERO_PRICE);\n\n        }\n\n\n\n        // BEGIN SIDE EFFECTS\n\n\n\n        // Set pendingAnchor = Nothing\n\n        // Pending anchor is only used once.\n\n        if (pendingAnchors[asset] != 0) {\n\n            pendingAnchors[asset] = 0;\n\n        }\n\n\n\n        // If currentPeriod > anchorPeriod:\n\n        //  Set anchors[asset] = (currentPeriod, price)\n\n        //  The new anchor is if we're in a new period or we had a pending anchor, then we become the new anchor\n\n        if (localVars.currentPeriod > localVars.anchorPeriod) {\n\n            anchors[asset] = Anchor({period : localVars.currentPeriod, priceMantissa : localVars.price.mantissa});\n\n        }\n\n\n\n        uint previousPrice = _assetPrices[asset].mantissa;\n\n\n\n        setPriceStorageInternal(asset, localVars.price.mantissa);\n\n\n\n        emit PricePosted(asset, previousPrice, requestedPriceMantissa, localVars.price.mantissa);\n\n\n\n        if (localVars.priceCapped) {\n\n            // We have set a capped price. Log it so we can detect the situation and investigate.\n\n            emit CappedPricePosted(asset, requestedPriceMantissa, localVars.cappingAnchorPriceMantissa, localVars.price.mantissa);\n\n        }\n\n\n\n        return uint(OracleError.NO_ERROR);\n\n    }\n\n\n\n    // As a function to allow harness overrides\n\n    function setPriceStorageInternal(address asset, uint256 priceMantissa) internal {\n\n        _assetPrices[asset] = Exp({mantissa: priceMantissa});\n\n    }\n\n\n\n    // abs(price - anchorPrice) / anchorPrice\n\n    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\n\n        Exp memory numerator;\n\n        Error err;\n\n\n\n        if (greaterThanExp(anchorPrice, price)) {\n\n            (err, numerator) = subExp(anchorPrice, price);\n\n            // can't underflow\n\n            assert(err == Error.NO_ERROR);\n\n        } else {\n\n            (err, numerator) = subExp(price, anchorPrice);\n\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\n\n            assert(err == Error.NO_ERROR);\n\n        }\n\n\n\n        return divExp(numerator, anchorPrice);\n\n    }\n\n\n\n    function capToMax(Exp memory anchorPrice, Exp memory price) view internal returns (Error, bool, Exp memory) {\n\n        Exp memory one = Exp({mantissa : mantissaOne});\n\n        Exp memory onePlusMaxSwing;\n\n        Exp memory oneMinusMaxSwing;\n\n        Exp memory max;\n\n        Exp memory min;\n\n        // re-used for intermediate errors\n\n        Error err;\n\n\n\n        (err, onePlusMaxSwing) = addExp(one, maxSwing);\n\n        if (err != Error.NO_ERROR) {\n\n            return (err, false, Exp({mantissa : 0}));\n\n        }\n\n\n\n        // max = anchorPrice * (1 + maxSwing)\n\n        (err, max) = mulExp(anchorPrice, onePlusMaxSwing);\n\n        if (err != Error.NO_ERROR) {\n\n            return (err, false, Exp({mantissa : 0}));\n\n        }\n\n\n\n        // If price > anchorPrice * (1 + maxSwing)\n\n        // Set price = anchorPrice * (1 + maxSwing)\n\n        if (greaterThanExp(price, max)) {\n\n            return (Error.NO_ERROR, true, max);\n\n        }\n\n\n\n        (err, oneMinusMaxSwing) = subExp(one, maxSwing);\n\n        if (err != Error.NO_ERROR) {\n\n            return (err, false, Exp({mantissa : 0}));\n\n        }\n\n\n\n        // min = anchorPrice * (1 - maxSwing)\n\n        (err, min) = mulExp(anchorPrice, oneMinusMaxSwing);\n\n        // We can't overflow here or we would have already overflowed above when calculating `max`\n\n        assert(err == Error.NO_ERROR);\n\n\n\n        // If  price < anchorPrice * (1 - maxSwing)\n\n        // Set price = anchorPrice * (1 - maxSwing)\n\n        if (lessThanExp(price, min)) {\n\n            return (Error.NO_ERROR, true, min);\n\n        }\n\n\n\n        return (Error.NO_ERROR, false, price);\n\n    }\n\n\n\n    /**\n\n      * @notice entry point for updating multiple prices\n\n      * @dev function to set prices for a variable number of assets.\n\n      * @param assets a list of up to assets for which to set a price. required: 0 < assets.length == requestedPriceMantissas.length\n\n      * @param requestedPriceMantissas requested new prices for the assets, scaled by 10**18. required: 0 < assets.length == requestedPriceMantissas.length\n\n      * @return uint values in same order as inputs. For each: 0=success, otherwise a failure (see enum OracleError for details)\n\n      */\n\n    function setPrices(address[] memory assets, uint[] memory requestedPriceMantissas) public returns (uint[] memory) {\n\n        uint numAssets = assets.length;\n\n        uint numPrices = requestedPriceMantissas.length;\n\n        uint[] memory result;\n\n\n\n        // Fail when msg.sender is not poster\n\n        if (msg.sender != poster) {\n\n            result = new uint[](1);\n\n            result[0] = failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n\n            return result;\n\n        }\n\n\n\n        if ((numAssets == 0) || (numPrices != numAssets)) {\n\n            result = new uint[](1);\n\n            result[0] = failOracle(address(0), OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICES_PARAM_VALIDATION);\n\n            return result;\n\n        }\n\n\n\n        result = new uint[](numAssets);\n\n\n\n        for (uint i = 0; i < numAssets; i++) {\n\n            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\n\n        }\n\n\n\n        return result;\n\n    }\n",
                    "message": "Contract '_PriceOracle' (_PriceOracle.sol#415-954) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _poster, address addr0, address reader0, address addr1, address reader1) public {\n",
                    "message": "Parameter '_poster' of _PriceOracle. (_PriceOracle.sol#448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": 592,
                    "vulnerability_code": "    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n\n        }\n\n\n\n        uint oldScaledPrice = pendingAnchors[asset];\n\n        pendingAnchors[asset] = newScaledPrice;\n\n\n\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n\n\n\n        return uint(OracleError.NO_ERROR);\n",
                    "message": "Function '_PriceOracle._setPendingAnchor' (_PriceOracle.sol#580-592) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 625,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function _setPaused(bool requestedState) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\n\n        }\n\n\n\n        paused = requestedState;\n\n        emit SetPaused(requestedState);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function '_PriceOracle._setPaused' (_PriceOracle.sol#625-635) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": 659,
                    "vulnerability_code": "    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // save current value, if any, for inclusion in log\n\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n\n        // Store pendingAdmin = newPendingAdmin\n\n        pendingAnchorAdmin = newPendingAnchorAdmin;\n\n\n\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function '_PriceOracle._setPendingAnchorAdmin' (_PriceOracle.sol#645-659) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": 683,
                    "vulnerability_code": "    function _acceptAnchorAdmin() public returns (uint) {\n\n        // Check caller = pendingAnchorAdmin\n\n        // msg.sender can't be zero\n\n        if (msg.sender != pendingAnchorAdmin) {\n\n            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldAnchorAdmin = anchorAdmin;\n\n        // Store admin = pendingAnchorAdmin\n\n        anchorAdmin = pendingAnchorAdmin;\n\n        // Clear the pending value\n\n        pendingAnchorAdmin = address(0);\n\n\n\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function '_PriceOracle._acceptAnchorAdmin' (_PriceOracle.sol#666-683) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant numBlocksPerPeriod = 240; // approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds\n",
                    "message": "Constant '_PriceOracle.numBlocksPerPeriod' (_PriceOracle.sol#423) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant maxSwingMantissa = (10 ** 17); // 0.1\n",
                    "message": "Constant '_PriceOracle.maxSwingMantissa' (_PriceOracle.sol#425) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => Exp) public _assetPrices;\n",
                    "message": "Variable '_PriceOracle._assetPrices' (_PriceOracle.sol#446) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
                    "message": "_Exponential.mantissaOneTenth (_PriceOracle.sol#245) is never used in _PriceOracle\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 670,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 678,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAnchorAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            result[0] = failOracle(address(0), OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            result[0] = failOracle(address(0), OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICES_PARAM_VALIDATION);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numAssets; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract _PriceOracle is _Exponential {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REDUNDANT_FALLBACK_REJECT",
                    "vulnerability_from_line": 474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function() payable external {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function peek() public view returns (bytes32, bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 876,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function capToMax(Exp memory anchorPrice, Exp memory price) view internal returns (Error, bool, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 10**18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = 10**18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOneTenth = 10**17;\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Oracles/_DSValue.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function peek() public view returns (bytes32, bool);\n",
                    "message": "_DSValue.peek (_DSValue.sol#7) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function read() public view returns (bytes32);\n",
                    "message": "_DSValue.read (_DSValue.sol#9) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in _DSValue.sol:\n\t- pragma solidity^0.5.10 (_DSValue.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 10,
                    "vulnerability_code": "contract _DSValue {\n\n    // TODO: View or constant? It's clearly a view...\n\n    function peek() public view returns (bytes32, bool);\n\n\n\n    function read() public view returns (bytes32);\n",
                    "message": "Contract '_DSValue' (_DSValue.sol#5-10) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function peek() public view returns (bytes32, bool);\n",
                    "message": null
                }
            ]
        }
    },
    "atomicloans-eth-contracts-10c2493d6851dcf59ee3d99519f0228b4bc2afaf/contracts/Compound/Oracles/_CarefulMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": "Detected issues with version pragma in _CarefulMath.sol:\n\t- pragma solidity^0.5.10 (_CarefulMath.sol#3): it allows old versions\n\t- pragma solidity^0.5.10 (_CarefulMath.sol#156): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "contract _ErrorReporter {\n\n\n\n    /**\n\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n\n      **/\n\n    event Failure(uint error, uint info, uint detail);\n\n\n\n    enum Error {\n\n        NO_ERROR,\n\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n\n        UNAUTHORIZED,\n\n        INTEGER_OVERFLOW,\n\n        INTEGER_UNDERFLOW,\n\n        DIVISION_BY_ZERO,\n\n        BAD_INPUT,\n\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n\n        TOKEN_INSUFFICIENT_BALANCE,\n\n        TOKEN_TRANSFER_FAILED,\n\n        MARKET_NOT_SUPPORTED,\n\n        SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_RATE_CALCULATION_FAILED,\n\n        TOKEN_INSUFFICIENT_CASH,\n\n        TOKEN_TRANSFER_OUT_FAILED,\n\n        INSUFFICIENT_LIQUIDITY,\n\n        INSUFFICIENT_BALANCE,\n\n        INVALID_COLLATERAL_RATIO,\n\n        MISSING_ASSET_PRICE,\n\n        EQUITY_INSUFFICIENT_BALANCE,\n\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n\n        ASSET_NOT_PRICED,\n\n        INVALID_LIQUIDATION_DISCOUNT,\n\n        INVALID_COMBINED_RISK_PARAMETERS\n\n    }\n\n\n\n    /*\n\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n\n     *       This is because FailureInfo grows significantly faster, and\n\n     *       the order of Error has some meaning, while the order of FailureInfo\n\n     *       is entirely arbitrary.\n\n     */\n\n    enum FailureInfo {\n\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        BORROW_MARKET_NOT_SUPPORTED,\n\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n\n        BORROW_TRANSFER_OUT_FAILED,\n\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n\n        LIQUIDATE_TRANSFER_IN_FAILED,\n\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n\n        SET_ADMIN_OWNER_CHECK,\n\n        SET_ASSET_PRICE_CHECK_ORACLE,\n\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n\n        SET_ORACLE_OWNER_CHECK,\n\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n\n        SET_RISK_PARAMETERS_VALIDATION,\n\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_MARKET_NOT_SUPPORTED,\n\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        SUPPLY_TRANSFER_IN_FAILED,\n\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n\n        SUPPORT_MARKET_OWNER_CHECK,\n\n        SUPPORT_MARKET_PRICE_CHECK,\n\n        SUSPEND_MARKET_OWNER_CHECK,\n\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_FAILED,\n\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n\n      */\n\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n\n        emit Failure(uint(err), uint(info), 0);\n\n\n\n        return uint(err);\n\n    }\n\n\n\n\n\n    /**\n\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n\n      */\n\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n\n\n        return uint(Error.OPAQUE_ERROR);\n\n    }\n\n\n",
                    "message": "Contract '_ErrorReporter' (_CarefulMath.sol#5-152) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "contract _CarefulMath is _ErrorReporter {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, returns an error on overflow.\n\n    */\n\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (a == 0) {\n\n            return (Error.NO_ERROR, 0);\n\n        }\n\n\n\n        uint c = a * b;\n\n\n\n        if (c / a != b) {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        } else {\n\n            return (Error.NO_ERROR, c);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers, truncating the quotient.\n\n    */\n\n    function div(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b == 0) {\n\n            return (Error.DIVISION_BY_ZERO, 0);\n\n        }\n\n\n\n        return (Error.NO_ERROR, a / b);\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\n\n        if (b <= a) {\n\n            return (Error.NO_ERROR, a - b);\n\n        } else {\n\n            return (Error.INTEGER_UNDERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, returns an error on overflow.\n\n    */\n\n    function add(uint a, uint b) internal pure returns (Error, uint) {\n\n        uint c = a + b;\n\n\n\n        if (c >= a) {\n\n            return (Error.NO_ERROR, c);\n\n        } else {\n\n            return (Error.INTEGER_OVERFLOW, 0);\n\n        }\n\n    }\n\n\n\n    /**\n\n    * @dev add a and b and then subtract c\n\n    */\n\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n\n        (Error err0, uint sum) = add(a, b);\n\n\n\n        if (err0 != Error.NO_ERROR) {\n\n            return (err0, 0);\n\n        }\n\n\n\n        return sub(sum, c);\n\n    }\n",
                    "message": "Contract '_CarefulMath' (_CarefulMath.sol#158-224) is not in CapWords\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mul(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function div(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sub(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function add(uint a, uint b) internal pure returns (Error, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n",
                    "message": null
                }
            ]
        }
    }
}