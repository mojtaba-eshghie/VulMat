{
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/EIP20NonCompliantHarness.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "contract EIP20NonCompliantHarness {\n\n    bool garbage;\n\n\n\n    function transfer(address _to, uint256 _value) public returns (uint, uint) {\n\n        _to;\n\n        _value; // supress unused variable warning\n\n        garbage = false;\n\n\n\n        return (1, 2);\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint, uint) {\n\n        _from;\n\n        _to;\n\n        _value; // supress unused variable warning\n\n        garbage = false;\n\n\n\n        return (1, 2);\n\n    }\n",
                    "message": "EIP20NonCompliantHarness (EIP20NonCompliantHarness.sol#10-29) has incorrect ERC20 function interface(s):\n\t-transfer (EIP20NonCompliantHarness.sol#13-19)\n\t-transferFrom (EIP20NonCompliantHarness.sol#21-28)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (uint, uint) {\n\n        _to;\n\n        _value; // supress unused variable warning\n\n        garbage = false;\n\n\n\n        return (1, 2);\n",
                    "message": "EIP20NonCompliantHarness.transfer (EIP20NonCompliantHarness.sol#13-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 28,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (uint, uint) {\n\n        _from;\n\n        _to;\n\n        _value; // supress unused variable warning\n\n        garbage = false;\n\n\n\n        return (1, 2);\n",
                    "message": "EIP20NonCompliantHarness.transferFrom (EIP20NonCompliantHarness.sol#21-28) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in EIP20NonCompliantHarness.sol:\n\t- pragma solidity^0.5.8 (EIP20NonCompliantHarness.sol#8): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value) public returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool garbage;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/MathHelpers.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in MathHelpers.sol:\n\t- pragma solidity^0.5.8 (MathHelpers.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/StandardToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_31"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicToken.totalSupply_ (StandardToken.sol#87) is never initialized. It is used in:\n\t- totalSupply (StandardToken.sol#92-94)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicToken.totalSupply_ should be constant (StandardToken.sol#87)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicToken.totalSupply (StandardToken.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (StandardToken.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (StandardToken.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicToken.balanceOf (StandardToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "BasicToken.transfer (StandardToken.sol#101-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20Basic.transfer (StandardToken.sol#14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "StandardToken.allowance (StandardToken.sol#201-210) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20.allowance (StandardToken.sol#131) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "StandardToken.transferFrom (StandardToken.sol#161-178) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20.transferFrom (StandardToken.sol#132) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20.approve (StandardToken.sol#133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "StandardToken.approve (StandardToken.sol#189-193) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": 232,
                    "vulnerability_code": "    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.increaseApproval (StandardToken.sol#221-232) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.decreaseApproval (StandardToken.sol#243-258) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in StandardToken.sol:\n\t- pragma solidity^0.5.8 (StandardToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (StandardToken.sol#20): it allows old versions\n\t- pragma solidity^0.5.8 (StandardToken.sol#75): it allows old versions\n\t- pragma solidity^0.5.8 (StandardToken.sol#124): it allows old versions\n\t- pragma solidity^0.5.8 (StandardToken.sol#140): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicToken.balanceOf (StandardToken.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_to' of BasicToken.transfer (StandardToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of BasicToken.transfer (StandardToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of StandardToken.allowance (StandardToken.sol#202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender\n",
                    "message": "Parameter '_spender' of StandardToken.allowance (StandardToken.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of StandardToken.transferFrom (StandardToken.sol#162) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of StandardToken.transferFrom (StandardToken.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of StandardToken.transferFrom (StandardToken.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of StandardToken.approve (StandardToken.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of StandardToken.approve (StandardToken.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.increaseApproval (StandardToken.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _addedValue\n",
                    "message": "Parameter '_addedValue' of StandardToken.increaseApproval (StandardToken.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.decreaseApproval (StandardToken.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of StandardToken.decreaseApproval (StandardToken.sol#245) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/ERC20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (ERC20.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (ERC20.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20Basic.transfer (ERC20.sol#14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20.allowance (ERC20.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20.transferFrom (ERC20.sol#28) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20.approve (ERC20.sol#29) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ERC20.sol:\n\t- pragma solidity^0.5.8 (ERC20.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ERC20.sol#20): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/FaucetNonStandardToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        totalSupply_ = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        balances[msg.sender] = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _tokenName;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _tokenSymbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        decimals = _decimalUnits;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_39"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "contract ERC20BasicNS {\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n",
                    "message": "ERC20BasicNS (FaucetNonStandardToken.sol#10-15) has incorrect ERC20 function interface(s):\n\t-transfer (FaucetNonStandardToken.sol#13)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "contract BasicTokenNS is ERC20BasicNS {\n\n    using SafeMath for uint256;\n\n\n\n    mapping(address => uint256) balances;\n\n\n\n    uint256 totalSupply_;\n\n\n\n    /**\n\n    * @dev Total number of tokens in existence\n\n    */\n\n    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer token for a specified address\n\n    * @param _to The address to transfer to.\n\n    * @param _value The amount to be transferred.\n\n    */\n\n    function transfer(address _to, uint256 _value) public {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param _owner The address to query the the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n\n",
                    "message": "BasicTokenNS (FaucetNonStandardToken.sol#83-120) has incorrect ERC20 function interface(s):\n\t-transfer (FaucetNonStandardToken.sol#102-109)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "contract ERC20NS is ERC20BasicNS {\n\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) public;\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n",
                    "message": "ERC20NS (FaucetNonStandardToken.sol#131-137) has incorrect ERC20 function interface(s):\n\t-transferFrom (FaucetNonStandardToken.sol#133)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 259,
                    "vulnerability_code": "contract NonStandardToken is ERC20NS, BasicTokenNS {\n\n\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n    /**\n\n     * @dev Transfer tokens from one address to another\n\n     * @param _from address The address which you want to send tokens from\n\n     * @param _to address The address which you want to transfer to\n\n     * @param _value uint256 the amount of tokens to be transferred\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n        public\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n    }\n\n\n\n    /**\n\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _value The amount of tokens to be spent.\n\n     */\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n     * @param _owner address The address which owns the funds.\n\n     * @param _spender address The address which will spend the funds.\n\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n\n     */\n\n    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n\n    }\n\n\n\n    /**\n\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n     * approve should be called when allowed[_spender] == 0. To increment\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _addedValue The amount of tokens to increase the allowance by.\n\n     */\n\n    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n     * approve should be called when allowed[_spender] == 0. To decrement\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n     */\n\n    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n\n    }\n\n\n",
                    "message": "NonStandardToken (FaucetNonStandardToken.sol#151-259) has incorrect ERC20 function interface(s):\n\t-transferFrom (FaucetNonStandardToken.sol#162-177)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20BasicNS.totalSupply (FaucetNonStandardToken.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply (FaucetNonStandardToken.sol#93-95) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicTokenNS.balanceOf (FaucetNonStandardToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20BasicNS.balanceOf (FaucetNonStandardToken.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public;\n",
                    "message": "ERC20BasicNS.transfer (FaucetNonStandardToken.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n",
                    "message": "BasicTokenNS.transfer (FaucetNonStandardToken.sol#102-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": 209,
                    "vulnerability_code": "    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "NonStandardToken.allowance (FaucetNonStandardToken.sol#200-209) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20NS.allowance (FaucetNonStandardToken.sol#132) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public;\n",
                    "message": "ERC20NS.transferFrom (FaucetNonStandardToken.sol#133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n        public\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n",
                    "message": "NonStandardToken.transferFrom (FaucetNonStandardToken.sol#162-177) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 192,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "NonStandardToken.approve (FaucetNonStandardToken.sol#188-192) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20NS.approve (FaucetNonStandardToken.sol#134) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "NonStandardToken.increaseApproval (FaucetNonStandardToken.sol#220-231) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 257,
                    "vulnerability_code": "    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "NonStandardToken.decreaseApproval (FaucetNonStandardToken.sol#242-257) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 290,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n\n        balances[_owner] += value;\n\n        totalSupply_ += value;\n\n        emit Transfer(address(this), _owner, value);\n",
                    "message": "FaucetNonStandardToken.allocateTo (FaucetNonStandardToken.sol#286-290) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in FaucetNonStandardToken.sol:\n\t- pragma solidity^0.5.8 (FaucetNonStandardToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetNonStandardToken.sol#19): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetNonStandardToken.sol#74): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetNonStandardToken.sol#124): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetNonStandardToken.sol#141): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetNonStandardToken.sol#263): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicTokenNS.balanceOf (FaucetNonStandardToken.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n",
                    "message": "Parameter '_to' of BasicTokenNS.transfer (FaucetNonStandardToken.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n",
                    "message": "Parameter '_value' of BasicTokenNS.transfer (FaucetNonStandardToken.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of NonStandardToken.allowance (FaucetNonStandardToken.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender\n",
                    "message": "Parameter '_spender' of NonStandardToken.allowance (FaucetNonStandardToken.sol#202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NonStandardToken.transferFrom (FaucetNonStandardToken.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NonStandardToken.transferFrom (FaucetNonStandardToken.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of NonStandardToken.transferFrom (FaucetNonStandardToken.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of NonStandardToken.approve (FaucetNonStandardToken.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of NonStandardToken.approve (FaucetNonStandardToken.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of NonStandardToken.increaseApproval (FaucetNonStandardToken.sol#221) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _addedValue\n",
                    "message": "Parameter '_addedValue' of NonStandardToken.increaseApproval (FaucetNonStandardToken.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of NonStandardToken.decreaseApproval (FaucetNonStandardToken.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of NonStandardToken.decreaseApproval (FaucetNonStandardToken.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_initialAmount' of FaucetNonStandardToken. (FaucetNonStandardToken.sol#275) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenName' of FaucetNonStandardToken. (FaucetNonStandardToken.sol#275) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_decimalUnits' of FaucetNonStandardToken. (FaucetNonStandardToken.sol#275) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenSymbol' of FaucetNonStandardToken. (FaucetNonStandardToken.sol#275) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n",
                    "message": "Parameter '_owner' of FaucetNonStandardToken.allocateTo (FaucetNonStandardToken.sol#286) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/ERC20BasicNS.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "contract ERC20BasicNS {\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n",
                    "message": "ERC20BasicNS (ERC20BasicNS.sol#10-15) has incorrect ERC20 function interface(s):\n\t-transfer (ERC20BasicNS.sol#13)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20BasicNS.totalSupply (ERC20BasicNS.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20BasicNS.balanceOf (ERC20BasicNS.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public;\n",
                    "message": "ERC20BasicNS.transfer (ERC20BasicNS.sol#13) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ERC20BasicNS.sol:\n\t- pragma solidity^0.5.8 (ERC20BasicNS.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/FaucetTokenReEntrantHarness.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _totalSupply = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _balances[msg.sender] = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _tokenName;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _tokenSymbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        decimals = _decimalUnits;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        reEntryCallData = _reEntryCallData;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        reEntryFun = _reEntryFun;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20NonView.increaseAllowance (FaucetTokenReEntrantHarness.sol#162-165) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 180,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n\n        return true;\n",
                    "message": "ERC20NonView.decreaseAllowance (FaucetTokenReEntrantHarness.sol#177-180) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 302,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n\n        _balances[_owner] += value;\n\n        _totalSupply += value;\n\n        emit Transfer(address(this), _owner, value);\n",
                    "message": "FaucetTokenReEntrantHarness.allocateTo (FaucetTokenReEntrantHarness.sol#298-302) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in FaucetTokenReEntrantHarness.sol:\n\t- pragma solidity^0.5.8 (FaucetTokenReEntrantHarness.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetTokenReEntrantHarness.sol#58): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetTokenReEntrantHarness.sol#255): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 194,
                    "vulnerability_code": "    function _transfer(address from, address to, uint256 value) internal {\n\n        require(to != address(0));\n\n\n\n        _balances[from] = _balances[from].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        emit Transfer(from, to, value);\n",
                    "message": "Function 'ERC20NonView._transfer' (FaucetTokenReEntrantHarness.sol#188-194) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 209,
                    "vulnerability_code": "    function _mint(address account, uint256 value) internal {\n\n        require(account != address(0));\n\n\n\n        _totalSupply = _totalSupply.add(value);\n\n        _balances[account] = _balances[account].add(value);\n\n        emit Transfer(address(0), account, value);\n",
                    "message": "Function 'ERC20NonView._mint' (FaucetTokenReEntrantHarness.sol#203-209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function _burn(address account, uint256 value) internal {\n\n        require(account != address(0));\n\n\n\n        _totalSupply = _totalSupply.sub(value);\n\n        _balances[account] = _balances[account].sub(value);\n\n        emit Transfer(account, address(0), value);\n",
                    "message": "Function 'ERC20NonView._burn' (FaucetTokenReEntrantHarness.sol#217-223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 value) internal {\n\n        require(spender != address(0));\n\n        require(owner != address(0));\n\n\n\n        _allowed[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n",
                    "message": "Function 'ERC20NonView._approve' (FaucetTokenReEntrantHarness.sol#231-237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": 250,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 value) internal {\n\n        _burn(account, value);\n\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n",
                    "message": "Function 'ERC20NonView._burnFrom' (FaucetTokenReEntrantHarness.sol#247-250) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) public _balances;\n",
                    "message": "Variable 'ERC20NonView._balances' (FaucetTokenReEntrantHarness.sol#79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) public _allowed;\n",
                    "message": "Variable 'ERC20NonView._allowed' (FaucetTokenReEntrantHarness.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public _totalSupply;\n",
                    "message": "Variable 'ERC20NonView._totalSupply' (FaucetTokenReEntrantHarness.sol#83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Parameter '_initialAmount' of FaucetTokenReEntrantHarness. (FaucetTokenReEntrantHarness.sol#269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Parameter '_tokenName' of FaucetTokenReEntrantHarness. (FaucetTokenReEntrantHarness.sol#269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Parameter '_decimalUnits' of FaucetTokenReEntrantHarness. (FaucetTokenReEntrantHarness.sol#269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Parameter '_tokenSymbol' of FaucetTokenReEntrantHarness. (FaucetTokenReEntrantHarness.sol#269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Parameter '_reEntryCallData' of FaucetTokenReEntrantHarness. (FaucetTokenReEntrantHarness.sol#269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n",
                    "message": "Parameter '_reEntryFun' of FaucetTokenReEntrantHarness. (FaucetTokenReEntrantHarness.sol#269) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n",
                    "message": "Parameter '_owner' of FaucetTokenReEntrantHarness.allocateTo (FaucetTokenReEntrantHarness.sol#298) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) public reEnter(\"approve\") returns (bool success) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in SafeMath.sol:\n\t- pragma solidity^0.5.8 (SafeMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/NonStandardToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply_ (NonStandardToken.sol#88) is never initialized. It is used in:\n\t- totalSupply (NonStandardToken.sol#93-95)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "contract ERC20BasicNS {\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n",
                    "message": "ERC20BasicNS (NonStandardToken.sol#10-15) has incorrect ERC20 function interface(s):\n\t-transfer (NonStandardToken.sol#13)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "contract BasicTokenNS is ERC20BasicNS {\n\n    using SafeMath for uint256;\n\n\n\n    mapping(address => uint256) balances;\n\n\n\n    uint256 totalSupply_;\n\n\n\n    /**\n\n    * @dev Total number of tokens in existence\n\n    */\n\n    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer token for a specified address\n\n    * @param _to The address to transfer to.\n\n    * @param _value The amount to be transferred.\n\n    */\n\n    function transfer(address _to, uint256 _value) public {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param _owner The address to query the the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n\n",
                    "message": "BasicTokenNS (NonStandardToken.sol#83-120) has incorrect ERC20 function interface(s):\n\t-transfer (NonStandardToken.sol#102-109)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "contract ERC20NS is ERC20BasicNS {\n\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) public;\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n",
                    "message": "ERC20NS (NonStandardToken.sol#131-137) has incorrect ERC20 function interface(s):\n\t-transferFrom (NonStandardToken.sol#133)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 259,
                    "vulnerability_code": "contract NonStandardToken is ERC20NS, BasicTokenNS {\n\n\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n    /**\n\n     * @dev Transfer tokens from one address to another\n\n     * @param _from address The address which you want to send tokens from\n\n     * @param _to address The address which you want to transfer to\n\n     * @param _value uint256 the amount of tokens to be transferred\n\n     */\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n        public\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n    }\n\n\n\n    /**\n\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _value The amount of tokens to be spent.\n\n     */\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n     * @param _owner address The address which owns the funds.\n\n     * @param _spender address The address which will spend the funds.\n\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n\n     */\n\n    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n\n    }\n\n\n\n    /**\n\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n     * approve should be called when allowed[_spender] == 0. To increment\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _addedValue The amount of tokens to increase the allowance by.\n\n     */\n\n    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n     * approve should be called when allowed[_spender] == 0. To decrement\n\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n\n     * the first transaction is mined)\n\n     * From MonolithDAO Token.sol\n\n     * @param _spender The address which will spend the funds.\n\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\n     */\n\n    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n\n    }\n\n\n",
                    "message": "NonStandardToken (NonStandardToken.sol#151-259) has incorrect ERC20 function interface(s):\n\t-transferFrom (NonStandardToken.sol#162-177)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply_ should be constant (NonStandardToken.sol#88)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20BasicNS.totalSupply (NonStandardToken.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply (NonStandardToken.sol#93-95) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20BasicNS.balanceOf (NonStandardToken.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicTokenNS.balanceOf (NonStandardToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n",
                    "message": "BasicTokenNS.transfer (NonStandardToken.sol#102-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public;\n",
                    "message": "ERC20BasicNS.transfer (NonStandardToken.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20NS.allowance (NonStandardToken.sol#132) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": 209,
                    "vulnerability_code": "    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "NonStandardToken.allowance (NonStandardToken.sol#200-209) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n        public\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n",
                    "message": "NonStandardToken.transferFrom (NonStandardToken.sol#162-177) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public;\n",
                    "message": "ERC20NS.transferFrom (NonStandardToken.sol#133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20NS.approve (NonStandardToken.sol#134) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 192,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "NonStandardToken.approve (NonStandardToken.sol#188-192) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": 231,
                    "vulnerability_code": "    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "NonStandardToken.increaseApproval (NonStandardToken.sol#220-231) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": 257,
                    "vulnerability_code": "    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "NonStandardToken.decreaseApproval (NonStandardToken.sol#242-257) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in NonStandardToken.sol:\n\t- pragma solidity^0.5.8 (NonStandardToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (NonStandardToken.sol#19): it allows old versions\n\t- pragma solidity^0.5.8 (NonStandardToken.sol#74): it allows old versions\n\t- pragma solidity^0.5.8 (NonStandardToken.sol#124): it allows old versions\n\t- pragma solidity^0.5.8 (NonStandardToken.sol#141): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicTokenNS.balanceOf (NonStandardToken.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n",
                    "message": "Parameter '_to' of BasicTokenNS.transfer (NonStandardToken.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n",
                    "message": "Parameter '_value' of BasicTokenNS.transfer (NonStandardToken.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of NonStandardToken.allowance (NonStandardToken.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender\n",
                    "message": "Parameter '_spender' of NonStandardToken.allowance (NonStandardToken.sol#202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of NonStandardToken.transferFrom (NonStandardToken.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of NonStandardToken.transferFrom (NonStandardToken.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of NonStandardToken.transferFrom (NonStandardToken.sol#165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of NonStandardToken.approve (NonStandardToken.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of NonStandardToken.approve (NonStandardToken.sol#188) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of NonStandardToken.increaseApproval (NonStandardToken.sol#221) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _addedValue\n",
                    "message": "Parameter '_addedValue' of NonStandardToken.increaseApproval (NonStandardToken.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of NonStandardToken.decreaseApproval (NonStandardToken.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of NonStandardToken.decreaseApproval (NonStandardToken.sol#244) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/NotPriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in NotPriceOracle.sol:\n\t- pragma solidity^0.5.8 (NotPriceOracle.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isPriceOracle = false;\n",
                    "message": "Constant 'NotPriceOracle.isPriceOracle' (NotPriceOracle.sol#7) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/BasicTokenNS.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply_ (BasicTokenNS.sol#88) is never initialized. It is used in:\n\t- totalSupply (BasicTokenNS.sol#93-95)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "contract ERC20BasicNS {\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n",
                    "message": "ERC20BasicNS (BasicTokenNS.sol#10-15) has incorrect ERC20 function interface(s):\n\t-transfer (BasicTokenNS.sol#13)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "contract BasicTokenNS is ERC20BasicNS {\n\n    using SafeMath for uint256;\n\n\n\n    mapping(address => uint256) balances;\n\n\n\n    uint256 totalSupply_;\n\n\n\n    /**\n\n    * @dev Total number of tokens in existence\n\n    */\n\n    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer token for a specified address\n\n    * @param _to The address to transfer to.\n\n    * @param _value The amount to be transferred.\n\n    */\n\n    function transfer(address _to, uint256 _value) public {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param _owner The address to query the the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n\n",
                    "message": "BasicTokenNS (BasicTokenNS.sol#83-120) has incorrect ERC20 function interface(s):\n\t-transfer (BasicTokenNS.sol#102-109)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply_ should be constant (BasicTokenNS.sol#88)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicTokenNS.totalSupply (BasicTokenNS.sol#93-95) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20BasicNS.totalSupply (BasicTokenNS.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20BasicNS.balanceOf (BasicTokenNS.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicTokenNS.balanceOf (BasicTokenNS.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public;\n",
                    "message": "ERC20BasicNS.transfer (BasicTokenNS.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n",
                    "message": "BasicTokenNS.transfer (BasicTokenNS.sol#102-109) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in BasicTokenNS.sol:\n\t- pragma solidity^0.5.8 (BasicTokenNS.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (BasicTokenNS.sol#19): it allows old versions\n\t- pragma solidity^0.5.8 (BasicTokenNS.sol#74): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicTokenNS.balanceOf (BasicTokenNS.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n",
                    "message": "Parameter '_to' of BasicTokenNS.transfer (BasicTokenNS.sol#102) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public {\n",
                    "message": "Parameter '_value' of BasicTokenNS.transfer (BasicTokenNS.sol#102) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/ERC20Basic.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (ERC20Basic.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (ERC20Basic.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20Basic.transfer (ERC20Basic.sol#14) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ERC20Basic.sol:\n\t- pragma solidity^0.5.8 (ERC20Basic.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/DSValueHarness.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 initVal) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (initVal != 0) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            has = true;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            val = initVal;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "    function peek() public view returns (bytes32, bool) {\n\n        return (val, has);\n",
                    "message": "DSValueHarness.peek (DSValueHarness.sol#18-20) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function read() public view returns (bytes32) {\n\n        return val;\n",
                    "message": "DSValueHarness.read (DSValueHarness.sol#22-24) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 29,
                    "vulnerability_code": "    function set(bytes32 _val) public {\n\n        val = _val;\n\n        has = true;\n",
                    "message": "DSValueHarness.set (DSValueHarness.sol#26-29) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 33,
                    "vulnerability_code": "    function unset() public {\n\n        has = false;\n",
                    "message": "DSValueHarness.unset (DSValueHarness.sol#31-33) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in DSValueHarness.sol:\n\t- pragma solidity^0.5.8 (DSValueHarness.sol#5): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function set(bytes32 _val) public {\n",
                    "message": "Parameter '_val' of DSValueHarness.set (DSValueHarness.sol#26) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function peek() public view returns (bytes32, bool) {\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/BasicToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_12"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicToken.totalSupply_ (BasicToken.sol#87) is never initialized. It is used in:\n\t- totalSupply (BasicToken.sol#92-94)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": "BasicToken.totalSupply_ should be constant (BasicToken.sol#87)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (BasicToken.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicToken.totalSupply (BasicToken.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicToken.balanceOf (BasicToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (BasicToken.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "BasicToken.transfer (BasicToken.sol#101-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20Basic.transfer (BasicToken.sol#14) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in BasicToken.sol:\n\t- pragma solidity^0.5.8 (BasicToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (BasicToken.sol#20): it allows old versions\n\t- pragma solidity^0.5.8 (BasicToken.sol#75): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicToken.balanceOf (BasicToken.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_to' of BasicToken.transfer (BasicToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of BasicToken.transfer (BasicToken.sol#101) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/EvilToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        totalSupply_ = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        balances[msg.sender] = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _tokenName;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _tokenSymbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        decimals = _decimalUnits;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        fail = true;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_33"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (EvilToken.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicToken.totalSupply (EvilToken.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicToken.balanceOf (EvilToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (EvilToken.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "StandardToken.allowance (EvilToken.sol#201-210) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20.allowance (EvilToken.sol#131) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "StandardToken.approve (EvilToken.sol#189-193) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20.approve (EvilToken.sol#133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": 232,
                    "vulnerability_code": "    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.increaseApproval (EvilToken.sol#221-232) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.decreaseApproval (EvilToken.sol#243-258) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function setFail(bool _fail) public {\n\n        fail = _fail;\n",
                    "message": "EvilToken.setFail (EvilToken.sol#286-288) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 297,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n\n        balances[_owner] += value;\n\n        totalSupply_ += value;\n\n        emit Transfer(address(this), _owner, value);\n",
                    "message": "EvilToken.allocateTo (EvilToken.sol#293-297) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in EvilToken.sol:\n\t- pragma solidity^0.5.8 (EvilToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (EvilToken.sol#20): it allows old versions\n\t- pragma solidity^0.5.8 (EvilToken.sol#75): it allows old versions\n\t- pragma solidity^0.5.8 (EvilToken.sol#124): it allows old versions\n\t- pragma solidity^0.5.8 (EvilToken.sol#140): it allows old versions\n\t- pragma solidity^0.5.8 (EvilToken.sol#264): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicToken.balanceOf (EvilToken.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_to' of BasicToken.transfer (EvilToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of BasicToken.transfer (EvilToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of StandardToken.allowance (EvilToken.sol#202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender\n",
                    "message": "Parameter '_spender' of StandardToken.allowance (EvilToken.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of StandardToken.transferFrom (EvilToken.sol#162) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of StandardToken.transferFrom (EvilToken.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of StandardToken.transferFrom (EvilToken.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of StandardToken.approve (EvilToken.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of StandardToken.approve (EvilToken.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.increaseApproval (EvilToken.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _addedValue\n",
                    "message": "Parameter '_addedValue' of StandardToken.increaseApproval (EvilToken.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.decreaseApproval (EvilToken.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of StandardToken.decreaseApproval (EvilToken.sol#245) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_initialAmount' of EvilToken. (EvilToken.sol#277) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenName' of EvilToken. (EvilToken.sol#277) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_decimalUnits' of EvilToken. (EvilToken.sol#277) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenSymbol' of EvilToken. (EvilToken.sol#277) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setFail(bool _fail) public {\n",
                    "message": "Parameter '_fail' of EvilToken.setFail (EvilToken.sol#286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n",
                    "message": "Parameter '_owner' of EvilToken.allocateTo (EvilToken.sol#293) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/ERC20NS.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "contract ERC20BasicNS {\n\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n",
                    "message": "ERC20BasicNS (ERC20NS.sol#10-15) has incorrect ERC20 function interface(s):\n\t-transfer (ERC20NS.sol#13)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "contract ERC20NS is ERC20BasicNS {\n\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) public;\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n",
                    "message": "ERC20NS (ERC20NS.sol#26-32) has incorrect ERC20 function interface(s):\n\t-transferFrom (ERC20NS.sol#28)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20BasicNS.totalSupply (ERC20NS.sol#11) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20BasicNS.balanceOf (ERC20NS.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public;\n",
                    "message": "ERC20BasicNS.transfer (ERC20NS.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20NS.allowance (ERC20NS.sol#27) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public;\n",
                    "message": "ERC20NS.transferFrom (ERC20NS.sol#28) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20NS.approve (ERC20NS.sol#29) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ERC20NS.sol:\n\t- pragma solidity^0.5.8 (ERC20NS.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ERC20NS.sol#19): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/ERC20NonView.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_17"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 91,
                    "vulnerability_code": "    function totalSupply() public returns (uint256) {\n\n        _totalSupply = _totalSupply;\n\n        return _totalSupply;\n",
                    "message": "ERC20NonView.totalSupply (ERC20NonView.sol#88-91) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "    function balanceOf(address owner) public returns (uint256) {\n\n        _totalSupply = _totalSupply;\n\n        return _balances[owner];\n",
                    "message": "ERC20NonView.balanceOf (ERC20NonView.sol#98-101) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 112,
                    "vulnerability_code": "    function allowance(address owner, address spender) public returns (uint256) {\n\n        _totalSupply = _totalSupply;\n\n        return _allowed[owner][spender];\n",
                    "message": "ERC20NonView.allowance (ERC20NonView.sol#109-112) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool) {\n\n        _transfer(msg.sender, to, value);\n\n        return true;\n",
                    "message": "ERC20NonView.transfer (ERC20NonView.sol#119-122) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool) {\n\n        _approve(msg.sender, spender, value);\n\n        return true;\n",
                    "message": "ERC20NonView.approve (ERC20NonView.sol#133-136) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 150,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n\n        _transfer(from, to, value);\n\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n\n        return true;\n",
                    "message": "ERC20NonView.transferFrom (ERC20NonView.sol#146-150) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n\n        return true;\n",
                    "message": "ERC20NonView.increaseAllowance (ERC20NonView.sol#162-165) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": 180,
                    "vulnerability_code": "    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n\n        return true;\n",
                    "message": "ERC20NonView.decreaseAllowance (ERC20NonView.sol#177-180) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ERC20NonView.sol:\n\t- pragma solidity^0.5.8 (ERC20NonView.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ERC20NonView.sol#58): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 194,
                    "vulnerability_code": "    function _transfer(address from, address to, uint256 value) internal {\n\n        require(to != address(0));\n\n\n\n        _balances[from] = _balances[from].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        emit Transfer(from, to, value);\n",
                    "message": "Function 'ERC20NonView._transfer' (ERC20NonView.sol#188-194) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": 209,
                    "vulnerability_code": "    function _mint(address account, uint256 value) internal {\n\n        require(account != address(0));\n\n\n\n        _totalSupply = _totalSupply.add(value);\n\n        _balances[account] = _balances[account].add(value);\n\n        emit Transfer(address(0), account, value);\n",
                    "message": "Function 'ERC20NonView._mint' (ERC20NonView.sol#203-209) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 223,
                    "vulnerability_code": "    function _burn(address account, uint256 value) internal {\n\n        require(account != address(0));\n\n\n\n        _totalSupply = _totalSupply.sub(value);\n\n        _balances[account] = _balances[account].sub(value);\n\n        emit Transfer(account, address(0), value);\n",
                    "message": "Function 'ERC20NonView._burn' (ERC20NonView.sol#217-223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function _approve(address owner, address spender, uint256 value) internal {\n\n        require(spender != address(0));\n\n        require(owner != address(0));\n\n\n\n        _allowed[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n",
                    "message": "Function 'ERC20NonView._approve' (ERC20NonView.sol#231-237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": 250,
                    "vulnerability_code": "    function _burnFrom(address account, uint256 value) internal {\n\n        _burn(account, value);\n\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n",
                    "message": "Function 'ERC20NonView._burnFrom' (ERC20NonView.sol#247-250) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) public _balances;\n",
                    "message": "Variable 'ERC20NonView._balances' (ERC20NonView.sol#79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) public _allowed;\n",
                    "message": "Variable 'ERC20NonView._allowed' (ERC20NonView.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 public _totalSupply;\n",
                    "message": "Variable 'ERC20NonView._totalSupply' (ERC20NonView.sol#83) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/test/contracts/FaucetToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        totalSupply_ = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        balances[msg.sender] = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _tokenName;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _tokenSymbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        decimals = _decimalUnits;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicToken.totalSupply (FaucetToken.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (FaucetToken.sol#12) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicToken.balanceOf (FaucetToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (FaucetToken.sol#13) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "BasicToken.transfer (FaucetToken.sol#101-109) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20Basic.transfer (FaucetToken.sol#14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 210,
                    "vulnerability_code": "    function allowance(\n\n        address _owner,\n\n        address _spender\n\n     )\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "StandardToken.allowance (FaucetToken.sol#201-210) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20.allowance (FaucetToken.sol#131) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "StandardToken.transferFrom (FaucetToken.sol#161-178) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20.transferFrom (FaucetToken.sol#132) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20.approve (FaucetToken.sol#133) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "StandardToken.approve (FaucetToken.sol#189-193) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": 232,
                    "vulnerability_code": "    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n            allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.increaseApproval (FaucetToken.sol#221-232) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": 258,
                    "vulnerability_code": "    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n        public\n\n        returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.decreaseApproval (FaucetToken.sol#243-258) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": 291,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n\n        balances[_owner] += value;\n\n        totalSupply_ += value;\n\n        emit Transfer(address(this), _owner, value);\n",
                    "message": "FaucetToken.allocateTo (FaucetToken.sol#287-291) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in FaucetToken.sol:\n\t- pragma solidity^0.5.8 (FaucetToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#20): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#75): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#124): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#140): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#264): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicToken.balanceOf (FaucetToken.sol#116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_to' of BasicToken.transfer (FaucetToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of BasicToken.transfer (FaucetToken.sol#101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of StandardToken.allowance (FaucetToken.sol#202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender\n",
                    "message": "Parameter '_spender' of StandardToken.allowance (FaucetToken.sol#203) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of StandardToken.transferFrom (FaucetToken.sol#162) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of StandardToken.transferFrom (FaucetToken.sol#163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of StandardToken.transferFrom (FaucetToken.sol#164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of StandardToken.approve (FaucetToken.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of StandardToken.approve (FaucetToken.sol#189) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.increaseApproval (FaucetToken.sol#222) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _addedValue\n",
                    "message": "Parameter '_addedValue' of StandardToken.increaseApproval (FaucetToken.sol#223) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.decreaseApproval (FaucetToken.sol#244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of StandardToken.decreaseApproval (FaucetToken.sol#245) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_initialAmount' of FaucetToken. (FaucetToken.sol#276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenName' of FaucetToken. (FaucetToken.sol#276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_decimalUnits' of FaucetToken. (FaucetToken.sol#276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenSymbol' of FaucetToken. (FaucetToken.sol#276) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n",
                    "message": "Parameter '_owner' of FaucetToken.allocateTo (FaucetToken.sol#287) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/EIP20NonStandardInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (EIP20NonStandardInterface.sol#10-72) has incorrect ERC20 function interface(s):\n\t-transfer (EIP20NonStandardInterface.sol#36)\n\t-transferFrom (EIP20NonStandardInterface.sol#50)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in EIP20NonStandardInterface.sol:\n\t- pragma solidity^0.5.8 (EIP20NonStandardInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/ComptrollerInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ComptrollerInterface.sol:\n\t- pragma solidity^0.5.8 (ComptrollerInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/ReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ReentrancyGuard.sol:\n\t- pragma solidity^0.5.8 (ReentrancyGuard.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/Comptroller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (accountAssets[msg.sender].length >= maxAssets)  {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2754,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 2790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Market storage marketToJoin = markets[address(cToken)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(changeStatus == 0, \"change not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 2878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2837,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3605,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_82"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2636,
                    "vulnerability_to_line": 2652,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback (Comptroller.sol#2636-2652) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (Comptroller.sol#2638-2640)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2461,
                    "vulnerability_to_line": 2464,
                    "vulnerability_code": "    address public comptrollerImplementation;\n\n\n\n    /**\n",
                    "message": "UnitrollerAdminStorage.comptrollerImplementation (Comptroller.sol#2461-2464) is never initialized. It is used in:\n\t- adminOrInitializing (Comptroller.sol#3637-3647)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (Comptroller.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (Comptroller.sol#745)\n\t-transferFrom (Comptroller.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (Comptroller.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (Comptroller.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (Comptroller.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Comptroller.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (Comptroller.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (Comptroller.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Comptroller.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (Comptroller.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (Comptroller.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Comptroller.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (Comptroller.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (Comptroller.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Comptroller.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3587,
                    "vulnerability_to_line": 3604,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller._supportMarket (Comptroller.sol#3587-3604):\n\tExternal calls:\n\t- cToken.isCToken() (Comptroller.sol#3596)\n\tState variables written after the call(s):\n\t- markets (Comptroller.sol#3598-3599)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Comptroller.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Comptroller.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1503-1504)\n\t- totalReserves (Comptroller.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (Comptroller.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (Comptroller.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2833,
                    "vulnerability_to_line": 2885,
                    "vulnerability_code": "    function exitMarket(address cTokenAddress) external returns (uint) {\n\n        CToken cToken = CToken(cTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(cToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set cToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete cToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == cToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        CToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(cToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller.exitMarket (Comptroller.sol#2833-2885):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = cToken.getAccountSnapshot(msg.sender) (Comptroller.sol#2836-2837)\n\t- allowed = redeemAllowedInternal(cTokenAddress,msg.sender,tokensHeld) (Comptroller.sol#2845-2846)\n\tState variables written after the call(s):\n\t- accountAssets (Comptroller.sol#2877-2878)\n\t- accountAssets (Comptroller.sol#2879-2880)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (Comptroller.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (Comptroller.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Comptroller.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Comptroller.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Comptroller.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (Comptroller.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Comptroller.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Comptroller.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (Comptroller.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (Comptroller.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Comptroller.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (Comptroller.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (Comptroller.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (Comptroller.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (Comptroller.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (Comptroller.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (Comptroller.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 3587,
                    "vulnerability_to_line": 3604,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Comptroller._supportMarket (Comptroller.sol#3587-3604) does not use the value returned by external calls:\n\t-cToken.isCToken() (Comptroller.sol#3596)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3316,
                    "vulnerability_to_line": 3317,
                    "vulnerability_code": "            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- (oErr,vars.cTokenBalance,vars.borrowBalance,vars.exchangeRateMantissa) = asset.getAccountSnapshot(account) (Comptroller.sol#3316-3317)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3324,
                    "vulnerability_to_line": 3325,
                    "vulnerability_code": "            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset) (Comptroller.sol#3324-3325)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Comptroller.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Comptroller.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Comptroller.sol#1501-1502)\n\t- borrowIndex (Comptroller.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (Comptroller.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Comptroller.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (Comptroller.sol#1853-1854)\n\t- accountBorrows (Comptroller.sol#1854-1855)\n\t- totalBorrows (Comptroller.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Comptroller.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Comptroller.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Comptroller.sol#1070)\n\t- borrowIndex (Comptroller.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Comptroller.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Comptroller.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Comptroller.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (Comptroller.sol#1079)\n\t- name (Comptroller.sol#1077)\n\t- symbol (Comptroller.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (Comptroller.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Comptroller.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1611-1613)\n\t- totalSupply (Comptroller.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Comptroller.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Comptroller.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (Comptroller.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Comptroller.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (Comptroller.sol#1980-1981)\n\t- accountBorrows (Comptroller.sol#1981-1982)\n\t- totalBorrows (Comptroller.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (Comptroller.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Comptroller.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#2134-2135)\n\t- accountTokens (Comptroller.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (Comptroller.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Comptroller.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (Comptroller.sol#1136)\n\t- accountTokens (Comptroller.sol#1137)\n\t- transferAllowances (Comptroller.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2636,
                    "vulnerability_to_line": 2652,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback uses assembly (Comptroller.sol#2636-2652)\n\t- Comptroller.sol#2642-2652\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (Comptroller.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2537,
                    "vulnerability_to_line": 2553,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (Comptroller.sol#2537-2553) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2557,
                    "vulnerability_to_line": 2579,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (Comptroller.sol#2557-2579) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2586,
                    "vulnerability_to_line": 2605,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (Comptroller.sol#2586-2605) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2609,
                    "vulnerability_to_line": 2632,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (Comptroller.sol#2609-2632) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2784,
                    "vulnerability_to_line": 2827,
                    "vulnerability_code": "    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n\n            if (accountAssets[msg.sender].length >= maxAssets)  {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.enterMarkets (Comptroller.sol#2784-2827) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n",
                    "message": "ComptrollerInterface.enterMarkets (Comptroller.sol#15) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3272,
                    "vulnerability_to_line": 3279,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.getAccountLiquidity (Comptroller.sol#3272-3279) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3433,
                    "vulnerability_to_line": 3455,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._setPriceOracle (Comptroller.sol#3433-3455) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3604,
                    "vulnerability_to_line": 3632,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._become (Comptroller.sol#3604-3632) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in Comptroller.sol:\n\t- pragma solidity^0.5.8 (Comptroller.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#2425-2427): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#2444-2447): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#2500-2504): it allows old versions\n\t- pragma solidity^0.5.8 (Comptroller.sol#2654-2663): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2636,
                    "vulnerability_to_line": 2652,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Low level call in Unitroller.fallback (Comptroller.sol#2636-2652):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) Comptroller.sol#2638-2640\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Comptroller.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Comptroller.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Comptroller.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (Comptroller.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (Comptroller.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (Comptroller.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (Comptroller.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (Comptroller.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (Comptroller.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (Comptroller.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (Comptroller.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (Comptroller.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (Comptroller.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (Comptroller.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (Comptroller.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2537,
                    "vulnerability_to_line": 2553,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (Comptroller.sol#2537-2553) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2557,
                    "vulnerability_to_line": 2579,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (Comptroller.sol#2557-2579) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2586,
                    "vulnerability_to_line": 2605,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (Comptroller.sol#2586-2605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2609,
                    "vulnerability_to_line": 2632,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (Comptroller.sol#2609-2632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3433,
                    "vulnerability_to_line": 3455,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setPriceOracle' (Comptroller.sol#3433-3455) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3460,
                    "vulnerability_to_line": 3485,
                    "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCloseFactor' (Comptroller.sol#3460-3485) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3491,
                    "vulnerability_to_line": 3527,
                    "vulnerability_code": "    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(cToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCollateralFactor' (Comptroller.sol#3491-3527) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3532,
                    "vulnerability_to_line": 3546,
                    "vulnerability_code": "    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n\n        }\n\n\n\n        uint oldMaxAssets = maxAssets;\n\n        maxAssets = newMaxAssets;\n\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setMaxAssets' (Comptroller.sol#3532-3546) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3551,
                    "vulnerability_to_line": 3582,
                    "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setLiquidationIncentive' (Comptroller.sol#3551-3582) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3587,
                    "vulnerability_to_line": 3604,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'Comptroller._supportMarket' (Comptroller.sol#3587-3604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3604,
                    "vulnerability_to_line": 3632,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._become' (Comptroller.sol#3604-3632) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_oracle' of Comptroller._become (Comptroller.sol#3604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_closeFactorMantissa' of Comptroller._become (Comptroller.sol#3604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_maxAssets' of Comptroller._become (Comptroller.sol#3604) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2735,
                    "vulnerability_to_line": 2737,
                    "vulnerability_code": "    bool public constant isComptroller = true;\n\n\n",
                    "message": "Constant 'Comptroller.isComptroller' (Comptroller.sol#2735-2737) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2738,
                    "vulnerability_to_line": 2740,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMinMantissa' (Comptroller.sol#2738-2740) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2741,
                    "vulnerability_to_line": 2743,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMaxMantissa' (Comptroller.sol#2741-2743) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2744,
                    "vulnerability_to_line": 2746,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (Comptroller.sol#2744-2746) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2747,
                    "vulnerability_to_line": 2749,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMinMantissa' (Comptroller.sol#2747-2749) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2750,
                    "vulnerability_to_line": 2752,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMaxMantissa' (Comptroller.sol#2750-2752) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (Comptroller.sol#435) is never used in Comptroller\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 2878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2654,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 2974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint repayAmount) external view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_TX_ORIGIN",
                    "vulnerability_from_line": 3642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tx.origin == admin\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2738,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2741,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2750,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/CErc20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_46"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CErc20.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (CErc20.sol#745)\n\t-transferFrom (CErc20.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CErc20.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (CErc20.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CErc20.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CErc20.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (CErc20.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CErc20.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CErc20.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CErc20.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CErc20.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CErc20.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CErc20.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1503-1504)\n\t- totalReserves (CErc20.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CErc20.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (CErc20.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CErc20.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (CErc20.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CErc20.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (CErc20.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CErc20.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CErc20.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CErc20.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CErc20.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CErc20.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CErc20.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CErc20.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CErc20.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CErc20.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": 2462,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (CErc20.sol#2449-2462) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (CErc20.sol#2459)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20.sol#1501-1502)\n\t- borrowIndex (CErc20.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CErc20.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CErc20.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20.sol#1853-1854)\n\t- accountBorrows (CErc20.sol#1854-1855)\n\t- totalBorrows (CErc20.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20.sol#1070)\n\t- borrowIndex (CErc20.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CErc20.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (CErc20.sol#1079)\n\t- name (CErc20.sol#1077)\n\t- symbol (CErc20.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CErc20.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CErc20.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1611-1613)\n\t- totalSupply (CErc20.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CErc20.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CErc20.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20.sol#1980-1981)\n\t- accountBorrows (CErc20.sol#1981-1982)\n\t- totalBorrows (CErc20.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CErc20.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CErc20.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#2134-2135)\n\t- accountTokens (CErc20.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CErc20.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CErc20.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20.sol#1136)\n\t- accountTokens (CErc20.sol#1137)\n\t- transferAllowances (CErc20.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2573,
                    "vulnerability_to_line": 2602,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (CErc20.sol#2573-2602)\n\t- CErc20.sol#2581-2594\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": 2637,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n",
                    "message": "CErc20.doTransferOut uses assembly (CErc20.sol#2610-2637)\n\t- CErc20.sol#2618-2631\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CErc20.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CErc20.sol:\n\t- pragma solidity^0.5.8 (CErc20.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20.sol#2425-2428): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CErc20.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CErc20.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CErc20.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CErc20.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CErc20.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CErc20.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CErc20.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CErc20.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CErc20.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CErc20.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CErc20.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CErc20.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CErc20.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CErc20.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CErc20.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/AnchorPriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _poster) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        anchorAdmin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        poster = _poster;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 677,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        maxSwing = Exp({mantissa : maxSwingMantissa});\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 678,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numAssets; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numAssets; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_22"
            ],
            "vulnerability_findings": [
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 931,
                    "vulnerability_code": "    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (MathError, Exp memory) {\n\n        Exp memory numerator;\n\n        MathError err;\n\n\n\n        if (greaterThanExp(anchorPrice, price)) {\n\n            (err, numerator) = subExp(anchorPrice, price);\n\n            // can't underflow\n\n            assert(err == MathError.NO_ERROR);\n\n        } else {\n\n            (err, numerator) = subExp(price, anchorPrice);\n\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\n\n            assert(err == MathError.NO_ERROR);\n\n        }\n\n\n\n        return divExp(numerator, anchorPrice);\n",
                    "message": "AnchorPriceOracle.calculateSwing (AnchorPriceOracle.sol#916-931) uses a dangerous strict equality:\n\t- assert(bool)(err == MathError.NO_ERROR)\n\t- assert(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 931,
                    "vulnerability_code": "    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (MathError, Exp memory) {\n\n        Exp memory numerator;\n\n        MathError err;\n\n\n\n        if (greaterThanExp(anchorPrice, price)) {\n\n            (err, numerator) = subExp(anchorPrice, price);\n\n            // can't underflow\n\n            assert(err == MathError.NO_ERROR);\n\n        } else {\n\n            (err, numerator) = subExp(price, anchorPrice);\n\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\n\n            assert(err == MathError.NO_ERROR);\n\n        }\n\n\n\n        return divExp(numerator, anchorPrice);\n",
                    "message": "AnchorPriceOracle.calculateSwing (AnchorPriceOracle.sol#916-931) uses a dangerous strict equality:\n\t- assert(bool)(err == MathError.NO_ERROR)\n\t- assert(bool)(err == MathError.NO_ERROR)\nAnchorPriceOracle.capToMax (AnchorPriceOracle.sol#933-976) uses a dangerous strict equality:\n\t- assert(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        SetPriceLocalVars memory localVars;\n",
                    "message": "localVars in AnchorPriceOracle.setPriceInternal (AnchorPriceOracle.sol#828) is a local variable never initialiazed\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 687,
                    "vulnerability_to_line": 699,
                    "vulnerability_code": "    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(asset, Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n\n        }\n\n\n\n        uint oldScaledPrice = pendingAnchors[asset];\n\n        pendingAnchors[asset] = newScaledPrice;\n\n\n\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "AnchorPriceOracle._setPendingAnchor (AnchorPriceOracle.sol#687-699) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 707,
                    "vulnerability_to_line": 717,
                    "vulnerability_code": "    function _setPaused(bool requestedState) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n\n        }\n\n\n\n        paused = requestedState;\n\n        emit SetPaused(requestedState);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "AnchorPriceOracle._setPaused (AnchorPriceOracle.sol#707-717) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": 739,
                    "vulnerability_code": "    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // save current value, if any, for inclusion in log\n\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n\n        // Store pendingAdmin = newPendingAdmin\n\n        pendingAnchorAdmin = newPendingAnchorAdmin;\n\n\n\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "AnchorPriceOracle._setPendingAnchorAdmin (AnchorPriceOracle.sol#725-739) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": 763,
                    "vulnerability_code": "    function _acceptAnchorAdmin() public returns (uint) {\n\n        // Check caller = pendingAnchorAdmin\n\n        // msg.sender can't be zero\n\n        if (msg.sender != pendingAnchorAdmin) {\n\n            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldAnchorAdmin = anchorAdmin;\n\n        // Store admin = pendingAnchorAdmin\n\n        anchorAdmin = pendingAnchorAdmin;\n\n        // Clear the pending value\n\n        pendingAnchorAdmin = address(0);\n\n\n\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "AnchorPriceOracle._acceptAnchorAdmin (AnchorPriceOracle.sol#746-763) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": 796,
                    "vulnerability_code": "    function getPrice(address asset) public view returns (uint) {\n\n        return assetPrices(asset);\n",
                    "message": "AnchorPriceOracle.getPrice (AnchorPriceOracle.sol#794-796) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": 823,
                    "vulnerability_code": "    function setPrice(address asset, uint requestedPriceMantissa) public returns (uint) {\n\n        // Fail when msg.sender is not poster\n\n        if (msg.sender != poster) {\n\n            return failOracle(asset, Error.UNAUTHORIZED, FailureInfo.SET_PRICE_PERMISSION_CHECK);\n\n        }\n\n\n\n        return setPriceInternal(asset, requestedPriceMantissa);\n",
                    "message": "AnchorPriceOracle.setPrice (AnchorPriceOracle.sol#816-823) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in AnchorPriceOracle.sol:\n\t- pragma solidity^0.5.8 (AnchorPriceOracle.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (AnchorPriceOracle.sol#91): it allows old versions\n\t- pragma solidity^0.5.8 (AnchorPriceOracle.sol#318): it allows old versions\n\t- pragma solidity^0.5.8 (AnchorPriceOracle.sol#572): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (AnchorPriceOracle.sol#101) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (AnchorPriceOracle.sol#102) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (AnchorPriceOracle.sol#103) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _poster) public {\n",
                    "message": "Parameter '_poster' of AnchorPriceOracle. (AnchorPriceOracle.sol#674) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 687,
                    "vulnerability_to_line": 699,
                    "vulnerability_code": "    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(asset, Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n\n        }\n\n\n\n        uint oldScaledPrice = pendingAnchors[asset];\n\n        pendingAnchors[asset] = newScaledPrice;\n\n\n\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'AnchorPriceOracle._setPendingAnchor' (AnchorPriceOracle.sol#687-699) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 707,
                    "vulnerability_to_line": 717,
                    "vulnerability_code": "    function _setPaused(bool requestedState) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n\n        }\n\n\n\n        paused = requestedState;\n\n        emit SetPaused(requestedState);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'AnchorPriceOracle._setPaused' (AnchorPriceOracle.sol#707-717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": 739,
                    "vulnerability_code": "    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n\n        // Check caller = anchorAdmin\n\n        if (msg.sender != anchorAdmin) {\n\n            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // save current value, if any, for inclusion in log\n\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n\n        // Store pendingAdmin = newPendingAdmin\n\n        pendingAnchorAdmin = newPendingAnchorAdmin;\n\n\n\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'AnchorPriceOracle._setPendingAnchorAdmin' (AnchorPriceOracle.sol#725-739) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": 763,
                    "vulnerability_code": "    function _acceptAnchorAdmin() public returns (uint) {\n\n        // Check caller = pendingAnchorAdmin\n\n        // msg.sender can't be zero\n\n        if (msg.sender != pendingAnchorAdmin) {\n\n            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current value for inclusion in log\n\n        address oldAnchorAdmin = anchorAdmin;\n\n        // Store admin = pendingAnchorAdmin\n\n        anchorAdmin = pendingAnchorAdmin;\n\n        // Clear the pending value\n\n        pendingAnchorAdmin = address(0);\n\n\n\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n",
                    "message": "Function 'AnchorPriceOracle._acceptAnchorAdmin' (AnchorPriceOracle.sol#746-763) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isPriceOracle = true;\n",
                    "message": "Constant 'AnchorPriceOracle.isPriceOracle' (AnchorPriceOracle.sol#579) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant numBlocksPerPeriod = 240; // ~1 hour: 1/15 blocks/second * 3600 seconds/hour\n",
                    "message": "Constant 'AnchorPriceOracle.numBlocksPerPeriod' (AnchorPriceOracle.sol#589) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant maxSwingMantissa = 1e17; // 0.1\n",
                    "message": "Constant 'AnchorPriceOracle.maxSwingMantissa' (AnchorPriceOracle.sol#594) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => Exp) public _assetPrices;\n",
                    "message": "Variable 'AnchorPriceOracle._assetPrices' (AnchorPriceOracle.sol#621) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 750,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAnchorAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            result[0] = failOracle(address(0), Error.UNAUTHORIZED, FailureInfo.SET_PRICE_PERMISSION_CHECK);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            result[0] = failOracle(address(0), Error.FAILED_TO_SET_PRICE, FailureInfo.SET_PRICES_PARAM_VALIDATION);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numAssets; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 933,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function capToMax(Exp memory anchorPrice, Exp memory price) view internal returns (MathError, bool, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/Exponential.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in Exponential.sol:\n\t- pragma solidity^0.5.8 (Exponential.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (Exponential.sol#91): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Exponential.sol#101) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Exponential.sol#102) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Exponential.sol#103) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (Exponential.sol#103) is never used in Exponential\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/PriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_43"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (PriceOracle.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (PriceOracle.sol#745)\n\t-transferFrom (PriceOracle.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (PriceOracle.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (PriceOracle.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (PriceOracle.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (PriceOracle.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (PriceOracle.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (PriceOracle.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (PriceOracle.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracle.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (PriceOracle.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (PriceOracle.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracle.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (PriceOracle.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (PriceOracle.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracle.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracle.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1503-1504)\n\t- totalReserves (PriceOracle.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (PriceOracle.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (PriceOracle.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (PriceOracle.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (PriceOracle.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (PriceOracle.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracle.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracle.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (PriceOracle.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (PriceOracle.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (PriceOracle.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (PriceOracle.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracle.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (PriceOracle.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracle.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (PriceOracle.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (PriceOracle.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (PriceOracle.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (PriceOracle.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (PriceOracle.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracle.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracle.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracle.sol#1501-1502)\n\t- borrowIndex (PriceOracle.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (PriceOracle.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (PriceOracle.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracle.sol#1853-1854)\n\t- accountBorrows (PriceOracle.sol#1854-1855)\n\t- totalBorrows (PriceOracle.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracle.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracle.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracle.sol#1070)\n\t- borrowIndex (PriceOracle.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracle.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracle.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (PriceOracle.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (PriceOracle.sol#1079)\n\t- name (PriceOracle.sol#1077)\n\t- symbol (PriceOracle.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (PriceOracle.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (PriceOracle.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1611-1613)\n\t- totalSupply (PriceOracle.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracle.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracle.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (PriceOracle.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (PriceOracle.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracle.sol#1980-1981)\n\t- accountBorrows (PriceOracle.sol#1981-1982)\n\t- totalBorrows (PriceOracle.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (PriceOracle.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (PriceOracle.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#2134-2135)\n\t- accountTokens (PriceOracle.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (PriceOracle.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (PriceOracle.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracle.sol#1136)\n\t- accountTokens (PriceOracle.sol#1137)\n\t- transferAllowances (PriceOracle.sol#1141)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (PriceOracle.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in PriceOracle.sol:\n\t- pragma solidity^0.5.8 (PriceOracle.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracle.sol#2425-2427): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (PriceOracle.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (PriceOracle.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (PriceOracle.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (PriceOracle.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (PriceOracle.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (PriceOracle.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (PriceOracle.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (PriceOracle.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (PriceOracle.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (PriceOracle.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (PriceOracle.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (PriceOracle.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (PriceOracle.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (PriceOracle.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (PriceOracle.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/CToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_43"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CToken.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (CToken.sol#745)\n\t-transferFrom (CToken.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CToken.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (CToken.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CToken.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CToken.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (CToken.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CToken.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CToken.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (CToken.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CToken.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CToken.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (CToken.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CToken.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CToken.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CToken.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CToken.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1503-1504)\n\t- totalReserves (CToken.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CToken.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (CToken.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CToken.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (CToken.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CToken.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CToken.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CToken.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (CToken.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CToken.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CToken.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CToken.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (CToken.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CToken.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (CToken.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CToken.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CToken.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CToken.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CToken.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CToken.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CToken.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CToken.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CToken.sol#1501-1502)\n\t- borrowIndex (CToken.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CToken.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CToken.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (CToken.sol#1853-1854)\n\t- accountBorrows (CToken.sol#1854-1855)\n\t- totalBorrows (CToken.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CToken.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CToken.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CToken.sol#1070)\n\t- borrowIndex (CToken.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CToken.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CToken.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CToken.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (CToken.sol#1079)\n\t- name (CToken.sol#1077)\n\t- symbol (CToken.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CToken.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CToken.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1611-1613)\n\t- totalSupply (CToken.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CToken.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CToken.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CToken.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CToken.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (CToken.sol#1980-1981)\n\t- accountBorrows (CToken.sol#1981-1982)\n\t- totalBorrows (CToken.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CToken.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CToken.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#2134-2135)\n\t- accountTokens (CToken.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CToken.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CToken.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (CToken.sol#1136)\n\t- accountTokens (CToken.sol#1137)\n\t- transferAllowances (CToken.sol#1141)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CToken.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CToken.sol:\n\t- pragma solidity^0.5.8 (CToken.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (CToken.sol#852-853): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CToken.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CToken.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CToken.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CToken.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CToken.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CToken.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CToken.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CToken.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CToken.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CToken.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CToken.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CToken.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CToken.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CToken.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CToken.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/PriceOracleProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (accountAssets[msg.sender].length >= maxAssets)  {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2749,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2750,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2968,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2970,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address comptroller_, address v1PriceOracle_, address cEtherAddress_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3911,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        comptroller = Comptroller(comptroller_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3912,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        cEtherAddress = cEtherAddress_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3914,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Market storage marketToJoin = markets[address(cToken)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3081,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(changeStatus == 0, \"change not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3831,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3835,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"redeemTokens zero\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 3094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3081,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 3821,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_88"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2852,
                    "vulnerability_to_line": 2868,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback (PriceOracleProxy.sol#2852-2868) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (PriceOracleProxy.sol#2854-2856)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2677,
                    "vulnerability_to_line": 2680,
                    "vulnerability_code": "    address public comptrollerImplementation;\n\n\n\n    /**\n",
                    "message": "UnitrollerAdminStorage.comptrollerImplementation (PriceOracleProxy.sol#2677-2680) is never initialized. It is used in:\n\t- adminOrInitializing (PriceOracleProxy.sol#3853-3865)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (PriceOracleProxy.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (PriceOracleProxy.sol#745)\n\t-transferFrom (PriceOracleProxy.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (PriceOracleProxy.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (PriceOracleProxy.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (PriceOracleProxy.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (PriceOracleProxy.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (PriceOracleProxy.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (PriceOracleProxy.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (PriceOracleProxy.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracleProxy.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (PriceOracleProxy.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (PriceOracleProxy.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (PriceOracleProxy.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (PriceOracleProxy.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (PriceOracleProxy.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3803,
                    "vulnerability_to_line": 3820,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller._supportMarket (PriceOracleProxy.sol#3803-3820):\n\tExternal calls:\n\t- cToken.isCToken() (PriceOracleProxy.sol#3812)\n\tState variables written after the call(s):\n\t- markets (PriceOracleProxy.sol#3814-3815)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracleProxy.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracleProxy.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1503-1504)\n\t- totalReserves (PriceOracleProxy.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (PriceOracleProxy.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (PriceOracleProxy.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3049,
                    "vulnerability_to_line": 3101,
                    "vulnerability_code": "    function exitMarket(address cTokenAddress) external returns (uint) {\n\n        CToken cToken = CToken(cTokenAddress);\n\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n\n\n        /* Fail if the sender has a borrow balance */\n\n        if (amountOwed != 0) {\n\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n\n        }\n\n\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n\n        }\n\n\n\n        Market storage marketToExit = markets[address(cToken)];\n\n\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n\n        if (!marketToExit.accountMembership[msg.sender]) {\n\n            return uint(Error.NO_ERROR);\n\n        }\n\n\n\n        /* Set cToken account membership to false */\n\n        delete marketToExit.accountMembership[msg.sender];\n\n\n\n        /* Delete cToken from the account\u2019s list of assets */\n\n        // load into memory for faster iteration\n\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n\n        uint len = userAssetList.length;\n\n        uint assetIndex = len;\n\n        for (uint i = 0; i < len; i++) {\n\n            if (userAssetList[i] == cToken) {\n\n                assetIndex = i;\n\n                break;\n\n            }\n\n        }\n\n\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n\n        assert(assetIndex < len);\n\n\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n\n        CToken[] storage storedList = accountAssets[msg.sender];\n\n        storedList[assetIndex] = storedList[storedList.length - 1];\n\n        storedList.length--;\n\n\n\n        emit MarketExited(cToken, msg.sender);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in Comptroller.exitMarket (PriceOracleProxy.sol#3049-3101):\n\tExternal calls:\n\t- (oErr,tokensHeld,amountOwed) = cToken.getAccountSnapshot(msg.sender) (PriceOracleProxy.sol#3052-3053)\n\t- allowed = redeemAllowedInternal(cTokenAddress,msg.sender,tokensHeld) (PriceOracleProxy.sol#3061-3062)\n\tState variables written after the call(s):\n\t- accountAssets (PriceOracleProxy.sol#3093-3094)\n\t- accountAssets (PriceOracleProxy.sol#3095-3096)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (PriceOracleProxy.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (PriceOracleProxy.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (PriceOracleProxy.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracleProxy.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracleProxy.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (PriceOracleProxy.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (PriceOracleProxy.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (PriceOracleProxy.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (PriceOracleProxy.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (PriceOracleProxy.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (PriceOracleProxy.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (PriceOracleProxy.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (PriceOracleProxy.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (PriceOracleProxy.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (PriceOracleProxy.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (PriceOracleProxy.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (PriceOracleProxy.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": 2462,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (PriceOracleProxy.sol#2449-2462) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (PriceOracleProxy.sol#2459)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 3803,
                    "vulnerability_to_line": 3820,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Comptroller._supportMarket (PriceOracleProxy.sol#3803-3820) does not use the value returned by external calls:\n\t-cToken.isCToken() (PriceOracleProxy.sol#3812)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3532,
                    "vulnerability_to_line": 3533,
                    "vulnerability_code": "            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- (oErr,vars.cTokenBalance,vars.borrowBalance,vars.exchangeRateMantissa) = asset.getAccountSnapshot(account) (PriceOracleProxy.sol#3532-3533)\n"
                },
                {
                    "name": "calls-loop",
                    "vulnerability_from_line": 3540,
                    "vulnerability_to_line": 3541,
                    "vulnerability_code": "            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n",
                    "message": "Comptroller.getHypotheticalAccountLiquidityInternal has external calls inside a loop:\n\t- vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset) (PriceOracleProxy.sol#3540-3541)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (PriceOracleProxy.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (PriceOracleProxy.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracleProxy.sol#1501-1502)\n\t- borrowIndex (PriceOracleProxy.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (PriceOracleProxy.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (PriceOracleProxy.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracleProxy.sol#1853-1854)\n\t- accountBorrows (PriceOracleProxy.sol#1854-1855)\n\t- totalBorrows (PriceOracleProxy.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracleProxy.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracleProxy.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (PriceOracleProxy.sol#1070)\n\t- borrowIndex (PriceOracleProxy.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (PriceOracleProxy.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (PriceOracleProxy.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (PriceOracleProxy.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (PriceOracleProxy.sol#1079)\n\t- name (PriceOracleProxy.sol#1077)\n\t- symbol (PriceOracleProxy.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (PriceOracleProxy.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (PriceOracleProxy.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#1611-1613)\n\t- totalSupply (PriceOracleProxy.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (PriceOracleProxy.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (PriceOracleProxy.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (PriceOracleProxy.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (PriceOracleProxy.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (PriceOracleProxy.sol#1980-1981)\n\t- accountBorrows (PriceOracleProxy.sol#1981-1982)\n\t- totalBorrows (PriceOracleProxy.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (PriceOracleProxy.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (PriceOracleProxy.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#2134-2135)\n\t- accountTokens (PriceOracleProxy.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (PriceOracleProxy.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (PriceOracleProxy.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (PriceOracleProxy.sol#1136)\n\t- accountTokens (PriceOracleProxy.sol#1137)\n\t- transferAllowances (PriceOracleProxy.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2573,
                    "vulnerability_to_line": 2602,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (PriceOracleProxy.sol#2573-2602)\n\t- PriceOracleProxy.sol#2581-2594\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": 2639,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n}\n\n\n",
                    "message": "CErc20.doTransferOut uses assembly (PriceOracleProxy.sol#2610-2639)\n\t- PriceOracleProxy.sol#2618-2631\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2852,
                    "vulnerability_to_line": 2868,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Unitroller.fallback uses assembly (PriceOracleProxy.sol#2852-2868)\n\t- PriceOracleProxy.sol#2858-2868\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (PriceOracleProxy.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2753,
                    "vulnerability_to_line": 2769,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (PriceOracleProxy.sol#2753-2769) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": 2795,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (PriceOracleProxy.sol#2773-2795) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2802,
                    "vulnerability_to_line": 2821,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (PriceOracleProxy.sol#2802-2821) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2825,
                    "vulnerability_to_line": 2848,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (PriceOracleProxy.sol#2825-2848) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n",
                    "message": "ComptrollerInterface.enterMarkets (PriceOracleProxy.sol#15) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3000,
                    "vulnerability_to_line": 3043,
                    "vulnerability_code": "    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n\n            if (accountAssets[msg.sender].length >= maxAssets)  {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n\n        return results;\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.enterMarkets (PriceOracleProxy.sol#3000-3043) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3488,
                    "vulnerability_to_line": 3495,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n\n\n\n        return (uint(err), liquidity, shortfall);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller.getAccountLiquidity (PriceOracleProxy.sol#3488-3495) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3649,
                    "vulnerability_to_line": 3671,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._setPriceOracle (PriceOracleProxy.sol#3649-3671) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3820,
                    "vulnerability_to_line": 3848,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Comptroller._become (PriceOracleProxy.sol#3820-3848) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 3922,
                    "vulnerability_to_line": 3938,
                    "vulnerability_code": "    function getUnderlyingPrice(CToken cToken) public view returns (uint) {\n\n        address cTokenAddress = address(cToken);\n\n        (bool isListed, ) = comptroller.markets(cTokenAddress);\n\n\n\n        if (!isListed) {\n\n            // not listed, worthless\n\n            return 0;\n\n        } else if (cTokenAddress == cEtherAddress) {\n\n            // ether always worth 1\n\n            return 1e18;\n\n        } else {\n\n            // read from v1 oracle\n\n            address underlying = CErc20(cTokenAddress).underlying();\n\n            return v1PriceOracle.assetPrices(underlying);\n\n        }\n\n    }\n",
                    "message": "PriceOracleProxy.getUnderlyingPrice (PriceOracleProxy.sol#3922-3938) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2655,
                    "vulnerability_to_line": 2658,
                    "vulnerability_code": "    function getUnderlyingPrice(CToken cToken) external view returns (uint);\n\n}\n\n\n",
                    "message": "PriceOracle.getUnderlyingPrice (PriceOracleProxy.sol#2655-2658) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in PriceOracleProxy.sol:\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#2425-2428): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#2641-2643): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#2660-2663): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#2716-2720): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#2870-2879): it allows old versions\n\t- pragma solidity^0.5.8 (PriceOracleProxy.sol#3867-3872): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2852,
                    "vulnerability_to_line": 2868,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Low level call in Unitroller.fallback (PriceOracleProxy.sol#2852-2868):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) PriceOracleProxy.sol#2854-2856\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (PriceOracleProxy.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (PriceOracleProxy.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (PriceOracleProxy.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (PriceOracleProxy.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (PriceOracleProxy.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (PriceOracleProxy.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (PriceOracleProxy.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (PriceOracleProxy.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (PriceOracleProxy.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (PriceOracleProxy.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (PriceOracleProxy.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (PriceOracleProxy.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (PriceOracleProxy.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (PriceOracleProxy.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (PriceOracleProxy.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2753,
                    "vulnerability_to_line": 2769,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (PriceOracleProxy.sol#2753-2769) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": 2795,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (PriceOracleProxy.sol#2773-2795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2802,
                    "vulnerability_to_line": 2821,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (PriceOracleProxy.sol#2802-2821) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2825,
                    "vulnerability_to_line": 2848,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (PriceOracleProxy.sol#2825-2848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3649,
                    "vulnerability_to_line": 3671,
                    "vulnerability_code": "    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n\n        }\n\n\n\n        // Track the old oracle for the comptroller\n\n        PriceOracle oldOracle = oracle;\n\n\n\n        // Ensure invoke newOracle.isPriceOracle() returns true\n\n        // require(newOracle.isPriceOracle(), \"oracle method isPriceOracle returned false\");\n\n\n\n        // Set comptroller's oracle to newOracle\n\n        oracle = newOracle;\n\n\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n\n        emit NewPriceOracle(oldOracle, newOracle);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setPriceOracle' (PriceOracleProxy.sol#3649-3671) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3676,
                    "vulnerability_to_line": 3701,
                    "vulnerability_code": "    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n\n        }\n\n\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCloseFactor' (PriceOracleProxy.sol#3676-3701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3707,
                    "vulnerability_to_line": 3743,
                    "vulnerability_code": "    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n\n        }\n\n\n\n        // Verify market is listed\n\n        Market storage market = markets[address(cToken)];\n\n        if (!market.isListed) {\n\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n\n        }\n\n\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n\n\n        // Check collateral factor <= 0.9\n\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n\n        }\n\n\n\n        // If collateral factor != 0, fail if price == 0\n\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n\n        }\n\n\n\n        // Set market's collateral factor to new collateral factor, remember old value\n\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setCollateralFactor' (PriceOracleProxy.sol#3707-3743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3748,
                    "vulnerability_to_line": 3762,
                    "vulnerability_code": "    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n\n        }\n\n\n\n        uint oldMaxAssets = maxAssets;\n\n        maxAssets = newMaxAssets;\n\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setMaxAssets' (PriceOracleProxy.sol#3748-3762) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3767,
                    "vulnerability_to_line": 3798,
                    "vulnerability_code": "    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n\n        // Check caller is admin OR currently initialzing as new unitroller implementation\n\n        if (!adminOrInitializing()) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n\n        }\n\n\n\n        // Check de-scaled 1 <= newLiquidationDiscount <= 1.5\n\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n\n        }\n\n\n\n        // Save current value for use in log\n\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n\n\n        // Set liquidation incentive to new incentive\n\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n\n\n        // Emit event with old incentive, new incentive\n\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._setLiquidationIncentive' (PriceOracleProxy.sol#3767-3798) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3803,
                    "vulnerability_to_line": 3820,
                    "vulnerability_code": "    function _supportMarket(CToken cToken) external returns (uint) {\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n\n        }\n\n\n\n        if (markets[address(cToken)].isListed) {\n\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n\n        }\n\n\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n\n\n        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n\n        emit MarketListed(cToken);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'Comptroller._supportMarket' (PriceOracleProxy.sol#3803-3820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3820,
                    "vulnerability_to_line": 3848,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n\n        uint changeStatus = unitroller._acceptImplementation();\n\n\n\n        require(changeStatus == 0, \"change not authorized\");\n\n\n\n        if (!reinitializing) {\n\n            Comptroller freshBrainedComptroller = Comptroller(address(unitroller));\n\n\n\n            // Ensure invoke _setPriceOracle() = 0\n\n            uint err = freshBrainedComptroller._setPriceOracle(_oracle);\n\n            require (err == uint(Error.NO_ERROR), \"set price oracle error\");\n\n\n\n            // Ensure invoke _setCloseFactor() = 0\n\n            err = freshBrainedComptroller._setCloseFactor(_closeFactorMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set close factor error\");\n\n\n\n            // Ensure invoke _setMaxAssets() = 0\n\n            err = freshBrainedComptroller._setMaxAssets(_maxAssets);\n\n            require (err == uint(Error.NO_ERROR), \"set max asssets error\");\n\n\n\n            // Ensure invoke _setLiquidationIncentive(liquidationIncentiveMinMantissa) = 0\n\n            err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);\n\n            require (err == uint(Error.NO_ERROR), \"set liquidation incentive error\");\n\n        }\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Comptroller._become' (PriceOracleProxy.sol#3820-3848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_oracle' of Comptroller._become (PriceOracleProxy.sol#3820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_closeFactorMantissa' of Comptroller._become (PriceOracleProxy.sol#3820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {\n",
                    "message": "Parameter '_maxAssets' of Comptroller._become (PriceOracleProxy.sol#3820) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2951,
                    "vulnerability_to_line": 2953,
                    "vulnerability_code": "    bool public constant isComptroller = true;\n\n\n",
                    "message": "Constant 'Comptroller.isComptroller' (PriceOracleProxy.sol#2951-2953) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2954,
                    "vulnerability_to_line": 2956,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMinMantissa' (PriceOracleProxy.sol#2954-2956) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2957,
                    "vulnerability_to_line": 2959,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.closeFactorMaxMantissa' (PriceOracleProxy.sol#2957-2959) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2960,
                    "vulnerability_to_line": 2962,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n\n\n",
                    "message": "Constant 'Comptroller.collateralFactorMaxMantissa' (PriceOracleProxy.sol#2960-2962) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2963,
                    "vulnerability_to_line": 2965,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMinMantissa' (PriceOracleProxy.sol#2963-2965) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2966,
                    "vulnerability_to_line": 2968,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n\n\n",
                    "message": "Constant 'Comptroller.liquidationIncentiveMaxMantissa' (PriceOracleProxy.sol#2966-2968) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3900,
                    "vulnerability_to_line": 3903,
                    "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n\n    /**\n",
                    "message": "Constant 'PriceOracleProxy.isPriceOracle' (PriceOracleProxy.sol#3900-3903) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Exponential.mantissaOne (PriceOracleProxy.sol#435) is never used in Comptroller\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 3094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        storedList.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3081,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < len; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < assets.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3867,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (redeemTokens == 0 && redeemAmount > 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint borrowAmount) internal view returns (Error, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint repayAmount) external view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_TX_ORIGIN",
                    "vulnerability_from_line": 3858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                tx.origin == admin\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMinMantissa = 5e16; // 0.05\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant closeFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2960,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant collateralFactorMaxMantissa = 9e17; // 0.9\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMinMantissa = mantissaOne;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2966,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/ErrorReporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ErrorReporter.sol:\n\t- pragma solidity^0.5.8 (ErrorReporter.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/Unitroller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to caller\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_55"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 2636,
                    "vulnerability_to_line": 2650,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n",
                    "message": "Unitroller.fallback (Unitroller.sol#2636-2650) uses delegatecall to a input-controlled function id\n\t(success) = comptrollerImplementation.delegatecall(msg.data) (Unitroller.sol#2638-2640)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (Unitroller.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (Unitroller.sol#745)\n\t-transferFrom (Unitroller.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (Unitroller.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (Unitroller.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (Unitroller.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Unitroller.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (Unitroller.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (Unitroller.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Unitroller.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (Unitroller.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (Unitroller.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Unitroller.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (Unitroller.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (Unitroller.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Unitroller.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Unitroller.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Unitroller.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1503-1504)\n\t- totalReserves (Unitroller.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (Unitroller.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (Unitroller.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (Unitroller.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (Unitroller.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Unitroller.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Unitroller.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Unitroller.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (Unitroller.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Unitroller.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Unitroller.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (Unitroller.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (Unitroller.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Unitroller.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (Unitroller.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (Unitroller.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (Unitroller.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (Unitroller.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (Unitroller.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (Unitroller.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Unitroller.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Unitroller.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Unitroller.sol#1501-1502)\n\t- borrowIndex (Unitroller.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (Unitroller.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Unitroller.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (Unitroller.sol#1853-1854)\n\t- accountBorrows (Unitroller.sol#1854-1855)\n\t- totalBorrows (Unitroller.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Unitroller.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Unitroller.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Unitroller.sol#1070)\n\t- borrowIndex (Unitroller.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Unitroller.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Unitroller.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Unitroller.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (Unitroller.sol#1079)\n\t- name (Unitroller.sol#1077)\n\t- symbol (Unitroller.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (Unitroller.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Unitroller.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1611-1613)\n\t- totalSupply (Unitroller.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Unitroller.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Unitroller.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (Unitroller.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Unitroller.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (Unitroller.sol#1980-1981)\n\t- accountBorrows (Unitroller.sol#1981-1982)\n\t- totalBorrows (Unitroller.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (Unitroller.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Unitroller.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#2134-2135)\n\t- accountTokens (Unitroller.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (Unitroller.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Unitroller.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (Unitroller.sol#1136)\n\t- accountTokens (Unitroller.sol#1137)\n\t- transferAllowances (Unitroller.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2636,
                    "vulnerability_to_line": 2650,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n",
                    "message": "Unitroller.fallback uses assembly (Unitroller.sol#2636-2650)\n\t- Unitroller.sol#2642-2650\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2482,
                    "vulnerability_code": "    uint public closeFactorMantissa;\n\n\n\n    /**\n",
                    "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (Unitroller.sol#2479-2482)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (Unitroller.sol#2484-2487)\nComptrollerV1Storage.maxAssets should be constant (Unitroller.sol#2489-2492)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (Unitroller.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2537,
                    "vulnerability_to_line": 2553,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingImplementation (Unitroller.sol#2537-2553) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2557,
                    "vulnerability_to_line": 2579,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptImplementation (Unitroller.sol#2557-2579) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2586,
                    "vulnerability_to_line": 2605,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._setPendingAdmin (Unitroller.sol#2586-2605) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2609,
                    "vulnerability_to_line": 2632,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Unitroller._acceptAdmin (Unitroller.sol#2609-2632) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in Unitroller.sol:\n\t- pragma solidity^0.5.8 (Unitroller.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#257): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#2425-2427): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#2444-2447): it allows old versions\n\t- pragma solidity^0.5.8 (Unitroller.sol#2500-2504): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 2636,
                    "vulnerability_to_line": 2650,
                    "vulnerability_code": "    function () payable external {\n\n        // delegate all other functions to current implementation\n\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n              let free_mem_ptr := mload(0x40)\n\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n\n\n              switch success\n\n              case 0 { revert(free_mem_ptr, returndatasize) }\n\n              default { return(free_mem_ptr, returndatasize) }\n\n        }\n\n    }\n",
                    "message": "Low level call in Unitroller.fallback (Unitroller.sol#2636-2650):\n\t-(success) = comptrollerImplementation.delegatecall(msg.data) Unitroller.sol#2638-2640\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Unitroller.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Unitroller.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Unitroller.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (Unitroller.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (Unitroller.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (Unitroller.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (Unitroller.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (Unitroller.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (Unitroller.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (Unitroller.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (Unitroller.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (Unitroller.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (Unitroller.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (Unitroller.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (Unitroller.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2537,
                    "vulnerability_to_line": 2553,
                    "vulnerability_code": "    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n\n        }\n\n\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingImplementation' (Unitroller.sol#2537-2553) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2557,
                    "vulnerability_to_line": 2579,
                    "vulnerability_code": "    function _acceptImplementation() public returns (uint) {\n\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\n\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldImplementation = comptrollerImplementation;\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n\n\n        pendingComptrollerImplementation = address(0);\n\n\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptImplementation' (Unitroller.sol#2557-2579) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2586,
                    "vulnerability_to_line": 2605,
                    "vulnerability_code": "    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._setPendingAdmin' (Unitroller.sol#2586-2605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2609,
                    "vulnerability_to_line": 2632,
                    "vulnerability_code": "    function _acceptAdmin() public returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'Unitroller._acceptAdmin' (Unitroller.sol#2609-2632) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingComptrollerImplementation = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        pendingAdmin = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2638,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/CarefulMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CarefulMath.sol:\n\t- pragma solidity^0.5.8 (CarefulMath.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/EIP20Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in EIP20Interface.sol:\n\t- pragma solidity^0.5.8 (EIP20Interface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/InterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in InterestRateModel.sol:\n\t- pragma solidity^0.5.8 (InterestRateModel.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/ComptrollerStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_44"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (ComptrollerStorage.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (ComptrollerStorage.sol#745)\n\t-transferFrom (ComptrollerStorage.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (ComptrollerStorage.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerStorage.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (ComptrollerStorage.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ComptrollerStorage.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (ComptrollerStorage.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (ComptrollerStorage.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ComptrollerStorage.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (ComptrollerStorage.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ComptrollerStorage.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerStorage.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (ComptrollerStorage.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ComptrollerStorage.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1503-1504)\n\t- totalReserves (ComptrollerStorage.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (ComptrollerStorage.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (ComptrollerStorage.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (ComptrollerStorage.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (ComptrollerStorage.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (ComptrollerStorage.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (ComptrollerStorage.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (ComptrollerStorage.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ComptrollerStorage.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (ComptrollerStorage.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerStorage.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ComptrollerStorage.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerStorage.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (ComptrollerStorage.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (ComptrollerStorage.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (ComptrollerStorage.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (ComptrollerStorage.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (ComptrollerStorage.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerStorage.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerStorage.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#1501-1502)\n\t- borrowIndex (ComptrollerStorage.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (ComptrollerStorage.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ComptrollerStorage.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1853-1854)\n\t- accountBorrows (ComptrollerStorage.sol#1854-1855)\n\t- totalBorrows (ComptrollerStorage.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerStorage.sol#1070)\n\t- borrowIndex (ComptrollerStorage.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerStorage.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerStorage.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ComptrollerStorage.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (ComptrollerStorage.sol#1079)\n\t- name (ComptrollerStorage.sol#1077)\n\t- symbol (ComptrollerStorage.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (ComptrollerStorage.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ComptrollerStorage.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1611-1613)\n\t- totalSupply (ComptrollerStorage.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerStorage.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerStorage.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (ComptrollerStorage.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ComptrollerStorage.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerStorage.sol#1980-1981)\n\t- accountBorrows (ComptrollerStorage.sol#1981-1982)\n\t- totalBorrows (ComptrollerStorage.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (ComptrollerStorage.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (ComptrollerStorage.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#2134-2135)\n\t- accountTokens (ComptrollerStorage.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (ComptrollerStorage.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ComptrollerStorage.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerStorage.sol#1136)\n\t- accountTokens (ComptrollerStorage.sol#1137)\n\t- transferAllowances (ComptrollerStorage.sol#1141)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2479,
                    "vulnerability_to_line": 2482,
                    "vulnerability_code": "    uint public closeFactorMantissa;\n\n\n\n    /**\n",
                    "message": "ComptrollerV1Storage.closeFactorMantissa should be constant (ComptrollerStorage.sol#2479-2482)\nComptrollerV1Storage.liquidationIncentiveMantissa should be constant (ComptrollerStorage.sol#2484-2487)\nComptrollerV1Storage.maxAssets should be constant (ComptrollerStorage.sol#2489-2492)\nUnitrollerAdminStorage.admin should be constant (ComptrollerStorage.sol#2451-2454)\nUnitrollerAdminStorage.comptrollerImplementation should be constant (ComptrollerStorage.sol#2461-2464)\nUnitrollerAdminStorage.pendingAdmin should be constant (ComptrollerStorage.sol#2456-2459)\nUnitrollerAdminStorage.pendingComptrollerImplementation should be constant (ComptrollerStorage.sol#2466-2469)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (ComptrollerStorage.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ComptrollerStorage.sol:\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#2425-2427): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerStorage.sol#2444-2447): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (ComptrollerStorage.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (ComptrollerStorage.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (ComptrollerStorage.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (ComptrollerStorage.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (ComptrollerStorage.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (ComptrollerStorage.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (ComptrollerStorage.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (ComptrollerStorage.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (ComptrollerStorage.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (ComptrollerStorage.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (ComptrollerStorage.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (ComptrollerStorage.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (ComptrollerStorage.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (ComptrollerStorage.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (ComptrollerStorage.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/WhitePaperInterestRateModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint baseRate_, uint multiplier_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        baseRate = baseRate_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        multiplier = multiplier_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": "InterestRateModel.getBorrowRate (WhitePaperInterestRateModel.sol#338) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": 479,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n\n        _reserves; // pragma ignore unused argument\n\n\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n\n        if (err0 != IRError.NO_ERROR) {\n\n            return (uint(err0), 0);\n\n        }\n\n\n\n        // And then divide down by blocks per year.\n\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n\n        assert(err1 == MathError.NO_ERROR);\n\n\n\n        _utilizationRate; // pragma ignore unused variable\n\n\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n",
                    "message": "WhitePaperInterestRateModel.getBorrowRate (WhitePaperInterestRateModel.sol#462-479) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in WhitePaperInterestRateModel.sol:\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#91): it allows old versions\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#318): it allows old versions\n\t- pragma solidity^0.5.8 (WhitePaperInterestRateModel.sol#350): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (WhitePaperInterestRateModel.sol#101) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (WhitePaperInterestRateModel.sol#102) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (WhitePaperInterestRateModel.sol#103) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isInterestRateModel = true;\n",
                    "message": "Constant 'WhitePaperInterestRateModel.isInterestRateModel' (WhitePaperInterestRateModel.sol#362) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public constant blocksPerYear = 2102400;\n",
                    "message": "Constant 'WhitePaperInterestRateModel.blocksPerYear' (WhitePaperInterestRateModel.sol#377) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/CEther.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_44"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CEther.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (CEther.sol#745)\n\t-transferFrom (CEther.sol#759)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 2531,
                    "vulnerability_to_line": 2538,
                    "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n\n    /**\n",
                    "message": "CEther.getCashPrior (CEther.sol#2531-2538) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CEther.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (CEther.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CEther.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CEther.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (CEther.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CEther.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CEther.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (CEther.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CEther.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CEther.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (CEther.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CEther.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CEther.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CEther.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CEther.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1503-1504)\n\t- totalReserves (CEther.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CEther.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (CEther.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CEther.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (CEther.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CEther.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CEther.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CEther.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (CEther.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CEther.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CEther.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CEther.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (CEther.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CEther.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (CEther.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CEther.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CEther.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CEther.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CEther.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CEther.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CEther.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CEther.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CEther.sol#1501-1502)\n\t- borrowIndex (CEther.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CEther.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CEther.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (CEther.sol#1853-1854)\n\t- accountBorrows (CEther.sol#1854-1855)\n\t- totalBorrows (CEther.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CEther.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CEther.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CEther.sol#1070)\n\t- borrowIndex (CEther.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CEther.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CEther.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CEther.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (CEther.sol#1079)\n\t- name (CEther.sol#1077)\n\t- symbol (CEther.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CEther.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CEther.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#1611-1613)\n\t- totalSupply (CEther.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CEther.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CEther.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CEther.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CEther.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (CEther.sol#1980-1981)\n\t- accountBorrows (CEther.sol#1981-1982)\n\t- totalBorrows (CEther.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CEther.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CEther.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#2134-2135)\n\t- accountTokens (CEther.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CEther.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CEther.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (CEther.sol#1136)\n\t- accountTokens (CEther.sol#1137)\n\t- transferAllowances (CEther.sol#1141)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CEther.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CEther.sol:\n\t- pragma solidity^0.5.8 (CEther.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (CEther.sol#2425-2428): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CEther.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CEther.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CEther.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CEther.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CEther.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CEther.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CEther.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CEther.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CEther.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CEther.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CEther.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CEther.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CEther.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CEther.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CEther.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CEther is CToken {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        to.transfer(amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return Error.NO_ERROR;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/Maximillion.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(CEther cEther_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        cEther = cEther_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_46"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 2630,
                    "vulnerability_to_line": 2640,
                    "vulnerability_code": "    function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\n\n        uint received = msg.value;\n\n        uint borrows = cEther_.borrowBalanceCurrent(borrower);\n\n        if (received > borrows) {\n\n            cEther_.repayBorrowBehalf.value(borrows)(borrower);\n\n            msg.sender.transfer(received - borrows);\n\n        } else {\n\n            cEther_.repayBorrowBehalf.value(received)(borrower);\n\n        }\n\n    }\n",
                    "message": "Maximillion.repayBehalfExplicit (Maximillion.sol#2630-2640) sends eth to arbitrary user\n\tDangerous calls:\n\t- cEther_.repayBorrowBehalf.value(borrows)(borrower) (Maximillion.sol#2634-2635)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (Maximillion.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (Maximillion.sol#745)\n\t-transferFrom (Maximillion.sol#759)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 2531,
                    "vulnerability_to_line": 2538,
                    "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n\n    /**\n",
                    "message": "CEther.getCashPrior (Maximillion.sol#2531-2538) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (Maximillion.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (Maximillion.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (Maximillion.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (Maximillion.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (Maximillion.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (Maximillion.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (Maximillion.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (Maximillion.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (Maximillion.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (Maximillion.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (Maximillion.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (Maximillion.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (Maximillion.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Maximillion.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Maximillion.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (Maximillion.sol#1503-1504)\n\t- totalReserves (Maximillion.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (Maximillion.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (Maximillion.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (Maximillion.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (Maximillion.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (Maximillion.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (Maximillion.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (Maximillion.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Maximillion.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Maximillion.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (Maximillion.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (Maximillion.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (Maximillion.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (Maximillion.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (Maximillion.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (Maximillion.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (Maximillion.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (Maximillion.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (Maximillion.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (Maximillion.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (Maximillion.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (Maximillion.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (Maximillion.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (Maximillion.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (Maximillion.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Maximillion.sol#1501-1502)\n\t- borrowIndex (Maximillion.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (Maximillion.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (Maximillion.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (Maximillion.sol#1853-1854)\n\t- accountBorrows (Maximillion.sol#1854-1855)\n\t- totalBorrows (Maximillion.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Maximillion.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Maximillion.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (Maximillion.sol#1070)\n\t- borrowIndex (Maximillion.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (Maximillion.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (Maximillion.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (Maximillion.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (Maximillion.sol#1079)\n\t- name (Maximillion.sol#1077)\n\t- symbol (Maximillion.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (Maximillion.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (Maximillion.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (Maximillion.sol#1611-1613)\n\t- totalSupply (Maximillion.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (Maximillion.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (Maximillion.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (Maximillion.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (Maximillion.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (Maximillion.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (Maximillion.sol#1980-1981)\n\t- accountBorrows (Maximillion.sol#1981-1982)\n\t- totalBorrows (Maximillion.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (Maximillion.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (Maximillion.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (Maximillion.sol#2134-2135)\n\t- accountTokens (Maximillion.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (Maximillion.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (Maximillion.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (Maximillion.sol#1136)\n\t- accountTokens (Maximillion.sol#1137)\n\t- transferAllowances (Maximillion.sol#1141)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (Maximillion.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2619,
                    "vulnerability_to_line": 2624,
                    "vulnerability_code": "    function repayBehalf(address borrower) public payable {\n\n        return repayBehalfExplicit(borrower, cEther);\n\n    }\n\n\n\n    /**\n",
                    "message": "Maximillion.repayBehalf (Maximillion.sol#2619-2624) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in Maximillion.sol:\n\t- pragma solidity^0.5.8 (Maximillion.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#2425-2428): it allows old versions\n\t- pragma solidity^0.5.8 (Maximillion.sol#2594-2597): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (Maximillion.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (Maximillion.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (Maximillion.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (Maximillion.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (Maximillion.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (Maximillion.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (Maximillion.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (Maximillion.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (Maximillion.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (Maximillion.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (Maximillion.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (Maximillion.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (Maximillion.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (Maximillion.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (Maximillion.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CEther is CToken {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        to.transfer(amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return Error.NO_ERROR;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/SimplePriceOracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2476,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_50"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (SimplePriceOracle.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (SimplePriceOracle.sol#745)\n\t-transferFrom (SimplePriceOracle.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (SimplePriceOracle.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (SimplePriceOracle.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (SimplePriceOracle.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (SimplePriceOracle.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (SimplePriceOracle.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (SimplePriceOracle.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (SimplePriceOracle.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (SimplePriceOracle.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (SimplePriceOracle.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (SimplePriceOracle.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (SimplePriceOracle.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (SimplePriceOracle.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (SimplePriceOracle.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (SimplePriceOracle.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (SimplePriceOracle.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (SimplePriceOracle.sol#1503-1504)\n\t- totalReserves (SimplePriceOracle.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (SimplePriceOracle.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (SimplePriceOracle.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (SimplePriceOracle.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (SimplePriceOracle.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (SimplePriceOracle.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (SimplePriceOracle.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (SimplePriceOracle.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (SimplePriceOracle.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (SimplePriceOracle.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (SimplePriceOracle.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (SimplePriceOracle.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (SimplePriceOracle.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (SimplePriceOracle.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (SimplePriceOracle.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (SimplePriceOracle.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (SimplePriceOracle.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (SimplePriceOracle.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (SimplePriceOracle.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (SimplePriceOracle.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (SimplePriceOracle.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (SimplePriceOracle.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (SimplePriceOracle.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2468,
                    "vulnerability_to_line": 2481,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (SimplePriceOracle.sol#2468-2481) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (SimplePriceOracle.sol#2478)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (SimplePriceOracle.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (SimplePriceOracle.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (SimplePriceOracle.sol#1501-1502)\n\t- borrowIndex (SimplePriceOracle.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (SimplePriceOracle.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (SimplePriceOracle.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (SimplePriceOracle.sol#1853-1854)\n\t- accountBorrows (SimplePriceOracle.sol#1854-1855)\n\t- totalBorrows (SimplePriceOracle.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (SimplePriceOracle.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (SimplePriceOracle.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (SimplePriceOracle.sol#1070)\n\t- borrowIndex (SimplePriceOracle.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (SimplePriceOracle.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (SimplePriceOracle.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (SimplePriceOracle.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (SimplePriceOracle.sol#1079)\n\t- name (SimplePriceOracle.sol#1077)\n\t- symbol (SimplePriceOracle.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (SimplePriceOracle.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (SimplePriceOracle.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (SimplePriceOracle.sol#1611-1613)\n\t- totalSupply (SimplePriceOracle.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (SimplePriceOracle.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (SimplePriceOracle.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (SimplePriceOracle.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (SimplePriceOracle.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (SimplePriceOracle.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (SimplePriceOracle.sol#1980-1981)\n\t- accountBorrows (SimplePriceOracle.sol#1981-1982)\n\t- totalBorrows (SimplePriceOracle.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (SimplePriceOracle.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (SimplePriceOracle.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (SimplePriceOracle.sol#2134-2135)\n\t- accountTokens (SimplePriceOracle.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (SimplePriceOracle.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (SimplePriceOracle.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (SimplePriceOracle.sol#1136)\n\t- accountTokens (SimplePriceOracle.sol#1137)\n\t- transferAllowances (SimplePriceOracle.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2592,
                    "vulnerability_to_line": 2621,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (SimplePriceOracle.sol#2592-2621)\n\t- SimplePriceOracle.sol#2600-2613\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2629,
                    "vulnerability_to_line": 2658,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n}\n\n\n",
                    "message": "CErc20.doTransferOut uses assembly (SimplePriceOracle.sol#2629-2658)\n\t- SimplePriceOracle.sol#2637-2650\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (SimplePriceOracle.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2667,
                    "vulnerability_to_line": 2671,
                    "vulnerability_code": "    function getUnderlyingPrice(CToken cToken) public view returns (uint) {\n\n        return prices[address(CErc20(address(cToken)).underlying())];\n\n    }\n\n\n",
                    "message": "SimplePriceOracle.getUnderlyingPrice (SimplePriceOracle.sol#2667-2671) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": 2442,
                    "vulnerability_code": "    function getUnderlyingPrice(CToken cToken) external view returns (uint);\n\n}\n\n\n",
                    "message": "PriceOracle.getUnderlyingPrice (SimplePriceOracle.sol#2439-2442) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2671,
                    "vulnerability_to_line": 2675,
                    "vulnerability_code": "    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\n\n        prices[address(CErc20(address(cToken)).underlying())] = underlyingPriceMantissa;\n\n    }\n\n\n",
                    "message": "SimplePriceOracle.setUnderlyingPrice (SimplePriceOracle.sol#2671-2675) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in SimplePriceOracle.sol:\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#2425-2427): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#2444-2447): it allows old versions\n\t- pragma solidity^0.5.8 (SimplePriceOracle.sol#2660-2663): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (SimplePriceOracle.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (SimplePriceOracle.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (SimplePriceOracle.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (SimplePriceOracle.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (SimplePriceOracle.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (SimplePriceOracle.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (SimplePriceOracle.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (SimplePriceOracle.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (SimplePriceOracle.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (SimplePriceOracle.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (SimplePriceOracle.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (SimplePriceOracle.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (SimplePriceOracle.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (SimplePriceOracle.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (SimplePriceOracle.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2665,
                    "vulnerability_to_line": 2667,
                    "vulnerability_code": "    bool public constant isPriceOracle = true;\n\n\n",
                    "message": "Constant 'SimplePriceOracle.isPriceOracle' (SimplePriceOracle.sol#2665-2667) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2637,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint) prices;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/contracts/FaucetToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        totalSupply_ = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        balances[msg.sender] = _initialAmount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _tokenName;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _tokenSymbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        decimals = _decimalUnits;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return totalSupply_;\n",
                    "message": "BasicToken.totalSupply (FaucetToken.sol#99-101) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256);\n",
                    "message": "ERC20Basic.totalSupply (FaucetToken.sol#14) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": 125,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n\n        return balances[_owner];\n",
                    "message": "BasicToken.balanceOf (FaucetToken.sol#123-125) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address who) public view returns (uint256);\n",
                    "message": "ERC20Basic.balanceOf (FaucetToken.sol#16) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 116,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n\n        require(_value <= balances[msg.sender]);\n\n\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "BasicToken.transfer (FaucetToken.sol#108-116) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20Basic.transfer (FaucetToken.sol#18) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function allowance(\n\n        address _owner,\n\n        address _spender\n\n    )\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "StandardToken.allowance (FaucetToken.sol#213-222) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256);\n",
                    "message": "ERC20.allowance (FaucetToken.sol#139) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": 190,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _value\n\n    )\n\n    public\n\n    returns (bool)\n\n    {\n\n        require(_to != address(0));\n\n        require(_value <= balances[_from]);\n\n        require(_value <= allowed[_from][msg.sender]);\n\n\n\n        balances[_from] = balances[_from].sub(_value);\n\n        balances[_to] = balances[_to].add(_value);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "StandardToken.transferFrom (FaucetToken.sol#173-190) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool);\n",
                    "message": "ERC20.transferFrom (FaucetToken.sol#141) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool);\n",
                    "message": "ERC20.approve (FaucetToken.sol#143) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": 205,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n\n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "StandardToken.approve (FaucetToken.sol#201-205) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function increaseApproval(\n\n        address _spender,\n\n        uint256 _addedValue\n\n    )\n\n    public\n\n    returns (bool)\n\n    {\n\n        allowed[msg.sender][_spender] = (\n\n        allowed[msg.sender][_spender].add(_addedValue));\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.increaseApproval (FaucetToken.sol#233-244) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function decreaseApproval(\n\n        address _spender,\n\n        uint256 _subtractedValue\n\n    )\n\n    public\n\n    returns (bool)\n\n    {\n\n        uint256 oldValue = allowed[msg.sender][_spender];\n\n        if (_subtractedValue > oldValue) {\n\n            allowed[msg.sender][_spender] = 0;\n\n        } else {\n\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n        return true;\n",
                    "message": "StandardToken.decreaseApproval (FaucetToken.sol#255-270) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": 304,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n\n        balances[_owner] += value;\n\n        totalSupply_ += value;\n\n        emit Transfer(address(this), _owner, value);\n",
                    "message": "FaucetToken.allocateTo (FaucetToken.sol#300-304) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in FaucetToken.sol:\n\t- pragma solidity^0.5.8 (FaucetToken.sol#5): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#25): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#80): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#131): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#150): it allows old versions\n\t- pragma solidity^0.5.8 (FaucetToken.sol#276): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint256) {\n",
                    "message": "Parameter '_owner' of BasicToken.balanceOf (FaucetToken.sol#123) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_to' of BasicToken.transfer (FaucetToken.sol#108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of BasicToken.transfer (FaucetToken.sol#108) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _owner,\n",
                    "message": "Parameter '_owner' of StandardToken.allowance (FaucetToken.sol#214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender\n",
                    "message": "Parameter '_spender' of StandardToken.allowance (FaucetToken.sol#215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of StandardToken.transferFrom (FaucetToken.sol#174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of StandardToken.transferFrom (FaucetToken.sol#175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of StandardToken.transferFrom (FaucetToken.sol#176) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_spender' of StandardToken.approve (FaucetToken.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": "Parameter '_value' of StandardToken.approve (FaucetToken.sol#201) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.increaseApproval (FaucetToken.sol#234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _addedValue\n",
                    "message": "Parameter '_addedValue' of StandardToken.increaseApproval (FaucetToken.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _spender,\n",
                    "message": "Parameter '_spender' of StandardToken.decreaseApproval (FaucetToken.sol#256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _subtractedValue\n",
                    "message": "Parameter '_subtractedValue' of StandardToken.decreaseApproval (FaucetToken.sol#257) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_initialAmount' of FaucetToken. (FaucetToken.sol#289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenName' of FaucetToken. (FaucetToken.sol#289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_decimalUnits' of FaucetToken. (FaucetToken.sol#289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n",
                    "message": "Parameter '_tokenSymbol' of FaucetToken. (FaucetToken.sol#289) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allocateTo(address _owner, uint256 value) public {\n",
                    "message": "Parameter '_owner' of FaucetToken.allocateTo (FaucetToken.sol#300) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 totalSupply_;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/ComptrollerModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_56"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2428,
                    "vulnerability_to_line": 2429,
                    "vulnerability_code": "    uint mintAllowedResult;\n",
                    "message": "ComptrollerModel.mintAllowedResult (ComptrollerModel.sol#2428-2429) is never initialized. It is used in:\n\t- mintAllowed (ComptrollerModel.sol#2439-2443)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2429,
                    "vulnerability_to_line": 2430,
                    "vulnerability_code": "    uint redeemAllowedResult;\n",
                    "message": "ComptrollerModel.redeemAllowedResult (ComptrollerModel.sol#2429-2430) is never initialized. It is used in:\n\t- redeemAllowed (ComptrollerModel.sol#2446-2450)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2430,
                    "vulnerability_to_line": 2431,
                    "vulnerability_code": "    uint borrowAllowedResult;\n",
                    "message": "ComptrollerModel.borrowAllowedResult (ComptrollerModel.sol#2430-2431) is never initialized. It is used in:\n\t- borrowAllowed (ComptrollerModel.sol#2453-2457)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2431,
                    "vulnerability_to_line": 2432,
                    "vulnerability_code": "    uint repayBorrowAllowedResult;\n",
                    "message": "ComptrollerModel.repayBorrowAllowedResult (ComptrollerModel.sol#2431-2432) is never initialized. It is used in:\n\t- repayBorrowAllowed (ComptrollerModel.sol#2460-2468)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2432,
                    "vulnerability_to_line": 2433,
                    "vulnerability_code": "    uint liquidateBorrowAllowedResult;\n",
                    "message": "ComptrollerModel.liquidateBorrowAllowedResult (ComptrollerModel.sol#2432-2433) is never initialized. It is used in:\n\t- liquidateBorrowAllowed (ComptrollerModel.sol#2476-2485)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2433,
                    "vulnerability_to_line": 2434,
                    "vulnerability_code": "    uint seizeAllowedResult;\n",
                    "message": "ComptrollerModel.seizeAllowedResult (ComptrollerModel.sol#2433-2434) is never initialized. It is used in:\n\t- seizeAllowed (ComptrollerModel.sol#2494-2503)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2434,
                    "vulnerability_to_line": 2435,
                    "vulnerability_code": "    uint transferAllowedResult;\n",
                    "message": "ComptrollerModel.transferAllowedResult (ComptrollerModel.sol#2434-2435) is never initialized. It is used in:\n\t- transferAllowed (ComptrollerModel.sol#2510-2514)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2435,
                    "vulnerability_to_line": 2436,
                    "vulnerability_code": "    uint liquidateCalculateSeizeTokensResult1;\n",
                    "message": "ComptrollerModel.liquidateCalculateSeizeTokensResult1 (ComptrollerModel.sol#2435-2436) is never initialized. It is used in:\n\t- liquidateCalculateSeizeTokens (ComptrollerModel.sol#2516-2522)\n"
                },
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2436,
                    "vulnerability_to_line": 2439,
                    "vulnerability_code": "    uint liquidateCalculateSeizeTokensResult2;\n\n\n\n\n",
                    "message": "ComptrollerModel.liquidateCalculateSeizeTokensResult2 (ComptrollerModel.sol#2436-2439) is never initialized. It is used in:\n\t- liquidateCalculateSeizeTokens (ComptrollerModel.sol#2516-2522)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (ComptrollerModel.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (ComptrollerModel.sol#745)\n\t-transferFrom (ComptrollerModel.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (ComptrollerModel.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (ComptrollerModel.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (ComptrollerModel.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (ComptrollerModel.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (ComptrollerModel.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (ComptrollerModel.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (ComptrollerModel.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerModel.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (ComptrollerModel.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (ComptrollerModel.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (ComptrollerModel.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (ComptrollerModel.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (ComptrollerModel.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerModel.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerModel.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerModel.sol#1503-1504)\n\t- totalReserves (ComptrollerModel.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (ComptrollerModel.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (ComptrollerModel.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerModel.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (ComptrollerModel.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (ComptrollerModel.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (ComptrollerModel.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerModel.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerModel.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerModel.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (ComptrollerModel.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (ComptrollerModel.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (ComptrollerModel.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerModel.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (ComptrollerModel.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (ComptrollerModel.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (ComptrollerModel.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (ComptrollerModel.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (ComptrollerModel.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (ComptrollerModel.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (ComptrollerModel.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (ComptrollerModel.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (ComptrollerModel.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (ComptrollerModel.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (ComptrollerModel.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerModel.sol#1501-1502)\n\t- borrowIndex (ComptrollerModel.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (ComptrollerModel.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (ComptrollerModel.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerModel.sol#1853-1854)\n\t- accountBorrows (ComptrollerModel.sol#1854-1855)\n\t- totalBorrows (ComptrollerModel.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerModel.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerModel.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (ComptrollerModel.sol#1070)\n\t- borrowIndex (ComptrollerModel.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (ComptrollerModel.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (ComptrollerModel.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (ComptrollerModel.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (ComptrollerModel.sol#1079)\n\t- name (ComptrollerModel.sol#1077)\n\t- symbol (ComptrollerModel.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (ComptrollerModel.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (ComptrollerModel.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerModel.sol#1611-1613)\n\t- totalSupply (ComptrollerModel.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (ComptrollerModel.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (ComptrollerModel.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerModel.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (ComptrollerModel.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (ComptrollerModel.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (ComptrollerModel.sol#1980-1981)\n\t- accountBorrows (ComptrollerModel.sol#1981-1982)\n\t- totalBorrows (ComptrollerModel.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (ComptrollerModel.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (ComptrollerModel.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerModel.sol#2134-2135)\n\t- accountTokens (ComptrollerModel.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (ComptrollerModel.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (ComptrollerModel.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (ComptrollerModel.sol#1136)\n\t- accountTokens (ComptrollerModel.sol#1137)\n\t- transferAllowances (ComptrollerModel.sol#1141)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2430,
                    "vulnerability_to_line": 2431,
                    "vulnerability_code": "    uint borrowAllowedResult;\n",
                    "message": "ComptrollerModel.borrowAllowedResult should be constant (ComptrollerModel.sol#2430-2431)\nComptrollerModel.liquidateBorrowAllowedResult should be constant (ComptrollerModel.sol#2432-2433)\nComptrollerModel.liquidateCalculateSeizeTokensResult1 should be constant (ComptrollerModel.sol#2435-2436)\nComptrollerModel.liquidateCalculateSeizeTokensResult2 should be constant (ComptrollerModel.sol#2436-2439)\nComptrollerModel.mintAllowedResult should be constant (ComptrollerModel.sol#2428-2429)\nComptrollerModel.redeemAllowedResult should be constant (ComptrollerModel.sol#2429-2430)\nComptrollerModel.repayBorrowAllowedResult should be constant (ComptrollerModel.sol#2431-2432)\nComptrollerModel.seizeAllowedResult should be constant (ComptrollerModel.sol#2433-2434)\nComptrollerModel.transferAllowedResult should be constant (ComptrollerModel.sol#2434-2435)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (ComptrollerModel.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2439,
                    "vulnerability_to_line": 2443,
                    "vulnerability_code": "    function mintAllowed(CToken cToken, address minter, uint mintAmount) public returns (uint) {\n\n        return mintAllowedResult;\n\n    }\n\n\n",
                    "message": "ComptrollerModel.mintAllowed (ComptrollerModel.sol#2439-2443) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2446,
                    "vulnerability_to_line": 2450,
                    "vulnerability_code": "    function redeemAllowed(CToken cToken, address redeemer, uint redeemTokens) public returns (uint) {\n\n        return redeemAllowedResult;\n\n    }\n\n\n",
                    "message": "ComptrollerModel.redeemAllowed (ComptrollerModel.sol#2446-2450) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2453,
                    "vulnerability_to_line": 2457,
                    "vulnerability_code": "    function borrowAllowed(CToken cToken, address borrower, uint borrowAmount) public returns (uint) {\n\n        return borrowAllowedResult;\n\n    }\n\n\n",
                    "message": "ComptrollerModel.borrowAllowed (ComptrollerModel.sol#2453-2457) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in ComptrollerModel.sol:\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (ComptrollerModel.sol#2425-2427): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (ComptrollerModel.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (ComptrollerModel.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (ComptrollerModel.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (ComptrollerModel.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (ComptrollerModel.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (ComptrollerModel.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (ComptrollerModel.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (ComptrollerModel.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (ComptrollerModel.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (ComptrollerModel.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (ComptrollerModel.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (ComptrollerModel.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (ComptrollerModel.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (ComptrollerModel.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (ComptrollerModel.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint mintAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint redeemAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint borrowAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint repayBorrowAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint liquidateBorrowAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint seizeAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint transferAllowedResult;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint liquidateCalculateSeizeTokensResult1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint liquidateCalculateSeizeTokensResult2;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/CEtherCertora.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public CEther(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2603,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_44"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CEtherCertora.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (CEtherCertora.sol#745)\n\t-transferFrom (CEtherCertora.sol#759)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 2531,
                    "vulnerability_to_line": 2538,
                    "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n\n    /**\n",
                    "message": "CEther.getCashPrior (CEtherCertora.sol#2531-2538) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CEtherCertora.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (CEtherCertora.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CEtherCertora.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CEtherCertora.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (CEtherCertora.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CEtherCertora.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CEtherCertora.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (CEtherCertora.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CEtherCertora.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CEtherCertora.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (CEtherCertora.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CEtherCertora.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CEtherCertora.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CEtherCertora.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CEtherCertora.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (CEtherCertora.sol#1503-1504)\n\t- totalReserves (CEtherCertora.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CEtherCertora.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (CEtherCertora.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (CEtherCertora.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CEtherCertora.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (CEtherCertora.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CEtherCertora.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (CEtherCertora.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CEtherCertora.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CEtherCertora.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (CEtherCertora.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CEtherCertora.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CEtherCertora.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (CEtherCertora.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CEtherCertora.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (CEtherCertora.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CEtherCertora.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (CEtherCertora.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CEtherCertora.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CEtherCertora.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CEtherCertora.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CEtherCertora.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CEtherCertora.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CEtherCertora.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CEtherCertora.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CEtherCertora.sol#1501-1502)\n\t- borrowIndex (CEtherCertora.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CEtherCertora.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CEtherCertora.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (CEtherCertora.sol#1853-1854)\n\t- accountBorrows (CEtherCertora.sol#1854-1855)\n\t- totalBorrows (CEtherCertora.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CEtherCertora.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CEtherCertora.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CEtherCertora.sol#1070)\n\t- borrowIndex (CEtherCertora.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CEtherCertora.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CEtherCertora.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CEtherCertora.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (CEtherCertora.sol#1079)\n\t- name (CEtherCertora.sol#1077)\n\t- symbol (CEtherCertora.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CEtherCertora.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CEtherCertora.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (CEtherCertora.sol#1611-1613)\n\t- totalSupply (CEtherCertora.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CEtherCertora.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CEtherCertora.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (CEtherCertora.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CEtherCertora.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CEtherCertora.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (CEtherCertora.sol#1980-1981)\n\t- accountBorrows (CEtherCertora.sol#1981-1982)\n\t- totalBorrows (CEtherCertora.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CEtherCertora.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CEtherCertora.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (CEtherCertora.sol#2134-2135)\n\t- accountTokens (CEtherCertora.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CEtherCertora.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CEtherCertora.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (CEtherCertora.sol#1136)\n\t- accountTokens (CEtherCertora.sol#1137)\n\t- transferAllowances (CEtherCertora.sol#1141)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CEtherCertora.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CEtherCertora.sol:\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#2425-2428): it allows old versions\n\t- pragma solidity^0.5.8 (CEtherCertora.sol#2594-2596): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CEtherCertora.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CEtherCertora.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CEtherCertora.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CEtherCertora.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CEtherCertora.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CEtherCertora.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CEtherCertora.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CEtherCertora.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CEtherCertora.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CEtherCertora.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CEtherCertora.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CEtherCertora.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CEtherCertora.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CEtherCertora.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CEtherCertora.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CEther is CToken {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        to.transfer(amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return Error.NO_ERROR;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/CTokenCollateral.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public CErc20(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_47"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CTokenCollateral.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (CTokenCollateral.sol#745)\n\t-transferFrom (CTokenCollateral.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CTokenCollateral.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (CTokenCollateral.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CTokenCollateral.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CTokenCollateral.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (CTokenCollateral.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CTokenCollateral.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CTokenCollateral.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (CTokenCollateral.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CTokenCollateral.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CTokenCollateral.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (CTokenCollateral.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CTokenCollateral.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CTokenCollateral.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CTokenCollateral.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CTokenCollateral.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (CTokenCollateral.sol#1503-1504)\n\t- totalReserves (CTokenCollateral.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CTokenCollateral.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (CTokenCollateral.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (CTokenCollateral.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CTokenCollateral.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (CTokenCollateral.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CTokenCollateral.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (CTokenCollateral.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CTokenCollateral.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CTokenCollateral.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (CTokenCollateral.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CTokenCollateral.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CTokenCollateral.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (CTokenCollateral.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CTokenCollateral.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (CTokenCollateral.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CTokenCollateral.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (CTokenCollateral.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CTokenCollateral.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CTokenCollateral.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CTokenCollateral.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CTokenCollateral.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CTokenCollateral.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": 2462,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (CTokenCollateral.sol#2449-2462) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (CTokenCollateral.sol#2459)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CTokenCollateral.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CTokenCollateral.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CTokenCollateral.sol#1501-1502)\n\t- borrowIndex (CTokenCollateral.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CTokenCollateral.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CTokenCollateral.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (CTokenCollateral.sol#1853-1854)\n\t- accountBorrows (CTokenCollateral.sol#1854-1855)\n\t- totalBorrows (CTokenCollateral.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CTokenCollateral.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CTokenCollateral.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CTokenCollateral.sol#1070)\n\t- borrowIndex (CTokenCollateral.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CTokenCollateral.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CTokenCollateral.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CTokenCollateral.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (CTokenCollateral.sol#1079)\n\t- name (CTokenCollateral.sol#1077)\n\t- symbol (CTokenCollateral.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CTokenCollateral.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CTokenCollateral.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (CTokenCollateral.sol#1611-1613)\n\t- totalSupply (CTokenCollateral.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CTokenCollateral.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CTokenCollateral.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (CTokenCollateral.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CTokenCollateral.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CTokenCollateral.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (CTokenCollateral.sol#1980-1981)\n\t- accountBorrows (CTokenCollateral.sol#1981-1982)\n\t- totalBorrows (CTokenCollateral.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CTokenCollateral.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CTokenCollateral.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (CTokenCollateral.sol#2134-2135)\n\t- accountTokens (CTokenCollateral.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CTokenCollateral.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CTokenCollateral.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (CTokenCollateral.sol#1136)\n\t- accountTokens (CTokenCollateral.sol#1137)\n\t- transferAllowances (CTokenCollateral.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2573,
                    "vulnerability_to_line": 2602,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (CTokenCollateral.sol#2573-2602)\n\t- CTokenCollateral.sol#2581-2594\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": 2639,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n}\n\n\n",
                    "message": "CErc20.doTransferOut uses assembly (CTokenCollateral.sol#2610-2639)\n\t- CTokenCollateral.sol#2618-2631\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CTokenCollateral.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2654,
                    "vulnerability_to_line": 2657,
                    "vulnerability_code": "    function getCashOf(address account) public view returns (uint) {\n\n        return EIP20Interface(underlying).balanceOf(account);\n\n    }\n",
                    "message": "CTokenCollateral.getCashOf (CTokenCollateral.sol#2654-2657) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CTokenCollateral.sol:\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#2425-2428): it allows old versions\n\t- pragma solidity^0.5.8 (CTokenCollateral.sol#2641-2644): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CTokenCollateral.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CTokenCollateral.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CTokenCollateral.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CTokenCollateral.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CTokenCollateral.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CTokenCollateral.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CTokenCollateral.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CTokenCollateral.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CTokenCollateral.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CTokenCollateral.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CTokenCollateral.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CTokenCollateral.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CTokenCollateral.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CTokenCollateral.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CTokenCollateral.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/UnderlyingModelNonStandard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _totalSupply;\n",
                    "message": "UnderlyingModelNonStandard._totalSupply (UnderlyingModelNonStandard.sol#87) is never initialized. It is used in:\n\t- totalSupply (UnderlyingModelNonStandard.sol#91-93)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (UnderlyingModelNonStandard.sol#10-72) has incorrect ERC20 function interface(s):\n\t-transfer (UnderlyingModelNonStandard.sol#36)\n\t-transferFrom (UnderlyingModelNonStandard.sol#50)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": 134,
                    "vulnerability_code": "contract UnderlyingModelNonStandard is EIP20NonStandardInterface, SimulationInterface {\n\n    uint256 _totalSupply;\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowances;\n\n\n\n    function totalSupply() external view returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance) {\n\n        balance = balances[owner];\n\n    }\n\n\n\n    function transfer(address dst, uint256 amount) external {\n\n        address src = msg.sender;\n\n        require (balances[src]>=amount);\n\n        require (balances[dst]+amount>=balances[dst]);\n\n\n\n        balances[src] -= amount;\n\n        balances[dst] += amount;\n\n    }\n\n\n\n    function transferFrom(address src, address dst, uint256 amount) external {\n\n        require (allowances[src][msg.sender] >= amount);\n\n        require (balances[src]>=amount);\n\n        require (balances[dst]+amount>=balances[dst]);\n\n\n\n        allowances[src][msg.sender] -= amount;\n\n        balances[src] -= amount;\n\n        balances[dst] += amount;\n\n    }\n\n\n\n    function approve(address spender, uint256 amount) external returns (bool success) {\n\n        allowances[msg.sender][spender] = amount;\n\n    }\n\n\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining) {\n\n        remaining = allowances[owner][spender];\n\n    }\n\n\n\n    function dummy() external {\n\n        return;\n\n    }\n",
                    "message": "UnderlyingModelNonStandard (UnderlyingModelNonStandard.sol#86-134) has incorrect ERC20 function interface(s):\n\t-transfer (UnderlyingModelNonStandard.sol#104-111)\n\t-transferFrom (UnderlyingModelNonStandard.sol#113-121)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _totalSupply;\n",
                    "message": "UnderlyingModelNonStandard._totalSupply should be constant (UnderlyingModelNonStandard.sol#87)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in UnderlyingModelNonStandard.sol:\n\t- pragma solidity^0.5.8 (UnderlyingModelNonStandard.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (UnderlyingModelNonStandard.sol#76): it allows old versions\n\t- pragma solidity^0.5.8 (UnderlyingModelNonStandard.sol#84): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _totalSupply;\n",
                    "message": "Variable 'UnderlyingModelNonStandard._totalSupply' (UnderlyingModelNonStandard.sol#87) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool success) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 _totalSupply;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) allowances;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/SimulationInterface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in SimulationInterface.sol:\n\t- pragma solidity^0.5.8 (SimulationInterface.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/MaximillionCertora.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(CEther cEther_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        cEther = cEther_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(CEther cEther_) public Maximillion(cEther_) {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == from, \"sender mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == amount, \"value mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < bytes(message).length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_45"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 2630,
                    "vulnerability_to_line": 2642,
                    "vulnerability_code": "    function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\n\n        uint received = msg.value;\n\n        uint borrows = cEther_.borrowBalanceCurrent(borrower);\n\n        if (received > borrows) {\n\n            cEther_.repayBorrowBehalf.value(borrows)(borrower);\n\n            msg.sender.transfer(received - borrows);\n\n        } else {\n\n            cEther_.repayBorrowBehalf.value(received)(borrower);\n\n        }\n\n    }\n\n}\n\n\n",
                    "message": "Maximillion.repayBehalfExplicit (MaximillionCertora.sol#2630-2642) sends eth to arbitrary user\n\tDangerous calls:\n\t- cEther_.repayBorrowBehalf.value(borrows)(borrower) (MaximillionCertora.sol#2634-2635)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (MaximillionCertora.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (MaximillionCertora.sol#745)\n\t-transferFrom (MaximillionCertora.sol#759)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 2531,
                    "vulnerability_to_line": 2538,
                    "vulnerability_code": "    function getCashPrior() internal view returns (uint) {\n\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n\n        require(err == MathError.NO_ERROR);\n\n        return startingBalance;\n\n    }\n\n\n\n    /**\n",
                    "message": "CEther.getCashPrior (MaximillionCertora.sol#2531-2538) uses a dangerous strict equality:\n\t- require(bool)(err == MathError.NO_ERROR)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (MaximillionCertora.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (MaximillionCertora.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (MaximillionCertora.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (MaximillionCertora.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (MaximillionCertora.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (MaximillionCertora.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (MaximillionCertora.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (MaximillionCertora.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (MaximillionCertora.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (MaximillionCertora.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (MaximillionCertora.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (MaximillionCertora.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (MaximillionCertora.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (MaximillionCertora.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (MaximillionCertora.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (MaximillionCertora.sol#1503-1504)\n\t- totalReserves (MaximillionCertora.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (MaximillionCertora.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (MaximillionCertora.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (MaximillionCertora.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (MaximillionCertora.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (MaximillionCertora.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (MaximillionCertora.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (MaximillionCertora.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (MaximillionCertora.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (MaximillionCertora.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (MaximillionCertora.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (MaximillionCertora.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (MaximillionCertora.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (MaximillionCertora.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (MaximillionCertora.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (MaximillionCertora.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (MaximillionCertora.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (MaximillionCertora.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (MaximillionCertora.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (MaximillionCertora.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (MaximillionCertora.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (MaximillionCertora.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (MaximillionCertora.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (MaximillionCertora.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (MaximillionCertora.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (MaximillionCertora.sol#1501-1502)\n\t- borrowIndex (MaximillionCertora.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (MaximillionCertora.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (MaximillionCertora.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (MaximillionCertora.sol#1853-1854)\n\t- accountBorrows (MaximillionCertora.sol#1854-1855)\n\t- totalBorrows (MaximillionCertora.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (MaximillionCertora.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (MaximillionCertora.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (MaximillionCertora.sol#1070)\n\t- borrowIndex (MaximillionCertora.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (MaximillionCertora.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (MaximillionCertora.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (MaximillionCertora.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (MaximillionCertora.sol#1079)\n\t- name (MaximillionCertora.sol#1077)\n\t- symbol (MaximillionCertora.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (MaximillionCertora.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (MaximillionCertora.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (MaximillionCertora.sol#1611-1613)\n\t- totalSupply (MaximillionCertora.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (MaximillionCertora.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (MaximillionCertora.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (MaximillionCertora.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (MaximillionCertora.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (MaximillionCertora.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (MaximillionCertora.sol#1980-1981)\n\t- accountBorrows (MaximillionCertora.sol#1981-1982)\n\t- totalBorrows (MaximillionCertora.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (MaximillionCertora.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (MaximillionCertora.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (MaximillionCertora.sol#2134-2135)\n\t- accountTokens (MaximillionCertora.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (MaximillionCertora.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (MaximillionCertora.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (MaximillionCertora.sol#1136)\n\t- accountTokens (MaximillionCertora.sol#1137)\n\t- transferAllowances (MaximillionCertora.sol#1141)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (MaximillionCertora.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in MaximillionCertora.sol:\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#2425-2428): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#2594-2597): it allows old versions\n\t- pragma solidity^0.5.8 (MaximillionCertora.sol#2644-2646): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (MaximillionCertora.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (MaximillionCertora.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (MaximillionCertora.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (MaximillionCertora.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (MaximillionCertora.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (MaximillionCertora.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (MaximillionCertora.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (MaximillionCertora.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (MaximillionCertora.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (MaximillionCertora.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (MaximillionCertora.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (MaximillionCertora.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (MaximillionCertora.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (MaximillionCertora.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (MaximillionCertora.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CEther is CToken {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MaximillionCertora is Maximillion {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        to.transfer(amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return Error.NO_ERROR;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-protocol/spec/formal/contracts/CErc20Certora.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // value, which is a more expensive operation.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _guardCounter = 1;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 801,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1053,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1054,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1056,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set admin to msg.sender\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1060,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1061,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set initial exchange rate\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Set underlying\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = underlying_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public CErc20(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address underlying_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2677,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ComptrollerInterface comptroller_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2678,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                InterestRateModel interestRateModel_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint initialExchangeRateMantissa_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory name_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                string memory symbol_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2682,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint decimals_) public CErc20(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 814,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(localCounter == _guardCounter, \"re-entered\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2078,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newComptroller.isComptroller(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 2382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1063,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(opaqueErr == 0, \"borrowRatePerBlock: interestRateModel.borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e0 == 0, \"supplyRatePerBlock: calculating borrowRate failed\"); // semi-opaque\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e1 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating underlying failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e2 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating borrowsPer failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e3 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating oneMinusReserveFactor failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(e4 == MathError.NO_ERROR, \"supplyRatePerBlock: calculating supplyRate failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 2333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "compound-borrowfresh-reentrancy",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vars.err = doTransferOut(borrower, borrowAmount);\n",
                    "message": "Function borrowFresh() in Compound performs state update after doTransferOut()"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_74"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 2674,
                    "vulnerability_to_line": 2676,
                    "vulnerability_code": "    CTokenCollateral public otherToken;\n\n\n",
                    "message": "CErc20Certora.otherToken (CErc20Certora.sol#2674-2676) is never initialized. It is used in:\n\t- balanceOfInOther (CErc20Certora.sol#2773-2777)\n\t- borrowBalanceStoredInOther (CErc20Certora.sol#2777-2781)\n\t- exchangeRateStoredInOther (CErc20Certora.sol#2781-2785)\n\t- getCashInOther (CErc20Certora.sol#2785-2789)\n\t- getCashOfInOther (CErc20Certora.sol#2793-2797)\n\t- totalSupplyInOther (CErc20Certora.sol#2797-2801)\n\t- totalBorrowsInOther (CErc20Certora.sol#2801-2805)\n\t- totalReservesInOther (CErc20Certora.sol#2805-2809)\n\t- liquidateBorrowFreshPub (CErc20Certora.sol#2825-2828)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 719,
                    "vulnerability_to_line": 781,
                    "vulnerability_code": "interface EIP20NonStandardInterface {\n\n\n\n    /**\n\n     * @notice Get the total number of tokens in circulation\n\n     * @return The supply of tokens\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @notice Gets the balance of the specified address\n\n     * @param owner The address from which the balance will be retrieved\n\n     * @return The balance\n\n     */\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transfer(address dst, uint256 amount) external;\n\n\n\n    ///\n\n    /// !!!!!!!!!!!!!!\n\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n\n    /// !!!!!!!!!!!!!!\n\n    ///\n\n\n\n    /**\n\n      * @notice Transfer `amount` tokens from `src` to `dst`\n\n      * @param src The address of the source account\n\n      * @param dst The address of the destination account\n\n      * @param amount The number of tokens to transfer\n\n      */\n\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n\n\n    /**\n\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n\n      * @dev This will overwrite the approval amount for `spender`\n\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @param amount The number of tokens that are approved\n\n      * @return Whether or not the approval succeeded\n\n      */\n\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n\n\n    /**\n\n      * @notice Get the current allowance from `owner` for `spender`\n\n      * @param owner The address of the account which owns the tokens to be spent\n\n      * @param spender The address of the account which may transfer tokens\n\n      * @return The number of tokens allowed to be spent\n\n      */\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n",
                    "message": "EIP20NonStandardInterface (CErc20Certora.sol#719-781) has incorrect ERC20 function interface(s):\n\t-transfer (CErc20Certora.sol#745)\n\t-transferFrom (CErc20Certora.sol#759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._reduceReserves (CErc20Certora.sol#2276-2286):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#2277-2278)\n\tState variables written after the call(s):\n\t- totalReserves (CErc20Certora.sol#2283-2286)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setComptroller (CErc20Certora.sol#2207-2226):\n\tExternal calls:\n\t- require(bool,string)(newComptroller.isComptroller(),marker method returned false) (CErc20Certora.sol#2215-2217)\n\tState variables written after the call(s):\n\t- comptroller (CErc20Certora.sol#2218-2220)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Reentrancy in CToken._setInterestRateModel (CErc20Certora.sol#2346-2357):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#2347-2348)\n\t- _setInterestRateModelFresh(newInterestRateModel) (CErc20Certora.sol#2353-2356)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20Certora.sol#2353-2356)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setInterestRateModelFresh (CErc20Certora.sol#2362-2393):\n\tExternal calls:\n\t- require(bool,string)(newInterestRateModel.isInterestRateModel(),marker method returned false) (CErc20Certora.sol#2382-2384)\n\tState variables written after the call(s):\n\t- interestRateModel (CErc20Certora.sol#2385-2387)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken._setReserveFactor (CErc20Certora.sol#2231-2241):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#2232-2233)\n\tState variables written after the call(s):\n\t- reserveFactorMantissa (CErc20Certora.sol#2238-2239)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20Certora.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20Certora.sol#1450-1451)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20Certora.sol#1503-1504)\n\t- totalReserves (CErc20Certora.sol#1504-1506)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1776,
                    "vulnerability_to_line": 1786,
                    "vulnerability_code": "    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return borrowFresh(msg.sender, borrowAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowInternal (CErc20Certora.sol#1776-1786):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#1777-1778)\n\t- borrowFresh(msg.sender,borrowAmount) (CErc20Certora.sol#1783-1784)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20Certora.sol#1783-1784)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2001,
                    "vulnerability_to_line": 2018,
                    "vulnerability_code": "    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n\n        }\n\n\n\n        error = cTokenCollateral.accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n\n        }\n\n\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.liquidateBorrowInternal (CErc20Certora.sol#2001-2018):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#2002-2003)\n\t- error = cTokenCollateral.accrueInterest() (CErc20Certora.sol#2008-2009)\n\t- liquidateBorrowFresh(msg.sender,borrower,repayAmount,cTokenCollateral) (CErc20Certora.sol#2015-2016)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20Certora.sol#2015-2016)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20Certora.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20Certora.sol#1713-1714)\n\tState variables written after the call(s):\n\t- totalSupply (CErc20Certora.sol#1758-1759)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": 1897,
                    "vulnerability_code": "    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowBehalfInternal (CErc20Certora.sol#1887-1897):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#1888-1889)\n\t- repayBorrowFresh(msg.sender,borrower,repayAmount) (CErc20Certora.sol#1894-1895)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20Certora.sol#1894-1895)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 1871,
                    "vulnerability_to_line": 1881,
                    "vulnerability_code": "    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowInternal (CErc20Certora.sol#1871-1881):\n\tExternal calls:\n\t- error = accrueInterest() (CErc20Certora.sol#1872-1873)\n\t- repayBorrowFresh(msg.sender,msg.sender,repayAmount) (CErc20Certora.sol#1878-1879)\n\tState variables written after the call(s):\n\t- totalBorrows (CErc20Certora.sol#1878-1879)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1447,
                    "vulnerability_to_line": 1449,
                    "vulnerability_code": "        AccrueInterestLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.accrueInterest (CErc20Certora.sol#1447-1449) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1816,
                    "vulnerability_to_line": 1818,
                    "vulnerability_code": "        BorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.borrowFresh (CErc20Certora.sol#1816-1818) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": 1678,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.redeemFresh (CErc20Certora.sol#1676-1678) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": 1928,
                    "vulnerability_code": "        RepayBorrowLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.repayBorrowFresh (CErc20Certora.sol#1926-1928) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1556,
                    "vulnerability_to_line": 1558,
                    "vulnerability_code": "        MintLocalVars memory vars;\n\n\n",
                    "message": "vars in CToken.mintFresh (CErc20Certora.sol#1556-1558) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": 2462,
                    "vulnerability_code": "    constructor(address underlying_,\n\n                ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) public\n\n    CToken(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_) {\n\n        // Set underlying\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply(); // Sanity check the underlying\n\n    }\n\n\n",
                    "message": "CErc20.constructor (CErc20Certora.sol#2449-2462) does not use the value returned by external calls:\n\t-EIP20Interface(underlying).totalSupply() (CErc20Certora.sol#2459)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 2813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFreshPub(address payable redeemer, uint redeemTokens, uint redeemUnderlying) public returns (uint) {\n",
                    "message": "CErc20Certora.redeemFreshPub.redeemUnderlying (local variable @ CErc20Certora.sol#2813) shadows:\n\t- CErc20.redeemUnderlying (function @ CErc20Certora.sol#2490-2495)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1446,
                    "vulnerability_to_line": 1512,
                    "vulnerability_code": "    function accrueInterest() public returns (uint) {\n\n        AccrueInterestLocalVars memory vars;\n\n\n\n        /* Calculate the current borrow interest rate */\n\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n\n        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        if (vars.opaqueErr != 0) {\n\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n\n        }\n\n\n\n        /* Remember the initial block number */\n\n        vars.currentBlockNumber = getBlockNumber();\n\n\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\n\n\n\n        /*\n\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n\n         *  simpleInterestFactor = borrowRate * blockDelta\n\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n\n         */\n\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accrualBlockNumber = vars.currentBlockNumber;\n\n        borrowIndex = vars.borrowIndexNew;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n        totalReserves = vars.totalReservesNew;\n\n\n\n        /* We emit an AccrueInterest event */\n\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.accrueInterest (CErc20Certora.sol#1446-1512):\n\tExternal calls:\n\t- (vars.opaqueErr,vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(),totalBorrows,totalReserves) (CErc20Certora.sol#1450-1451)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20Certora.sol#1501-1502)\n\t- borrowIndex (CErc20Certora.sol#1502-1503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": 1866,
                    "vulnerability_code": "    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n\n        /* Fail if borrow not allowed */\n\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n\n        if (getCashPrior() < borrowAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        BorrowLocalVars memory vars;\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken borrowAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(borrower, borrowAmount);\n\n        require(vars.err == Error.NO_ERROR, \"borrow transfer out failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a Borrow event */\n\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.borrowFresh (CErc20Certora.sol#1799-1866):\n\tExternal calls:\n\t- allowed = comptroller.borrowAllowed(address(this),borrower,borrowAmount) (CErc20Certora.sol#1801-1802)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20Certora.sol#1853-1854)\n\t- accountBorrows (CErc20Certora.sol#1854-1855)\n\t- totalBorrows (CErc20Certora.sol#1855-1857)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20Certora.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20Certora.sol#1066)\n\tState variables written after the call(s):\n\t- accrualBlockNumber (CErc20Certora.sol#1070)\n\t- borrowIndex (CErc20Certora.sol#1071)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1052,
                    "vulnerability_to_line": 1081,
                    "vulnerability_code": "    constructor(ComptrollerInterface comptroller_,\n\n                InterestRateModel interestRateModel_,\n\n                uint initialExchangeRateMantissa_,\n\n                string memory name_,\n\n                string memory symbol_,\n\n                uint decimals_) internal {\n\n        // Set admin to msg.sender\n\n        admin = msg.sender;\n\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"Initial exchange rate must be greater than zero.\");\n\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting comptroller failed\");\n\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"Setting interest rate model failed\");\n\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n    }\n",
                    "message": "Reentrancy in CToken.constructor (CErc20Certora.sol#1052-1081):\n\tExternal calls:\n\t- err = _setComptroller(comptroller_) (CErc20Certora.sol#1066)\n\t- err = _setInterestRateModelFresh(interestRateModel_) (CErc20Certora.sol#1074)\n\tState variables written after the call(s):\n\t- decimals (CErc20Certora.sol#1079)\n\t- name (CErc20Certora.sol#1077)\n\t- symbol (CErc20Certora.sol#1078)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1544,
                    "vulnerability_to_line": 1623,
                    "vulnerability_code": "    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n\n        /* Fail if mint not allowed */\n\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n\n        }\n\n\n\n        MintLocalVars memory vars;\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n\n         *  mintTokens = mintAmount / exchangeRate\n\n         */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n\n         *  totalSupplyNew = totalSupply + mintTokens\n\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the minter and the mintAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional mintAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(minter, mintAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n\n        }\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[minter] = vars.accountTokensNew;\n\n\n\n        /* We emit a Mint event, and a Transfer event */\n\n        emit Mint(minter, mintAmount, vars.mintTokens);\n\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.mintFresh (CErc20Certora.sol#1544-1623):\n\tExternal calls:\n\t- allowed = comptroller.mintAllowed(address(this),minter,mintAmount) (CErc20Certora.sol#1546-1547)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20Certora.sol#1611-1613)\n\t- totalSupply (CErc20Certora.sol#1610-1611)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": 1771,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n\n\n        RedeemLocalVars memory vars;\n\n\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If redeemTokensIn > 0: */\n\n        if (redeemTokensIn > 0) {\n\n            /*\n\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n\n             *  redeemTokens = redeemTokensIn\n\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n\n             */\n\n            vars.redeemTokens = redeemTokensIn;\n\n\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n        } else {\n\n            /*\n\n             * We get the current exchange rate and calculate the amount to be redeemed:\n\n             *  redeemTokens = redeemAmountIn / exchangeRate\n\n             *  redeemAmount = redeemAmountIn\n\n             */\n\n\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n\n            if (vars.mathErr != MathError.NO_ERROR) {\n\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n\n            }\n\n\n\n            vars.redeemAmount = redeemAmountIn;\n\n        }\n\n\n\n        /* Fail if redeem not allowed */\n\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n\n         *  totalSupplyNew = totalSupply - redeemTokens\n\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n\n         */\n\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* Fail gracefully if protocol has insufficient cash */\n\n        if (getCashPrior() < vars.redeemAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken has redeemAmount less of cash.\n\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n\n        require(vars.err == Error.NO_ERROR, \"redeem transfer out failed\");\n\n\n\n        /* We write previously calculated values into storage */\n\n        totalSupply = vars.totalSupplyNew;\n\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n\n\n        /* We emit a Transfer event, and a Redeem event */\n\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.redeemFresh (CErc20Certora.sol#1673-1771):\n\tExternal calls:\n\t- allowed = comptroller.redeemAllowed(address(this),redeemer,vars.redeemTokens) (CErc20Certora.sol#1713-1714)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20Certora.sol#1759-1761)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": 1993,
                    "vulnerability_code": "    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n\n        /* Fail if repayBorrow not allowed */\n\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Verify market's block number equals current block number */\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n\n        }\n\n\n\n        RepayBorrowLocalVars memory vars;\n\n\n\n        /* We remember the original borrowerIndex for verification purposes */\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n\n        if (repayAmount == uint(-1)) {\n\n            vars.repayAmount = vars.accountBorrows;\n\n        } else {\n\n            vars.repayAmount = repayAmount;\n\n        }\n\n\n\n        /* Fail if checkTransferIn fails */\n\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n\n        if (vars.err != Error.NO_ERROR) {\n\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n\n        }\n\n\n\n        /*\n\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n\n         *  accountBorrowsNew = accountBorrows - repayAmount\n\n         *  totalBorrowsNew = totalBorrows - repayAmount\n\n         */\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n\n        if (vars.mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /*\n\n         * We call doTransferIn for the payer and the repayAmount\n\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n\n         *  On success, the cToken holds an additional repayAmount of cash.\n\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n\n         *   we revert because we can't be sure if side effects occurred.\n\n         */\n\n        vars.err = doTransferIn(payer, vars.repayAmount);\n\n        require(vars.err == Error.NO_ERROR, \"repay borrow transfer in failed\");\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n\n        accountBorrows[borrower].interestIndex = borrowIndex;\n\n        totalBorrows = vars.totalBorrowsNew;\n\n\n\n        /* We emit a RepayBorrow event */\n\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Reentrancy in CToken.repayBorrowFresh (CErc20Certora.sol#1914-1993):\n\tExternal calls:\n\t- allowed = comptroller.repayBorrowAllowed(address(this),payer,borrower,repayAmount) (CErc20Certora.sol#1916-1917)\n\tState variables written after the call(s):\n\t- accountBorrows (CErc20Certora.sol#1980-1981)\n\t- accountBorrows (CErc20Certora.sol#1981-1982)\n\t- totalBorrows (CErc20Certora.sol#1982-1984)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 2098,
                    "vulnerability_to_line": 2147,
                    "vulnerability_code": "    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n\n        /* Fail if seize not allowed */\n\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Fail if borrower = liquidator */\n\n        if (borrower == liquidator) {\n\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n\n        }\n\n\n\n        MathError mathErr;\n\n        uint borrowerTokensNew;\n\n        uint liquidatorTokensNew;\n\n\n\n        /*\n\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n\n         */\n\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        /* We write the previously calculated values into storage */\n\n        accountTokens[borrower] = borrowerTokensNew;\n\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n\n\n        /* Emit a Transfer event */\n\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n\n\n        /* We call the defense hooks */\n\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n\n",
                    "message": "Reentrancy in CToken.seize (CErc20Certora.sol#2098-2147):\n\tExternal calls:\n\t- allowed = comptroller.seizeAllowed(address(this),msg.sender,liquidator,borrower,seizeTokens) (CErc20Certora.sol#2100-2101)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20Certora.sol#2134-2135)\n\t- accountTokens (CErc20Certora.sol#2135-2137)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 1091,
                    "vulnerability_to_line": 1152,
                    "vulnerability_code": "    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n\n        /* Fail if transfer not allowed */\n\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n\n        if (allowed != 0) {\n\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n\n        }\n\n\n\n        /* Do not allow self-transfers */\n\n        if (src == dst) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        /* Get the allowance, infinite for the account owner */\n\n        uint startingAllowance = 0;\n\n        if (spender == src) {\n\n            startingAllowance = uint(-1);\n\n        } else {\n\n            startingAllowance = transferAllowances[src][spender];\n\n        }\n\n\n\n        /* Do the calculations, checking for {under,over}flow */\n\n        MathError mathErr;\n\n        uint allowanceNew;\n\n        uint srcTokensNew;\n\n        uint dstTokensNew;\n\n\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n\n        }\n\n\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n\n        }\n\n\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n\n        if (mathErr != MathError.NO_ERROR) {\n\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        accountTokens[src] = srcTokensNew;\n\n        accountTokens[dst] = dstTokensNew;\n\n\n\n        /* Eat some of the allowance (if necessary) */\n\n        if (startingAllowance != uint(-1)) {\n\n            transferAllowances[src][spender] = allowanceNew;\n\n        }\n\n\n\n        /* We emit a Transfer event */\n\n        emit Transfer(src, dst, tokens);\n\n\n\n        /* We call the defense hooks (which checks for under-collateralization) */\n\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n",
                    "message": "Reentrancy in CToken.transferTokens (CErc20Certora.sol#1091-1152):\n\tExternal calls:\n\t- allowed = comptroller.transferAllowed(address(this),src,dst,tokens) (CErc20Certora.sol#1093)\n\tState variables written after the call(s):\n\t- accountTokens (CErc20Certora.sol#1136)\n\t- accountTokens (CErc20Certora.sol#1137)\n\t- transferAllowances (CErc20Certora.sol#1141)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2573,
                    "vulnerability_to_line": 2602,
                    "vulnerability_code": "    function doTransferIn(address from, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transferFrom(from, address(this), amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_IN_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n\n\n    /**\n",
                    "message": "CErc20.doTransferIn uses assembly (CErc20Certora.sol#2573-2602)\n\t- CErc20Certora.sol#2581-2594\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": 2639,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n\n        bool result;\n\n\n\n        token.transfer(to, amount);\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {                      // This is a non-standard ERC-20\n\n                    result := not(0)          // set result to true\n\n                }\n\n                case 32 {                     // This is a complaint ERC-20\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)        // Set `result = returndata` of external call\n\n                }\n\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n\n\n        if (!result) {\n\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n\n        }\n\n\n\n        return Error.NO_ERROR;\n\n    }\n\n}\n\n\n",
                    "message": "CErc20.doTransferOut uses assembly (CErc20Certora.sol#2610-2639)\n\t- CErc20Certora.sol#2618-2631\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2733,
                    "vulnerability_to_line": 2761,
                    "vulnerability_code": "    function simulateUnderlying(uint expectedError) internal returns (uint) {\n\n        SimulationInterface token = SimulationInterface(underlying);\n\n        bool result;\n\n\n\n        token.dummy();\n\n\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            switch returndatasize()\n\n            case 0 {                      // This is a non-standard ERC-20\n\n                result := not(0)          // set result to true\n\n            }\n\n            case 32 {                     // This is a complaint ERC-20\n\n                returndatacopy(0, 0, 32)\n\n                result := mload(0)        // Set `result = returndata` of external call\n\n            }\n\n            default {                     // This is an excessively non-compliant ERC-20, revert.\n\n                revert(0, 0)\n\n            }\n\n        }\n\n\n\n        if (!result) {\n\n            return expectedError;\n\n        }\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "CErc20Certora.simulateUnderlying uses assembly (CErc20Certora.sol#2733-2761)\n\t- CErc20Certora.sol#2741-2754\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "CToken._setInterestRateModel (CErc20Certora.sol#2346-2357) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2654,
                    "vulnerability_to_line": 2659,
                    "vulnerability_code": "    function getCashOf(address account) public view returns (uint) {\n\n        return EIP20Interface(underlying).balanceOf(account);\n\n    }\n\n}\n\n\n",
                    "message": "CTokenCollateral.getCashOf (CErc20Certora.sol#2654-2659) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2685,
                    "vulnerability_to_line": 2689,
                    "vulnerability_code": "    function comptrollerMintAllowed(address currentContract, address minter, uint mintAmount) public returns (uint) {\n\n        return comptroller.mintAllowed(currentContract, minter, mintAmount);\n\n    }\n\n\n",
                    "message": "CErc20Certora.comptrollerMintAllowed (CErc20Certora.sol#2685-2689) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2689,
                    "vulnerability_to_line": 2693,
                    "vulnerability_code": "    function comptrollerRedeemAllowed(address currentContract, address minter, uint mintAmount) public returns (uint) {\n\n        return comptroller.redeemAllowed(currentContract, minter, mintAmount);\n\n    }\n\n\n",
                    "message": "CErc20Certora.comptrollerRedeemAllowed (CErc20Certora.sol#2689-2693) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2693,
                    "vulnerability_to_line": 2697,
                    "vulnerability_code": "    function exchangeRateStoredInternalPub() public view returns (MathError, uint) {\n\n        return exchangeRateStoredInternal();\n\n    }\n\n\n",
                    "message": "CErc20Certora.exchangeRateStoredInternalPub (CErc20Certora.sol#2693-2697) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2697,
                    "vulnerability_to_line": 2711,
                    "vulnerability_code": "    function cTokenMintComputation(uint mintAmount) public returns (uint) {\n\n        MathError mathErr;\n\n        uint exchangeRateMantissa;\n\n        uint mintTokens;\n\n\n\n        (mathErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        require (mathErr == MathError.NO_ERROR);\n\n\n\n        (mathErr, mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: exchangeRateMantissa}));\n\n        require (mathErr == MathError.NO_ERROR);\n\n\n\n        return mintTokens;\n\n    }\n\n\n",
                    "message": "CErc20Certora.cTokenMintComputation (CErc20Certora.sol#2697-2711) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2711,
                    "vulnerability_to_line": 2725,
                    "vulnerability_code": "    function cTokenRedeemComputation(uint redeemTokens) public returns (uint) {\n\n        MathError mathErr;\n\n        uint exchangeRateMantissa;\n\n        uint redeemAmount;\n\n\n\n        (mathErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n\n        require (mathErr == MathError.NO_ERROR);\n\n\n\n        (mathErr, redeemAmount) = mulScalarTruncate(Exp({mantissa: exchangeRateMantissa}), redeemTokens);\n\n        require (mathErr == MathError.NO_ERROR);\n\n\n\n        return redeemAmount;\n\n    }\n\n\n",
                    "message": "CErc20Certora.cTokenRedeemComputation (CErc20Certora.sol#2711-2725) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2725,
                    "vulnerability_to_line": 2729,
                    "vulnerability_code": "    function checkTransferInPub(address from, uint amount) public view returns (uint) {\n\n        return uint(checkTransferIn(from,amount));\n\n    }\n\n\n",
                    "message": "CErc20Certora.checkTransferInPub (CErc20Certora.sol#2725-2729) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2729,
                    "vulnerability_to_line": 2733,
                    "vulnerability_code": "    function doTransferInPub(address from, uint amount) public returns (uint) {\n\n        return uint(doTransferIn(from,amount));\n\n    }\n\n\n",
                    "message": "CErc20Certora.doTransferInPub (CErc20Certora.sol#2729-2733) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2761,
                    "vulnerability_to_line": 2765,
                    "vulnerability_code": "    function doTransferInPubSim(address from, uint amount) public returns (uint) {\n\n        return simulateUnderlying(uint(Error.TOKEN_TRANSFER_IN_FAILED));\n\n    }\n\n\n",
                    "message": "CErc20Certora.doTransferInPubSim (CErc20Certora.sol#2761-2765) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2765,
                    "vulnerability_to_line": 2769,
                    "vulnerability_code": "    function doTransferOutPub(address payable to, uint amount) public returns (uint) {\n\n        return uint(doTransferOut(to, amount));\n\n    }\n\n\n",
                    "message": "CErc20Certora.doTransferOutPub (CErc20Certora.sol#2765-2769) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2769,
                    "vulnerability_to_line": 2773,
                    "vulnerability_code": "    function doTransferOutPubSim(address payable to, uint amount) public returns (uint) {\n\n        return simulateUnderlying(uint(Error.TOKEN_TRANSFER_OUT_FAILED));\n\n    }\n\n\n",
                    "message": "CErc20Certora.doTransferOutPubSim (CErc20Certora.sol#2769-2773) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": 2777,
                    "vulnerability_code": "    function balanceOfInOther(address account) public view returns (uint) {\n\n        return otherToken.balanceOf(account);\n\n    }\n\n\n",
                    "message": "CErc20Certora.balanceOfInOther (CErc20Certora.sol#2773-2777) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2777,
                    "vulnerability_to_line": 2781,
                    "vulnerability_code": "    function borrowBalanceStoredInOther(address account) public view returns (uint) {\n\n        return otherToken.borrowBalanceStored(account);\n\n    }\n\n\n",
                    "message": "CErc20Certora.borrowBalanceStoredInOther (CErc20Certora.sol#2777-2781) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2781,
                    "vulnerability_to_line": 2785,
                    "vulnerability_code": "    function exchangeRateStoredInOther() public view returns (uint) {\n\n        return otherToken.exchangeRateStored();\n\n    }\n\n\n",
                    "message": "CErc20Certora.exchangeRateStoredInOther (CErc20Certora.sol#2781-2785) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2785,
                    "vulnerability_to_line": 2789,
                    "vulnerability_code": "    function getCashInOther() public view returns (uint) {\n\n        return otherToken.getCash();\n\n    }\n\n\n",
                    "message": "CErc20Certora.getCashInOther (CErc20Certora.sol#2785-2789) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2789,
                    "vulnerability_to_line": 2793,
                    "vulnerability_code": "    function getCashOf(address account) public view returns (uint) {\n\n        return EIP20Interface(underlying).balanceOf(account);\n\n    }\n\n\n",
                    "message": "CErc20Certora.getCashOf (CErc20Certora.sol#2789-2793) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2793,
                    "vulnerability_to_line": 2797,
                    "vulnerability_code": "    function getCashOfInOther(address account) public view returns (uint) {\n\n        return otherToken.getCashOf(account);\n\n    }\n\n\n",
                    "message": "CErc20Certora.getCashOfInOther (CErc20Certora.sol#2793-2797) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2797,
                    "vulnerability_to_line": 2801,
                    "vulnerability_code": "    function totalSupplyInOther() public view returns (uint) {\n\n        return otherToken.totalSupply();\n\n    }\n\n\n",
                    "message": "CErc20Certora.totalSupplyInOther (CErc20Certora.sol#2797-2801) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2801,
                    "vulnerability_to_line": 2805,
                    "vulnerability_code": "    function totalBorrowsInOther() public view returns (uint) {\n\n        return otherToken.totalBorrows();\n\n    }\n\n\n",
                    "message": "CErc20Certora.totalBorrowsInOther (CErc20Certora.sol#2801-2805) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2805,
                    "vulnerability_to_line": 2809,
                    "vulnerability_code": "    function totalReservesInOther() public view returns (uint) {\n\n        return otherToken.totalReserves();\n\n    }\n\n\n",
                    "message": "CErc20Certora.totalReservesInOther (CErc20Certora.sol#2805-2809) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2809,
                    "vulnerability_to_line": 2813,
                    "vulnerability_code": "    function mintFreshPub(address minter, uint mintAmount) public returns (uint) {\n\n        return mintFresh(minter, mintAmount);\n\n    }\n\n\n",
                    "message": "CErc20Certora.mintFreshPub (CErc20Certora.sol#2809-2813) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2813,
                    "vulnerability_to_line": 2817,
                    "vulnerability_code": "    function redeemFreshPub(address payable redeemer, uint redeemTokens, uint redeemUnderlying) public returns (uint) {\n\n        return redeemFresh(redeemer, redeemTokens, redeemUnderlying);\n\n    }\n\n\n",
                    "message": "CErc20Certora.redeemFreshPub (CErc20Certora.sol#2813-2817) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2817,
                    "vulnerability_to_line": 2821,
                    "vulnerability_code": "    function borrowFreshPub(address payable borrower, uint borrowAmount) public returns (uint) {\n\n        return borrowFresh(borrower, borrowAmount);\n\n    }\n\n\n",
                    "message": "CErc20Certora.borrowFreshPub (CErc20Certora.sol#2817-2821) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2821,
                    "vulnerability_to_line": 2825,
                    "vulnerability_code": "    function repayBorrowFreshPub(address payer, address borrower, uint repayAmount) public returns (uint) {\n\n        return repayBorrowFresh(payer, borrower, repayAmount);\n\n    }\n\n\n",
                    "message": "CErc20Certora.repayBorrowFreshPub (CErc20Certora.sol#2821-2825) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2825,
                    "vulnerability_to_line": 2828,
                    "vulnerability_code": "    function liquidateBorrowFreshPub(address liquidator, address borrower, uint repayAmount) public returns (uint) {\n\n        return liquidateBorrowFresh(liquidator, borrower, repayAmount, otherToken);\n\n    }\n",
                    "message": "CErc20Certora.liquidateBorrowFreshPub (CErc20Certora.sol#2825-2828) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": "Detected issues with version pragma in CErc20Certora.sol:\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#3): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#81): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#335): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#423): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#650): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#712): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#785): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#820-821): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#852-853): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#2425-2428): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#2641-2644): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#2661-2663): it allows old versions\n\t- pragma solidity^0.5.8 (CErc20Certora.sol#2669-2673): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": "Constant 'Exponential.expScale' (CErc20Certora.sol#433) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": "Constant 'Exponential.halfExpScale' (CErc20Certora.sol#434) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": "Constant 'Exponential.mantissaOne' (CErc20Certora.sol#435) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2157,
                    "vulnerability_to_line": 2175,
                    "vulnerability_code": "    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n\n        // Check caller = admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n\n        }\n\n\n\n        // Save current value, if any, for inclusion in log\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store pendingAdmin with value newPendingAdmin\n\n        pendingAdmin = newPendingAdmin;\n\n\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setPendingAdmin' (CErc20Certora.sol#2157-2175) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2180,
                    "vulnerability_to_line": 2202,
                    "vulnerability_code": "    function _acceptAdmin() external returns (uint) {\n\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n\n        }\n\n\n\n        // Save current values for inclusion in log\n\n        address oldAdmin = admin;\n\n        address oldPendingAdmin = pendingAdmin;\n\n\n\n        // Store admin with value pendingAdmin\n\n        admin = pendingAdmin;\n\n\n\n        // Clear the pending value\n\n        pendingAdmin = address(0);\n\n\n\n        emit NewAdmin(oldAdmin, admin);\n\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._acceptAdmin' (CErc20Certora.sol#2180-2202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2207,
                    "vulnerability_to_line": 2226,
                    "vulnerability_code": "    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n\n        }\n\n\n\n        ComptrollerInterface oldComptroller = comptroller;\n\n        // Ensure invoke comptroller.isComptroller() returns true\n\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n\n\n        // Set market's comptroller to newComptroller\n\n        comptroller = newComptroller;\n\n\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n\n        emit NewComptroller(oldComptroller, newComptroller);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setComptroller' (CErc20Certora.sol#2207-2226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2231,
                    "vulnerability_to_line": 2241,
                    "vulnerability_code": "    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactor' (CErc20Certora.sol#2231-2241) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2271,
                    "vulnerability_code": "    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n\n        }\n\n\n\n        // Verify market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n\n        }\n\n\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n\n        }\n\n\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setReserveFactorFresh' (CErc20Certora.sol#2246-2271) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2276,
                    "vulnerability_to_line": 2286,
                    "vulnerability_code": "    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n\n        return _reduceReservesFresh(reduceAmount);\n\n    }\n\n\n",
                    "message": "Function 'CToken._reduceReserves' (CErc20Certora.sol#2276-2286) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2292,
                    "vulnerability_to_line": 2341,
                    "vulnerability_code": "    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n\n        Error err;\n\n        // totalReserves - reduceAmount\n\n        uint totalReservesNew;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n\n        }\n\n\n\n        // Fail gracefully if protocol has insufficient underlying cash\n\n        if (getCashPrior() < reduceAmount) {\n\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n\n        }\n\n\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n\n        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n\n        if (reduceAmount > totalReserves) {\n\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n\n        }\n\n\n\n        /////////////////////////\n\n        // EFFECTS & INTERACTIONS\n\n        // (No safe failures beyond this point)\n\n\n\n        totalReservesNew = totalReserves - reduceAmount;\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n\n        totalReserves = totalReservesNew;\n\n\n\n        // invoke doTransferOut(reduceAmount, admin)\n\n        err = doTransferOut(admin, reduceAmount);\n\n        // we revert on the failure of this command\n\n        require(err == Error.NO_ERROR, \"reduce reserves transfer out failed\");\n\n\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._reduceReservesFresh' (CErc20Certora.sol#2292-2341) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": 2357,
                    "vulnerability_code": "    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n\n        uint error = accrueInterest();\n\n        if (error != uint(Error.NO_ERROR)) {\n\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n\n        }\n\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n\n        return _setInterestRateModelFresh(newInterestRateModel);\n\n    }\n\n\n\n    /**\n",
                    "message": "Function 'CToken._setInterestRateModel' (CErc20Certora.sol#2346-2357) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": 2393,
                    "vulnerability_code": "    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n\n\n        // Used to store old model for use in the event that is emitted on success\n\n        InterestRateModel oldInterestRateModel;\n\n\n\n        // Check caller is admin\n\n        if (msg.sender != admin) {\n\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n\n        }\n\n\n\n        // We fail gracefully unless market's block number equals current block number\n\n        if (accrualBlockNumber != getBlockNumber()) {\n\n            // TODO: static_assert + no error code?\n\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n\n        }\n\n\n\n        // Track the market's current interest rate model\n\n        oldInterestRateModel = interestRateModel;\n\n\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n\n\n        // Set the interest rate model to newInterestRateModel\n\n        interestRateModel = newInterestRateModel;\n\n\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n\n\n        return uint(Error.NO_ERROR);\n\n    }\n\n\n",
                    "message": "Function 'CToken._setInterestRateModelFresh' (CErc20Certora.sol#2362-2393) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool public constant isCToken = true;\n",
                    "message": "Constant 'CToken.isCToken' (CErc20Certora.sol#869) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": "Constant 'CToken.borrowRateMaxMantissa' (CErc20Certora.sol#889) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": "Constant 'CToken.reserveFactorMaxMantissa' (CErc20Certora.sol#894) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract CErc20Certora is CErc20 {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private _guardCounter;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint repayAmount) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 586,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 593,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint, uint);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 2693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function exchangeRateStoredInternalPub() public view returns (MathError, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2740,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOutPub(address payable to, uint amount) public returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant expScale = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant halfExpScale = expScale/2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant mantissaOne = expScale;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant borrowRateMaxMantissa = 5e14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 894,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant reserveFactorMaxMantissa = 1e18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) accountTokens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) transferAllowances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => BorrowSnapshot) accountBorrows;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        RedeemLocalVars memory vars;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1680,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (vars.mathErr != MathError.NO_ERROR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 1681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOut(address payable to, uint amount) internal returns (Error) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool result;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2614,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token.transfer(to, amount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            switch returndatasize()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    result := not(0)          // set result to true\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOutPub(address payable to, uint amount) public returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOutPub(address payable to, uint amount) public returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function doTransferOutPub(address payable to, uint amount) public returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return uint(doTransferOut(to, amount));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return uint(doTransferOut(to, amount));\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app/contracts/CErc20Interface.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public underlying;\n",
                    "message": "CErc20Interface.underlying should be constant (CErc20Interface.sol#7)\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app/contracts/misc/MockCErc20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _underlying) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        underlying = _underlying;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _underlying) public {\n",
                    "message": "Parameter '_underlying' of MockCErc20. (MockCErc20.sol#17) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app-b496ca40525a788bdc50f0dcc62bca48e86b6d36/compound-aragon-app/contracts/lib/AddressArrayUtils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length = newLength;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < self.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < self.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < self.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length = newLength;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    }
}