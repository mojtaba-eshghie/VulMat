{
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/framework/ProtocolWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function MVP() public pure returns (uint8) {\n\n        return Protocol.MVP();\n",
                    "message": "ProtocolWrapper.MVP (ProtocolWrapper.sol#33-35) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function MORE_VP() public pure returns (uint8) {\n\n        return Protocol.MORE_VP();\n",
                    "message": "ProtocolWrapper.MORE_VP (ProtocolWrapper.sol#38-40) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function isValidProtocol(uint8 protocol) public pure returns (bool) {\n\n        return Protocol.isValidProtocol(protocol);\n",
                    "message": "ProtocolWrapper.isValidProtocol (ProtocolWrapper.sol#42-44) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in ProtocolWrapper.sol:\n\t- pragma solidity0.5.11 (ProtocolWrapper.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (ProtocolWrapper.sol#29): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "    function MVP() internal pure returns (uint8) {\n\n        return MVP_VALUE;\n",
                    "message": "Function 'Protocol.MVP' (ProtocolWrapper.sol#13-15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "    function MORE_VP() internal pure returns (uint8) {\n\n        return MORE_VP_VALUE;\n",
                    "message": "Function 'Protocol.MORE_VP' (ProtocolWrapper.sol#18-20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function MVP() public pure returns (uint8) {\n\n        return Protocol.MVP();\n",
                    "message": "Function 'ProtocolWrapper.MVP' (ProtocolWrapper.sol#33-35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function MORE_VP() public pure returns (uint8) {\n\n        return Protocol.MORE_VP();\n",
                    "message": "Function 'ProtocolWrapper.MORE_VP' (ProtocolWrapper.sol#38-40) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/SafeEthTransferMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n\n        public\n\n    {\n\n        SafeEthTransfer.transferRevertOnError(receiver, amount, gasStipend);\n",
                    "message": "SafeEthTransferMock.transferRevertOnError (SafeEthTransferMock.sol#53-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function transferReturnResult(address payable receiver, uint256 amount, uint256 gasStipend)\n\n        public\n\n    {\n\n        transferResult = SafeEthTransfer.transferReturnResult(receiver, amount, gasStipend);\n",
                    "message": "SafeEthTransferMock.transferReturnResult (SafeEthTransferMock.sol#59-63) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in SafeEthTransferMock.sol:\n\t- pragma solidity0.5.11 (SafeEthTransferMock.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (SafeEthTransferMock.sol#48): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function transferReturnResult(address payable receiver, uint256 amount, uint256 gasStipend)\n\n        internal\n\n        returns (bool)\n\n    {\n\n        (bool success, ) = receiver.call.gas(gasStipend).value(amount)(\"\");\n\n        return success;\n",
                    "message": "Low level call in SafeEthTransfer.transferReturnResult (SafeEthTransferMock.sol#37-43):\n\t-(success) = receiver.call.gas(gasStipend).value(amount)() SafeEthTransferMock.sol#41\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract SafeEthTransferMock {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool success = transferReturnResult(receiver, amount, gasStipend);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        SafeEthTransfer.transferRevertOnError(receiver, amount, gasStipend);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        SafeEthTransfer.transferRevertOnError(receiver, amount, gasStipend);\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/BitsWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_18"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": 84,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index) public pure returns (uint)\n\n    {\n\n        return Bits.setBit(_self, _index);\n",
                    "message": "BitsWrapper.setBit (BitsWrapper.sol#81-84) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index) public pure returns (uint)\n\n    {\n\n        return Bits.clearBit(_self, _index);\n",
                    "message": "BitsWrapper.clearBit (BitsWrapper.sol#86-89) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 97,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index) public pure returns (bool)\n\n    {\n\n        return Bits.bitSet(_self, _index);\n",
                    "message": "BitsWrapper.bitSet (BitsWrapper.sol#94-97) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in BitsWrapper.sol:\n\t- pragma solidity0.5.11 (BitsWrapper.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (BitsWrapper.sol#78): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.setBit (BitsWrapper.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.setBit (BitsWrapper.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.clearBit (BitsWrapper.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.clearBit (BitsWrapper.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.getBit (BitsWrapper.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.getBit (BitsWrapper.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.bitSet (BitsWrapper.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.bitSet (BitsWrapper.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index) public pure returns (uint)\n",
                    "message": "Parameter '_self' of BitsWrapper.setBit (BitsWrapper.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index) public pure returns (uint)\n",
                    "message": "Parameter '_index' of BitsWrapper.setBit (BitsWrapper.sol#81) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index) public pure returns (uint)\n",
                    "message": "Parameter '_self' of BitsWrapper.clearBit (BitsWrapper.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index) public pure returns (uint)\n",
                    "message": "Parameter '_index' of BitsWrapper.clearBit (BitsWrapper.sol#86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index) public pure returns (bool)\n",
                    "message": "Parameter '_self' of BitsWrapper.bitSet (BitsWrapper.sol#94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index) public pure returns (bool)\n",
                    "message": "Parameter '_index' of BitsWrapper.bitSet (BitsWrapper.sol#94) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/BondSizeMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (uint128 initialBondSize, uint128 initialExitBountySize, uint16 lowerBoundDivisor, uint16 upperBoundMultiplier) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bond = BondSize.buildParams(initialBondSize, initialExitBountySize, lowerBoundDivisor, upperBoundMultiplier);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialBondSize >= initialExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize >= newExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize > 0, \"Bond size cannot be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize >= currentBondSize / self.lowerBoundDivisor, \"Bond size is too low\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(uint256(newBondSize) <= uint256(currentBondSize) * self.upperBoundMultiplier, \"Bond size is too high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self.updatedBondSize != 0 && now >= self.effectiveUpdateTime) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self.previousBondSize = self.updatedBondSize;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self.previousExitBountySize = self.updatedExitBountySize;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialBondSize >= initialExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize >= newExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": 119,
                    "vulnerability_code": "    function bondSize() public view returns (uint128) {\n\n        return bond.bondSize();\n",
                    "message": "BondSizeMock.bondSize (BondSizeMock.sol#117-119) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": 123,
                    "vulnerability_code": "    function bountySize() public view returns (uint128) {\n\n        return bond.exitBountySize();\n",
                    "message": "BondSizeMock.bountySize (BondSizeMock.sol#121-123) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function updateBondSize(uint128 newBondSize, uint128 newExitBountySize) public {\n\n        bond.updateBondSize(newBondSize, newExitBountySize);\n",
                    "message": "BondSizeMock.updateBondSize (BondSizeMock.sol#125-127) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in BondSizeMock.sol:\n\t- pragma solidity0.5.11 (BondSizeMock.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (BondSizeMock.sol#106): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/RLPMockSecurity.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (RLPMockSecurity.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (RLPMockSecurity.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (RLPMockSecurity.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (RLPMockSecurity.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (RLPMockSecurity.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (RLPMockSecurity.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (RLPMockSecurity.sol#33-42)\n\t- RLPMockSecurity.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (RLPMockSecurity.sol#74-87)\n\t- RLPMockSecurity.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (RLPMockSecurity.sol#94-111)\n\t- RLPMockSecurity.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (RLPMockSecurity.sol#118-145)\n\t- RLPMockSecurity.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (RLPMockSecurity.sol#152-168)\n\t- RLPMockSecurity.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (RLPMockSecurity.sol#196-282)\n\t- RLPMockSecurity.sol#202-204\n\t- RLPMockSecurity.sol#217-219\n\t- RLPMockSecurity.sol#233-241\n\t- RLPMockSecurity.sol#263-271\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in RLPMockSecurity.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- RLPMockSecurity.sol#13 declares pragma solidity0.5.11\n\t- RLPMockSecurity.sol#287 declares pragma solidity0.5.11\n\t- RLPMockSecurity.sol#289 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": 298,
                    "vulnerability_code": "    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n\n        return bytes32(_data.toRlpItem().toUint());\n",
                    "message": "RLPMockSecurity.decodeBytes32 (RLPMockSecurity.sol#296-298) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": 302,
                    "vulnerability_code": "    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n\n        return bytes20(_data.toRlpItem().toAddress());\n",
                    "message": "RLPMockSecurity.decodeBytes20 (RLPMockSecurity.sol#300-302) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": 306,
                    "vulnerability_code": "    function decodeUint(bytes memory _data) public pure returns (uint) {\n\n        return _data.toRlpItem().toUint();\n",
                    "message": "RLPMockSecurity.decodeUint (RLPMockSecurity.sol#304-306) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": 310,
                    "vulnerability_code": "    function decodeList(bytes memory _data) public pure returns (RLPReader.RLPItem[] memory) {\n\n        return _data.toRlpItem().toList();\n",
                    "message": "RLPMockSecurity.decodeList (RLPMockSecurity.sol#308-310) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in RLPMockSecurity.sol:\n\t- pragma solidity0.5.11 (RLPMockSecurity.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (RLPMockSecurity.sol#287): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n",
                    "message": "Parameter '_data' of RLPMockSecurity.decodeBytes32 (RLPMockSecurity.sol#296) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n",
                    "message": "Parameter '_data' of RLPMockSecurity.decodeBytes20 (RLPMockSecurity.sol#300) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 304,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeUint(bytes memory _data) public pure returns (uint) {\n",
                    "message": "Parameter '_data' of RLPMockSecurity.decodeUint (RLPMockSecurity.sol#304) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeList(bytes memory _data) public pure returns (RLPReader.RLPItem[] memory) {\n",
                    "message": "Parameter '_data' of RLPMockSecurity.decodeList (RLPMockSecurity.sol#308) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (RLPMockSecurity.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/MerkleWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 32; i <= proof.length; i += 32) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proof.length != 0, \"Merkle proof must not be empty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n\n        internal\n\n        pure\n\n        returns (bool)\n\n    {\n\n        require(proof.length != 0, \"Merkle proof must not be empty\");\n\n        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n\n\n        // see https://github.com/omisego/plasma-contracts/issues/546\n\n        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n\n\n\n        bytes32 proofElement;\n\n        bytes32 computedHash = keccak256(abi.encodePacked(LEAF_SALT, leaf));\n\n        uint256 j = index;\n\n        // Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\n\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                proofElement := mload(add(proof, i))\n\n            }\n\n            if (j % 2 == 0) {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, computedHash, proofElement));\n\n            } else {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, proofElement, computedHash));\n\n            }\n\n            j = j / 2;\n\n        }\n\n\n\n        return computedHash == rootHash;\n",
                    "message": "Merkle.checkMembership (MerkleWrapper.sol#21-50) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n\n        internal\n\n        pure\n\n        returns (bool)\n\n    {\n\n        require(proof.length != 0, \"Merkle proof must not be empty\");\n\n        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n\n\n        // see https://github.com/omisego/plasma-contracts/issues/546\n\n        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n\n\n\n        bytes32 proofElement;\n\n        bytes32 computedHash = keccak256(abi.encodePacked(LEAF_SALT, leaf));\n\n        uint256 j = index;\n\n        // Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\n\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                proofElement := mload(add(proof, i))\n\n            }\n\n            if (j % 2 == 0) {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, computedHash, proofElement));\n\n            } else {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, proofElement, computedHash));\n\n            }\n\n            j = j / 2;\n\n        }\n\n\n\n        return computedHash == rootHash;\n",
                    "message": "Merkle.checkMembership uses assembly (MerkleWrapper.sol#21-50)\n\t- MerkleWrapper.sol#38-40\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 65,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n\n        public\n\n        pure\n\n        returns (bool)\n\n    {\n\n        return Merkle.checkMembership(leaf, index, rootHash, proof);\n",
                    "message": "MerkleWrapper.checkMembership (MerkleWrapper.sol#59-65) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in MerkleWrapper.sol:\n\t- pragma solidity0.5.11 (MerkleWrapper.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (MerkleWrapper.sol#55): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant LEAF_SALT = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant NODE_SALT = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 32; i <= proof.length; i += 32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant LEAF_SALT = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant NODE_SALT = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/RLPMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0, \"Item length must be > 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 341,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(remainingLength < len, \"Remaining length not less than original length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(remainingLength < len, \"Remaining length not less than original length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_37"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (RLPMock.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (RLPMock.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (RLPMock.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (RLPMock.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (RLPMock.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (RLPMock.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": 353,
                    "vulnerability_code": "    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        require(item.len > 0, \"Item length must be > 0\");\n\n\n\n        (uint256 itemLen, uint256 offset) = RLPReader.decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n\n        uint len = itemLen - offset;\n\n        bytes memory result = new bytes(len);\n\n\n\n        uint destPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            destPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr + offset, destPtr, len);\n\n        return result;\n",
                    "message": "RLPMock.toBytes (RLPMock.sol#337-353) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": 381,
                    "vulnerability_code": "    function copyUnsafe(uint src, uint dest, uint len) private pure {\n\n        if (len == 0) return;\n\n        uint remainingLength = len;\n\n\n\n        // copy as many word sizes as possible\n\n        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n\n\n            src += WORD_SIZE;\n\n            dest += WORD_SIZE;\n\n            remainingLength -= WORD_SIZE;\n\n            require(remainingLength < len, \"Remaining length not less than original length\");\n\n        }\n\n\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n\n        uint mask = 256 ** (WORD_SIZE - remainingLength) - 1;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask)) // zero out src\n\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "RLPMock.copyUnsafe (RLPMock.sol#355-381) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 395,
                    "vulnerability_code": "    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        bytes memory result = new bytes(item.len);\n\n        if (result.length == 0) return result;\n\n\n\n        uint resultPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            resultPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr, resultPtr, item.len);\n\n        return result;\n",
                    "message": "RLPMock.toRlpBytes (RLPMock.sol#383-395) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (RLPMock.sol#33-42)\n\t- RLPMock.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (RLPMock.sol#74-87)\n\t- RLPMock.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (RLPMock.sol#94-111)\n\t- RLPMock.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (RLPMock.sol#118-145)\n\t- RLPMock.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (RLPMock.sol#152-168)\n\t- RLPMock.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (RLPMock.sol#196-282)\n\t- RLPMock.sol#202-204\n\t- RLPMock.sol#217-219\n\t- RLPMock.sol#233-241\n\t- RLPMock.sol#263-271\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": 353,
                    "vulnerability_code": "    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        require(item.len > 0, \"Item length must be > 0\");\n\n\n\n        (uint256 itemLen, uint256 offset) = RLPReader.decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n\n        uint len = itemLen - offset;\n\n        bytes memory result = new bytes(len);\n\n\n\n        uint destPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            destPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr + offset, destPtr, len);\n\n        return result;\n",
                    "message": "RLPMock.toBytes uses assembly (RLPMock.sol#337-353)\n\t- RLPMock.sol#347-349\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": 381,
                    "vulnerability_code": "    function copyUnsafe(uint src, uint dest, uint len) private pure {\n\n        if (len == 0) return;\n\n        uint remainingLength = len;\n\n\n\n        // copy as many word sizes as possible\n\n        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n\n\n            src += WORD_SIZE;\n\n            dest += WORD_SIZE;\n\n            remainingLength -= WORD_SIZE;\n\n            require(remainingLength < len, \"Remaining length not less than original length\");\n\n        }\n\n\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n\n        uint mask = 256 ** (WORD_SIZE - remainingLength) - 1;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask)) // zero out src\n\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "RLPMock.copyUnsafe uses assembly (RLPMock.sol#355-381)\n\t- RLPMock.sol#362-364\n\t- RLPMock.sol#376-380\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": 395,
                    "vulnerability_code": "    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n\n        bytes memory result = new bytes(item.len);\n\n        if (result.length == 0) return result;\n\n\n\n        uint resultPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            resultPtr := add(0x20, result)\n\n        }\n\n\n\n        copyUnsafe(item.memPtr, resultPtr, item.len);\n\n        return result;\n",
                    "message": "RLPMock.toRlpBytes uses assembly (RLPMock.sol#383-395)\n\t- RLPMock.sol#389-391\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in RLPMock.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- RLPMock.sol#13 declares pragma solidity0.5.11\n\t- RLPMock.sol#287 declares pragma solidity0.5.11\n\t- RLPMock.sol#289 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 300,
                    "vulnerability_code": "    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n\n        return _data.toRlpItem().toBytes32();\n",
                    "message": "RLPMock.decodeBytes32 (RLPMock.sol#298-300) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 304,
                    "vulnerability_code": "    function decodeAddress(bytes memory _data) public pure returns (address) {\n\n        return _data.toRlpItem().toAddress();\n",
                    "message": "RLPMock.decodeAddress (RLPMock.sol#302-304) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": 308,
                    "vulnerability_code": "    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n\n        return bytes20(_data.toRlpItem().toAddress());\n",
                    "message": "RLPMock.decodeBytes20 (RLPMock.sol#306-308) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function decodeBytes(bytes memory _data) public pure returns (bytes memory) {\n\n        return toBytes(_data.toRlpItem());\n",
                    "message": "RLPMock.decodeBytes (RLPMock.sol#310-312) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": 316,
                    "vulnerability_code": "    function decodeUint(bytes memory _data) public pure returns (uint) {\n\n        return _data.toRlpItem().toUint();\n",
                    "message": "RLPMock.decodeUint (RLPMock.sol#314-316) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": 320,
                    "vulnerability_code": "    function decodeInt(bytes memory _data) public pure returns (int) {\n\n        return int(_data.toRlpItem().toUint());\n",
                    "message": "RLPMock.decodeInt (RLPMock.sol#318-320) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": 324,
                    "vulnerability_code": "    function decodeString(bytes memory _data) public pure returns (string memory) {\n\n        return string(toBytes(_data.toRlpItem()));\n",
                    "message": "RLPMock.decodeString (RLPMock.sol#322-324) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": 335,
                    "vulnerability_code": "    function decodeList(bytes memory _data) public pure returns (bytes[] memory) {\n\n\n\n        RLPReader.RLPItem[] memory items = _data.toRlpItem().toList();\n\n\n\n        bytes[] memory result =  new bytes[](items.length);\n\n        for (uint i = 0; i < items.length; i++) {\n\n            result[i] = toRlpBytes(items[i]);\n\n        }\n\n        return result;\n",
                    "message": "RLPMock.decodeList (RLPMock.sol#326-335) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in RLPMock.sol:\n\t- pragma solidity0.5.11 (RLPMock.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (RLPMock.sol#287): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeBytes32 (RLPMock.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeAddress(bytes memory _data) public pure returns (address) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeAddress (RLPMock.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeBytes20 (RLPMock.sol#306) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeBytes(bytes memory _data) public pure returns (bytes memory) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeBytes (RLPMock.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeUint(bytes memory _data) public pure returns (uint) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeUint (RLPMock.sol#314) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeInt(bytes memory _data) public pure returns (int) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeInt (RLPMock.sol#318) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeString(bytes memory _data) public pure returns (string memory) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeString (RLPMock.sol#322) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeList(bytes memory _data) public pure returns (bytes[] memory) {\n",
                    "message": "Parameter '_data' of RLPMock.decodeList (RLPMock.sol#326) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (RLPMock.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < items.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyUnsafe(uint src, uint dest, uint len) private pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/QuarantineMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _period, uint256 _initialImmuneCount)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _quarantine.quarantinePeriod = _period;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _quarantine.immunitiesRemaining = _initialImmuneCount;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_contractAddress != address(0), \"An empty address cannot be quarantined\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_self.store[_contractAddress] == 0, \"The contract is already quarantined\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _self.immunitiesRemaining--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_contractAddress != address(0), \"An empty address cannot be quarantined\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_self.store[_contractAddress] == 0, \"The contract is already quarantined\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 22,
                    "vulnerability_code": "    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n\n        return block.timestamp < _self.store[_contractAddress];\n",
                    "message": "Quarantine.isQuarantined (QuarantineMock.sol#20-22) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp < _self.store[_contractAddress] (QuarantineMock.sol#21)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function quarantineContract(address _contractAddress) public {\n\n        _quarantine.quarantine(_contractAddress);\n",
                    "message": "QuarantineMock.quarantineContract (QuarantineMock.sol#55-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function isQuarantined(address _contractAddress) public view returns (bool) {\n\n        return _quarantine.isQuarantined(_contractAddress);\n",
                    "message": "QuarantineMock.isQuarantined (QuarantineMock.sol#59-61) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in QuarantineMock.sol:\n\t- pragma solidity0.5.11 (QuarantineMock.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (QuarantineMock.sol#42): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n",
                    "message": "Parameter '_self' of Quarantine.isQuarantined (QuarantineMock.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n",
                    "message": "Parameter '_contractAddress' of Quarantine.isQuarantined (QuarantineMock.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function quarantine(Data storage _self, address _contractAddress) internal {\n",
                    "message": "Parameter '_self' of Quarantine.quarantine (QuarantineMock.sol#28) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function quarantine(Data storage _self, address _contractAddress) internal {\n",
                    "message": "Parameter '_contractAddress' of Quarantine.quarantine (QuarantineMock.sol#28) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _period, uint256 _initialImmuneCount)\n",
                    "message": "Parameter '_period' of QuarantineMock. (QuarantineMock.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(uint256 _period, uint256 _initialImmuneCount)\n",
                    "message": "Parameter '_initialImmuneCount' of QuarantineMock. (QuarantineMock.sol#48) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function quarantineContract(address _contractAddress) public {\n",
                    "message": "Parameter '_contractAddress' of QuarantineMock.quarantineContract (QuarantineMock.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isQuarantined(address _contractAddress) public view returns (bool) {\n",
                    "message": "Parameter '_contractAddress' of QuarantineMock.isQuarantined (QuarantineMock.sol#59) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Quarantine.Data internal _quarantine;\n",
                    "message": "Variable 'QuarantineMock._quarantine' (QuarantineMock.sol#46) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/utils/OnlyWithValueMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == _value, \"Input value must match msg.value\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": 21,
                    "vulnerability_code": "    function checkOnlyWithValue(uint256 _value) public payable onlyWithValue(_value) {\n\n        emit OnlyWithValuePassed();\n",
                    "message": "Contract locking ether found in OnlyWithValueMock.sol:\n\tContract OnlyWithValueMock has payable functions:\n\t - checkOnlyWithValue (OnlyWithValueMock.sol#19-21)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": 21,
                    "vulnerability_code": "    function checkOnlyWithValue(uint256 _value) public payable onlyWithValue(_value) {\n\n        emit OnlyWithValuePassed();\n",
                    "message": "OnlyWithValueMock.checkOnlyWithValue (OnlyWithValueMock.sol#19-21) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in OnlyWithValueMock.sol:\n\t- pragma solidity0.5.11 (OnlyWithValueMock.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (OnlyWithValueMock.sol#14): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract OnlyWithValueMock is OnlyWithValue {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/transactions/GenericTransactionWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(rlpTx.length == TX_NUM_ITEMS, \"Invalid encoding of transaction\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(txType > 0, \"Transaction type must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(rlpList.length == 2, \"Output must have 2 items\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(output.outputType != 0, \"Output type must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_17"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (GenericTransactionWrapper.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (GenericTransactionWrapper.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (GenericTransactionWrapper.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (GenericTransactionWrapper.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (GenericTransactionWrapper.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (GenericTransactionWrapper.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (GenericTransactionWrapper.sol#33-42)\n\t- GenericTransactionWrapper.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (GenericTransactionWrapper.sol#74-87)\n\t- GenericTransactionWrapper.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (GenericTransactionWrapper.sol#94-111)\n\t- GenericTransactionWrapper.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (GenericTransactionWrapper.sol#118-145)\n\t- GenericTransactionWrapper.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (GenericTransactionWrapper.sol#152-168)\n\t- GenericTransactionWrapper.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (GenericTransactionWrapper.sol#196-282)\n\t- GenericTransactionWrapper.sol#202-204\n\t- GenericTransactionWrapper.sol#217-219\n\t- GenericTransactionWrapper.sol#233-241\n\t- GenericTransactionWrapper.sol#263-271\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in GenericTransactionWrapper.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- GenericTransactionWrapper.sol#13 declares pragma solidity0.5.11\n\t- GenericTransactionWrapper.sol#287 declares pragma solidity0.5.11\n\t- GenericTransactionWrapper.sol#384 declares pragma solidity0.5.11\n\t- GenericTransactionWrapper.sol#385 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function decode(bytes memory transaction) public pure returns (GenericTransaction.Transaction memory) {\n\n        return GenericTransaction.decode(transaction);\n",
                    "message": "GenericTransactionWrapper.decode (GenericTransactionWrapper.sol#389-391) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function getOutput(bytes memory transaction, uint16 outputIndex) public pure returns (GenericTransaction.Output memory) {\n\n        GenericTransaction.Transaction memory genericTx = GenericTransaction.decode(transaction);\n\n        return GenericTransaction.getOutput(genericTx, outputIndex);\n",
                    "message": "GenericTransactionWrapper.getOutput (GenericTransactionWrapper.sol#393-396) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in GenericTransactionWrapper.sol:\n\t- pragma solidity0.5.11 (GenericTransactionWrapper.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (GenericTransactionWrapper.sol#287): it allows old versions\n\t- pragma solidity0.5.11 (GenericTransactionWrapper.sol#384): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (GenericTransactionWrapper.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant private TX_NUM_ITEMS = 5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/attackers/OutOfGasFallbackAttacker.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": 8,
                    "vulnerability_code": "    function () external payable {\n\n        while (true) {}\n",
                    "message": "Contract locking ether found in OutOfGasFallbackAttacker.sol:\n\tContract OutOfGasFallbackAttacker has payable functions:\n\t - fallback (OutOfGasFallbackAttacker.sol#6-8)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in OutOfGasFallbackAttacker.sol:\n\t- pragma solidity0.5.11 (OutOfGasFallbackAttacker.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (true) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract OutOfGasFallbackAttacker {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/attackers/FallbackFunctionFailAttacker.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"fail on fallback function\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": 9,
                    "vulnerability_code": "    function () external payable {\n\n        revert(\"fail on fallback function\");\n",
                    "message": "Contract locking ether found in FallbackFunctionFailAttacker.sol:\n\tContract FallbackFunctionFailAttacker has payable functions:\n\t - fallback (FallbackFunctionFailAttacker.sol#7-9)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in FallbackFunctionFailAttacker.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- FallbackFunctionFailAttacker.sol#3 declares pragma solidity0.5.11\n\t- FallbackFunctionFailAttacker.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in FallbackFunctionFailAttacker.sol:\n\t- pragma solidity0.5.11 (FallbackFunctionFailAttacker.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 6,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract FallbackFunctionFailAttacker {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REDUNDANT_FALLBACK_REJECT",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function () external payable {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/exits/SpendingConditionMock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(keccak256(expectedArgs.inputTx) == keccak256(inputTx), \"input tx not as expected\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(expectedArgs.utxoPos == utxoPos, \"utxoPos not as expected\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(keccak256(expectedArgs.spendingTx) == keccak256(spendingTx), \"spending tx not as expected\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(expectedArgs.inputIndex == inputIndex, \"input index not as expected\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(keccak256(expectedArgs.witness) == keccak256(witness), \"witness not as expected\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in SpendingConditionMock.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- SpendingConditionMock.sol#3 declares pragma solidity0.5.11\n\t- SpendingConditionMock.sol#31 declares pragma solidity0.5.11\n\t- SpendingConditionMock.sol#32 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function mockResult(bool result) public {\n\n        expectedResult = result;\n",
                    "message": "SpendingConditionMock.mockResult (SpendingConditionMock.sol#50-52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function mockRevert() public {\n\n        shouldRevert = true;\n",
                    "message": "SpendingConditionMock.mockRevert (SpendingConditionMock.sol#55-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function shouldVerifyArgumentEquals(Args memory args) public {\n\n        expectedArgs = args;\n",
                    "message": "SpendingConditionMock.shouldVerifyArgumentEquals (SpendingConditionMock.sol#60-62) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in SpendingConditionMock.sol:\n\t- pragma solidity0.5.11 (SpendingConditionMock.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (SpendingConditionMock.sol#31): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verify(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verify(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata spendingTx,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint16 inputIndex,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata witness\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external view returns (bool);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata spendingTx,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint16 inputIndex,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata witness\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (shouldRevert) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(REVERT_MESSAGE);\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/exits/utils/OutputIdWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 53,
                    "vulnerability_code": "    function computeDepositOutputId(\n\n        bytes memory _txBytes,\n\n        uint8 _outputIndex,\n\n        uint256 _utxoPosValue\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes32)\n\n    {\n\n        return OutputId.computeDepositOutputId(_txBytes, _outputIndex, _utxoPosValue);\n",
                    "message": "OutputIdWrapper.computeDepositOutputId (OutputIdWrapper.sol#43-53) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function computeNormalOutputId(\n\n        bytes memory _txBytes,\n\n        uint8 _outputIndex\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes32)\n\n    {\n\n        return OutputId.computeNormalOutputId(_txBytes, _outputIndex);\n",
                    "message": "OutputIdWrapper.computeNormalOutputId (OutputIdWrapper.sol#55-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in OutputIdWrapper.sol:\n\t- pragma solidity0.5.11 (OutputIdWrapper.sol#3): it allows old versions\n\t- pragma solidity0.5.11 (OutputIdWrapper.sol#40): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n",
                    "message": "Parameter '_txBytes' of OutputId.computeDepositOutputId (OutputIdWrapper.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n",
                    "message": "Parameter '_outputIndex' of OutputId.computeDepositOutputId (OutputIdWrapper.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n",
                    "message": "Parameter '_utxoPosValue' of OutputId.computeDepositOutputId (OutputIdWrapper.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeNormalOutputId(bytes memory _txBytes, uint256 _outputIndex)\n",
                    "message": "Parameter '_txBytes' of OutputId.computeNormalOutputId (OutputIdWrapper.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeNormalOutputId(bytes memory _txBytes, uint256 _outputIndex)\n",
                    "message": "Parameter '_outputIndex' of OutputId.computeNormalOutputId (OutputIdWrapper.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _txBytes,\n",
                    "message": "Parameter '_txBytes' of OutputIdWrapper.computeDepositOutputId (OutputIdWrapper.sol#44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8 _outputIndex,\n",
                    "message": "Parameter '_outputIndex' of OutputIdWrapper.computeDepositOutputId (OutputIdWrapper.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _utxoPosValue\n",
                    "message": "Parameter '_utxoPosValue' of OutputIdWrapper.computeDepositOutputId (OutputIdWrapper.sol#46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory _txBytes,\n",
                    "message": "Parameter '_txBytes' of OutputIdWrapper.computeNormalOutputId (OutputIdWrapper.sol#56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint8 _outputIndex\n",
                    "message": "Parameter '_outputIndex' of OutputIdWrapper.computeNormalOutputId (OutputIdWrapper.sol#57) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/mocks/python_tests_wrappers/RLPTest.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (RLPTest.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (RLPTest.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (RLPTest.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (RLPTest.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (RLPTest.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (RLPTest.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (RLPTest.sol#33-42)\n\t- RLPTest.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (RLPTest.sol#74-87)\n\t- RLPTest.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (RLPTest.sol#94-111)\n\t- RLPTest.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (RLPTest.sol#118-145)\n\t- RLPTest.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (RLPTest.sol#152-168)\n\t- RLPTest.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (RLPTest.sol#196-282)\n\t- RLPTest.sol#202-204\n\t- RLPTest.sol#217-219\n\t- RLPTest.sol#233-241\n\t- RLPTest.sol#263-271\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in RLPTest.sol:\n\t- Version used: ['0.5.11', '^0.5.0']\n\t- RLPTest.sol#13 declares pragma solidity0.5.11\n\t- RLPTest.sol#287 declares pragma solidity^0.5.0\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 305,
                    "vulnerability_code": "    function eight(bytes memory tx_bytes)\n\n        public\n\n        pure\n\n        returns (uint256, address, address)\n\n    {\n\n        RLPReader.RLPItem[] memory txList = RLPReader.toList(RLPReader.toRlpItem(tx_bytes));\n\n        return (\n\n            RLPReader.toUint(txList[5]),\n\n            RLPReader.toAddress(txList[6]),\n\n            RLPReader.toAddress(txList[7])\n\n        );\n",
                    "message": "RLPTest.eight (RLPTest.sol#294-305) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": 319,
                    "vulnerability_code": "    function eleven(bytes memory tx_bytes)\n\n        public\n\n        pure\n\n        returns (uint256, address, address, address)\n\n    {\n\n        RLPReader.RLPItem[] memory  txList = RLPReader.toList(RLPReader.toRlpItem(tx_bytes));\n\n        return (\n\n            RLPReader.toUint(txList[7]),\n\n            RLPReader.toAddress(txList[8]),\n\n            RLPReader.toAddress(txList[9]),\n\n            RLPReader.toAddress(txList[10])\n\n        );\n",
                    "message": "RLPTest.eleven (RLPTest.sol#307-319) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in RLPTest.sol:\n\t- pragma solidity0.5.11 (RLPTest.sol#13): it allows old versions\n\t- pragma solidity^0.5.0 (RLPTest.sol#287): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function eight(bytes memory tx_bytes)\n",
                    "message": "Parameter 'tx_bytes' of RLPTest.eight (RLPTest.sol#294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function eleven(bytes memory tx_bytes)\n",
                    "message": "Parameter 'tx_bytes' of RLPTest.eleven (RLPTest.sol#307) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (RLPTest.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, address, address)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256, address, address, address)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/framework/Protocol.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in Protocol.sol:\n\t- pragma solidity0.5.11 (Protocol.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "    function MVP() internal pure returns (uint8) {\n\n        return MVP_VALUE;\n",
                    "message": "Function 'Protocol.MVP' (Protocol.sol#13-15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 20,
                    "vulnerability_code": "    function MORE_VP() internal pure returns (uint8) {\n\n        return MORE_VP_VALUE;\n",
                    "message": "Function 'Protocol.MORE_VP' (Protocol.sol#18-20) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/framework/utils/Quarantine.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_contractAddress != address(0), \"An empty address cannot be quarantined\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_self.store[_contractAddress] == 0, \"The contract is already quarantined\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _self.immunitiesRemaining--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_contractAddress != address(0), \"An empty address cannot be quarantined\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_self.store[_contractAddress] == 0, \"The contract is already quarantined\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 22,
                    "vulnerability_code": "    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n\n        return block.timestamp < _self.store[_contractAddress];\n",
                    "message": "Quarantine.isQuarantined (Quarantine.sol#20-22) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- block.timestamp < _self.store[_contractAddress] (Quarantine.sol#21)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in Quarantine.sol:\n\t- pragma solidity0.5.11 (Quarantine.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n",
                    "message": "Parameter '_self' of Quarantine.isQuarantined (Quarantine.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n",
                    "message": "Parameter '_contractAddress' of Quarantine.isQuarantined (Quarantine.sol#20) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function quarantine(Data storage _self, address _contractAddress) internal {\n",
                    "message": "Parameter '_self' of Quarantine.quarantine (Quarantine.sol#28) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function quarantine(Data storage _self, address _contractAddress) internal {\n",
                    "message": "Parameter '_contractAddress' of Quarantine.quarantine (Quarantine.sol#28) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/framework/models/BlockModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in BlockModel.sol:\n\t- pragma solidity0.5.11 (BlockModel.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/framework/interfaces/IExitProcessor.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in IExitProcessor.sol:\n\t- pragma solidity0.5.11 (IExitProcessor.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function processExit(uint168 exitId, uint256 vaultId, address token, address payable processExitInitiator) external;\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/utils/RLPReader.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (RLPReader.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (RLPReader.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (RLPReader.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (RLPReader.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (RLPReader.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (RLPReader.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (RLPReader.sol#33-42)\n\t- RLPReader.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (RLPReader.sol#74-87)\n\t- RLPReader.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (RLPReader.sol#94-111)\n\t- RLPReader.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (RLPReader.sol#118-145)\n\t- RLPReader.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (RLPReader.sol#152-168)\n\t- RLPReader.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (RLPReader.sol#196-282)\n\t- RLPReader.sol#202-204\n\t- RLPReader.sol#217-219\n\t- RLPReader.sol#233-241\n\t- RLPReader.sol#263-271\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in RLPReader.sol:\n\t- pragma solidity0.5.11 (RLPReader.sol#13): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (RLPReader.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/utils/Bits.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in Bits.sol:\n\t- pragma solidity0.5.11 (Bits.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.setBit (Bits.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.setBit (Bits.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.clearBit (Bits.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function clearBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.clearBit (Bits.sol#39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.getBit (Bits.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getBit(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.getBit (Bits.sol#53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index)\n",
                    "message": "Parameter '_self' of Bits.bitSet (Bits.sol#67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bitSet(uint _self, uint8 _index)\n",
                    "message": "Parameter '_index' of Bits.bitSet (Bits.sol#67) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/utils/OnlyFromAddress.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == caller, \"Caller address is unauthorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in OnlyFromAddress.sol:\n\t- pragma solidity0.5.11 (OnlyFromAddress.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/utils/SafeEthTransfer.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in SafeEthTransfer.sol:\n\t- pragma solidity0.5.11 (SafeEthTransfer.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function transferReturnResult(address payable receiver, uint256 amount, uint256 gasStipend)\n\n        internal\n\n        returns (bool)\n\n    {\n\n        (bool success, ) = receiver.call.gas(gasStipend).value(amount)(\"\");\n\n        return success;\n",
                    "message": "Low level call in SafeEthTransfer.transferReturnResult (SafeEthTransfer.sol#37-43):\n\t-(success) = receiver.call.gas(gasStipend).value(amount)() SafeEthTransfer.sol#41\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bool success = transferReturnResult(receiver, amount, gasStipend);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/utils/OnlyWithValue.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value == _value, \"Input value must match msg.value\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in OnlyWithValue.sol:\n\t- pragma solidity0.5.11 (OnlyWithValue.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/utils/Merkle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 32; i <= proof.length; i += 32) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proof.length != 0, \"Merkle proof must not be empty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n\n        internal\n\n        pure\n\n        returns (bool)\n\n    {\n\n        require(proof.length != 0, \"Merkle proof must not be empty\");\n\n        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n\n\n        // see https://github.com/omisego/plasma-contracts/issues/546\n\n        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n\n\n\n        bytes32 proofElement;\n\n        bytes32 computedHash = keccak256(abi.encodePacked(LEAF_SALT, leaf));\n\n        uint256 j = index;\n\n        // Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\n\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                proofElement := mload(add(proof, i))\n\n            }\n\n            if (j % 2 == 0) {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, computedHash, proofElement));\n\n            } else {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, proofElement, computedHash));\n\n            }\n\n            j = j / 2;\n\n        }\n\n\n\n        return computedHash == rootHash;\n",
                    "message": "Merkle.checkMembership (Merkle.sol#21-50) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 50,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n\n        internal\n\n        pure\n\n        returns (bool)\n\n    {\n\n        require(proof.length != 0, \"Merkle proof must not be empty\");\n\n        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n\n\n        // see https://github.com/omisego/plasma-contracts/issues/546\n\n        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n\n\n\n        bytes32 proofElement;\n\n        bytes32 computedHash = keccak256(abi.encodePacked(LEAF_SALT, leaf));\n\n        uint256 j = index;\n\n        // Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\n\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                proofElement := mload(add(proof, i))\n\n            }\n\n            if (j % 2 == 0) {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, computedHash, proofElement));\n\n            } else {\n\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, proofElement, computedHash));\n\n            }\n\n            j = j / 2;\n\n        }\n\n\n\n        return computedHash == rootHash;\n",
                    "message": "Merkle.checkMembership uses assembly (Merkle.sol#21-50)\n\t- Merkle.sol#38-40\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in Merkle.sol:\n\t- pragma solidity0.5.11 (Merkle.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant LEAF_SALT = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant NODE_SALT = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 32; i <= proof.length; i += 32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant LEAF_SALT = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte private constant NODE_SALT = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/transactions/GenericTransaction.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(rlpTx.length == TX_NUM_ITEMS, \"Invalid encoding of transaction\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(txType > 0, \"Transaction type must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(rlpList.length == 2, \"Output must have 2 items\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(output.outputType != 0, \"Output type must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (GenericTransaction.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (GenericTransaction.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (GenericTransaction.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (GenericTransaction.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (GenericTransaction.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (GenericTransaction.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (GenericTransaction.sol#33-42)\n\t- GenericTransaction.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (GenericTransaction.sol#74-87)\n\t- GenericTransaction.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (GenericTransaction.sol#94-111)\n\t- GenericTransaction.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (GenericTransaction.sol#118-145)\n\t- GenericTransaction.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (GenericTransaction.sol#152-168)\n\t- GenericTransaction.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (GenericTransaction.sol#196-282)\n\t- GenericTransaction.sol#202-204\n\t- GenericTransaction.sol#217-219\n\t- GenericTransaction.sol#233-241\n\t- GenericTransaction.sol#263-271\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in GenericTransaction.sol:\n\t- pragma solidity0.5.11 (GenericTransaction.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (GenericTransaction.sol#287): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (GenericTransaction.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant private TX_NUM_ITEMS = 5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/transactions/FungibleTokenOutputModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isList(item), \"Item is not a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 21, \"Item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 21, \"Decoded item length must be 21\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len == 33, \"Item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!isList(item), \"Item must not be a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == 33, \"Decoded item length must be 33\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(rlpTx.length == TX_NUM_ITEMS, \"Invalid encoding of transaction\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(txType > 0, \"Transaction type must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(rlpList.length == 2, \"Output must have 2 items\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 377,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(output.outputType != 0, \"Output type must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(dataList.length == 3, \"Output data must have 3 items\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(outputData.outputGuard != bytes20(0), \"Output outputGuard must not be 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (decodedLength == 2){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 215,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    byte1 := byte(0, mload(add(memPtr, 1)))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 byte1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 lengthLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // solhint-disable-next-line no-inline-assembly\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // decodedLength is between 1 and 56 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset = 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // lengthLen is between 1 and 8 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // dataLen is greater than 55 bytes\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint256 dataLen;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < items; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            count++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem (FungibleTokenOutputModel.sol#33-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList (FungibleTokenOutputModel.sol#74-87) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress (FungibleTokenOutputModel.sol#94-111) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint (FungibleTokenOutputModel.sol#118-145) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 (FungibleTokenOutputModel.sol#152-168) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset (FungibleTokenOutputModel.sol#196-282) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n\n        uint256 memPtr;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            memPtr := add(item, 0x20)\n\n        }\n\n\n\n        return RLPItem(item.length, memPtr);\n",
                    "message": "RLPReader.toRlpItem uses assembly (FungibleTokenOutputModel.sol#33-42)\n\t- FungibleTokenOutputModel.sol#37-39\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 87,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n\n        if (item.len == 0) return false;\n\n\n\n        uint8 byte0;\n\n        uint256 memPtr = item.memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < LIST_SHORT_START)\n\n            return false;\n\n        return true;\n",
                    "message": "RLPReader.isList uses assembly (FungibleTokenOutputModel.sol#74-87)\n\t- FungibleTokenOutputModel.sol#80-82\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n\n        require(item.len == 21, \"Item length must be 21\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        uint256 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            // right shift by 12 to make bytes20\n\n            result := div(result, exp(256, 12))\n\n        }\n\n\n\n        return address(result);\n",
                    "message": "RLPReader.toAddress uses assembly (FungibleTokenOutputModel.sol#94-111)\n\t- FungibleTokenOutputModel.sol#104-108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n\n\n        uint256 dataLen = itemLen - offset;\n\n\n\n        uint result;\n\n        uint dataByte0;\n\n        uint dataMemPtr = item.memPtr + offset;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n            dataByte0 := byte(0, result)\n\n            // shift to the correct location if necessary\n\n            if lt(dataLen, WORD_SIZE) {\n\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n\n            }\n\n        }\n\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n\n\n        // Disallow leading zeros\n\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n\n\n        return result;\n",
                    "message": "RLPReader.toUint uses assembly (FungibleTokenOutputModel.sol#118-145)\n\t- FungibleTokenOutputModel.sol#130-137\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n\n        // 1 byte for the length prefix\n\n        require(item.len == 33, \"Item length must be 33\");\n\n        require(!isList(item), \"Item must not be a list\");\n\n\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n\n\n        uint256 dataMemPtr = item.memPtr + offset;\n\n        bytes32 result;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            result := mload(dataMemPtr)\n\n        }\n\n\n\n        return result;\n",
                    "message": "RLPReader.toBytes32 uses assembly (FungibleTokenOutputModel.sol#152-168)\n\t- FungibleTokenOutputModel.sol#163-165\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 282,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n\n        uint256 decodedLength;\n\n        uint256 offset;\n\n        uint256 byte0;\n\n\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            byte0 := byte(0, mload(memPtr))\n\n        }\n\n\n\n        if (byte0 < STRING_SHORT_START) {\n\n            // Item is a single byte\n\n            decodedLength = 1;\n\n            offset = 0;\n\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n\n            if (decodedLength == 2){\n\n                uint256 byte1;\n\n                // solhint-disable-next-line no-inline-assembly\n\n                assembly {\n\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n\n                }\n\n                // A single byte below 0x80 must be encoded as itself.\n\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n\n            }\n\n            offset = 1;\n\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n\n            // decodedLength is between 1 and 56 bytes\n\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n\n            offset = 1;\n\n        } else {\n\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n\n            // lengthLen is between 1 and 8 bytes\n\n            // dataLen is greater than 55 bytes\n\n            uint256 dataLen;\n\n            uint256 byte1;\n\n            uint256 lengthLen;\n\n\n\n            // solhint-disable-next-line no-inline-assembly\n\n            assembly {\n\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n\n\n                // right shift to the correct position\n\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n\n                decodedLength := add(dataLen, add(lengthLen, 1))\n\n                byte1 := byte(0, mload(memPtr))\n\n            }\n\n\n\n            // Check that the length has no leading zeros\n\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n\n            // Check that the value of length > MAX_SHORT_LEN\n\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n\n            // Calculate the offset\n\n            offset = lengthLen + 1;\n\n        }\n\n\n\n        return (decodedLength, offset);\n",
                    "message": "RLPReader.decodeLengthAndOffset uses assembly (FungibleTokenOutputModel.sol#196-282)\n\t- FungibleTokenOutputModel.sol#202-204\n\t- FungibleTokenOutputModel.sol#217-219\n\t- FungibleTokenOutputModel.sol#233-241\n\t- FungibleTokenOutputModel.sol#263-271\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in FungibleTokenOutputModel.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- FungibleTokenOutputModel.sol#13 declares pragma solidity0.5.11\n\t- FungibleTokenOutputModel.sol#287 declares pragma solidity0.5.11\n\t- FungibleTokenOutputModel.sol#384 declares pragma solidity0.5.11\n\t- FungibleTokenOutputModel.sol#385 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in FungibleTokenOutputModel.sol:\n\t- pragma solidity0.5.11 (FungibleTokenOutputModel.sol#13): it allows old versions\n\t- pragma solidity0.5.11 (FungibleTokenOutputModel.sol#287): it allows old versions\n\t- pragma solidity0.5.11 (FungibleTokenOutputModel.sol#384): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal WORD_SIZE = 32;\n",
                    "message": "RLPReader.WORD_SIZE (FungibleTokenOutputModel.sol#21) is never used in RLPReader\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_SHORT_START = 0x80;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal STRING_LONG_START  = 0xb8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_SHORT_START   = 0xc0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant internal LIST_LONG_START    = 0xf8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < outputList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (currPtr < endPtr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant private TX_NUM_ITEMS = 5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isList(RLPItem memory item) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toAddress(RLPItem memory item) internal pure returns (address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toUint(RLPItem memory item) internal pure returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/vaults/verifiers/IErc20DepositVerifier.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in IErc20DepositVerifier.sol:\n\t- pragma solidity0.5.11 (IErc20DepositVerifier.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address owner, address token, uint256 amount);\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/vaults/verifiers/IEthDepositVerifier.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in IEthDepositVerifier.sol:\n\t- pragma solidity0.5.11 (IEthDepositVerifier.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/fee/FeeExitGame.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in FeeExitGame.sol:\n\t- pragma solidity0.5.11 (FeeExitGame.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/payment/PaymentExitDataModel.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in PaymentExitDataModel.sol:\n\t- pragma solidity0.5.11 (PaymentExitDataModel.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/payment/routers/PaymentStandardExitRouterArgs.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in PaymentStandardExitRouterArgs.sol:\n\t- pragma solidity0.5.11 (PaymentStandardExitRouterArgs.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/payment/routers/PaymentInFlightExitRouterArgs.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in PaymentInFlightExitRouterArgs.sol:\n\t- pragma solidity0.5.11 (PaymentInFlightExitRouterArgs.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/utils/OutputId.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in OutputId.sol:\n\t- pragma solidity0.5.11 (OutputId.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n",
                    "message": "Parameter '_txBytes' of OutputId.computeDepositOutputId (OutputId.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n",
                    "message": "Parameter '_outputIndex' of OutputId.computeDepositOutputId (OutputId.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n",
                    "message": "Parameter '_utxoPosValue' of OutputId.computeDepositOutputId (OutputId.sol#15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeNormalOutputId(bytes memory _txBytes, uint256 _outputIndex)\n",
                    "message": "Parameter '_txBytes' of OutputId.computeNormalOutputId (OutputId.sol#29) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function computeNormalOutputId(bytes memory _txBytes, uint256 _outputIndex)\n",
                    "message": "Parameter '_outputIndex' of OutputId.computeNormalOutputId (OutputId.sol#29) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/utils/BondSize.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialBondSize >= initialExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize >= newExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize > 0, \"Bond size cannot be zero\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize >= currentBondSize / self.lowerBoundDivisor, \"Bond size is too low\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(uint256(newBondSize) <= uint256(currentBondSize) * self.upperBoundMultiplier, \"Bond size is too high\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self.updatedBondSize != 0 && now >= self.effectiveUpdateTime) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self.previousBondSize = self.updatedBondSize;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self.previousExitBountySize = self.updatedExitBountySize;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(initialBondSize >= initialExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newBondSize >= newExitBountySize, \"The Bond size should be greater than or equal to the Bounty\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in BondSize.sol:\n\t- pragma solidity0.5.11 (BondSize.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/interfaces/IStateTransitionVerifier.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Different versions of Solidity is used in IStateTransitionVerifier.sol:\n\t- Version used: ['0.5.11', 'ABIEncoderV2']\n\t- IStateTransitionVerifier.sol#3 declares pragma solidity0.5.11\n\t- IStateTransitionVerifier.sol#4 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in IStateTransitionVerifier.sol:\n\t- pragma solidity0.5.11 (IStateTransitionVerifier.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isCorrectStateTransition(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes[] calldata inputTxs,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint16[] calldata outputIndexOfInputTxs\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool);\n",
                    "message": null
                }
            ]
        }
    },
    "plasma-contracts-2.0.0/plasma_framework/contracts/src/exits/interfaces/ISpendingCondition.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.11;\n",
                    "message": "Detected issues with version pragma in ISpendingCondition.sol:\n\t- pragma solidity0.5.11 (ISpendingCondition.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verify(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata spendingTx,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint16 inputIndex,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata witness\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external view returns (bool);\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/MultiSigWalletWithDailyLimit.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spentToday += txn.value;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txn.executed = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (!_confirmed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spentToday += txn.value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                Execution(transactionId);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ExecutionFailure(transactionId);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                txn.executed = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!_confirmed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_24"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "Contract locking ether found in MultiSigWalletWithDailyLimit.sol:\n\tContract MultiSigWalletWithDailyLimit has payable functions:\n\t - fallback (MultiSigWalletWithDailyLimit.sol#97-102)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet.external_call uses assembly (MultiSigWalletWithDailyLimit.sol#246-264)\n\t- MultiSigWalletWithDailyLimit.sol#248-263\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "MultiSigWallet.fallback (MultiSigWalletWithDailyLimit.sol#97-102) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 134,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWalletWithDailyLimit.sol#124-134) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint i=0; i<owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.length -= 1;\n\n        if (required > owners.length)\n\n            changeRequirement(owners.length);\n\n        OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWalletWithDailyLimit.sol#138-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        OwnerRemoval(owner);\n\n        OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWalletWithDailyLimit.sol#158-173) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 197,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n\n        public\n\n        returns (uint transactionId)\n\n    {\n\n        transactionId = addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWalletWithDailyLimit.sol#191-197) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function revokeConfirmation(uint transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWalletWithDailyLimit.sol#214-222) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": 321,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]])\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWalletWithDailyLimit.sol#313-321) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": 336,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWalletWithDailyLimit.sol#327-336) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        constant\n\n        returns (address[])\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWalletWithDailyLimit.sol#340-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n\n        public\n\n        constant\n\n        returns (address[] _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        _confirmations = new address[](count);\n\n        for (i=0; i<count; i++)\n\n            _confirmations[i] = confirmationsTemp[i];\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWalletWithDailyLimit.sol#351-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint[] _transactionIds)\n\n    {\n\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n            {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        _transactionIds = new uint[](to - from);\n\n        for (i=from; i<to; i++)\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWalletWithDailyLimit.sol#375-393) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function changeDailyLimit(uint _dailyLimit)\n\n        public\n\n        onlyWallet\n\n    {\n\n        dailyLimit = _dailyLimit;\n\n        DailyLimitChange(_dailyLimit);\n",
                    "message": "MultiSigWalletWithDailyLimit.changeDailyLimit (MultiSigWalletWithDailyLimit.sol#432-438) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function calcMaxWithdraw()\n\n        public\n\n        constant\n\n        returns (uint)\n\n    {\n\n        if (now > lastDay + 24 hours)\n\n            return dailyLimit;\n\n        if (dailyLimit < spentToday)\n\n            return 0;\n\n        return dailyLimit - spentToday;\n",
                    "message": "MultiSigWalletWithDailyLimit.calcMaxWithdraw (MultiSigWalletWithDailyLimit.sol#489-499) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in MultiSigWalletWithDailyLimit.sol:\n\t- pragma solidity^0.4.15 (MultiSigWalletWithDailyLimit.sol#3): it allows old versions\n\t- pragma solidity^0.4.15 (MultiSigWalletWithDailyLimit.sol#398): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n\n        public\n\n        validRequirement(_owners.length, _required)\n\n    {\n\n        for (uint i=0; i<_owners.length; i++) {\n\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\n\n            isOwner[_owners[i]] = true;\n\n        }\n\n        owners = _owners;\n\n        required = _required;\n",
                    "message": "Function 'MultiSigWallet.MultiSigWallet' (MultiSigWalletWithDailyLimit.sol#110-120) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_owners' of MultiSigWallet.MultiSigWallet (MultiSigWalletWithDailyLimit.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.MultiSigWallet (MultiSigWalletWithDailyLimit.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWalletWithDailyLimit.sol#177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet.external_call' (MultiSigWalletWithDailyLimit.sol#246-264) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": 428,
                    "vulnerability_code": "    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n\n        public\n\n        MultiSigWallet(_owners, _required)\n\n    {\n\n        dailyLimit = _dailyLimit;\n",
                    "message": "Function 'MultiSigWalletWithDailyLimit.MultiSigWalletWithDailyLimit' (MultiSigWalletWithDailyLimit.sol#423-428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": "Parameter '_dailyLimit' of MultiSigWalletWithDailyLimit.MultiSigWalletWithDailyLimit (MultiSigWalletWithDailyLimit.sol#423) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeDailyLimit(uint _dailyLimit)\n",
                    "message": "Parameter '_dailyLimit' of MultiSigWalletWithDailyLimit.changeDailyLimit (MultiSigWalletWithDailyLimit.sol#432) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcMaxWithdraw()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/Factory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function getInstantiationCount(address creator)\n\n        public\n\n        constant\n\n        returns (uint)\n\n    {\n\n        return instantiations[creator].length;\n",
                    "message": "Factory.getInstantiationCount (Factory.sol#26-32) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in Factory.sol:\n\t- pragma solidity^0.4.15 (Factory.sol#5): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getInstantiationCount(address creator)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/MultiSigWalletWithDailyLimitFactory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spentToday += txn.value;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txn.executed = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (!_confirmed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spentToday += txn.value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                Execution(transactionId);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ExecutionFailure(transactionId);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                txn.executed = false;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (!_confirmed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": 149,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "Contract locking ether found in MultiSigWalletWithDailyLimitFactory.sol:\n\tContract MultiSigWalletWithDailyLimit has payable functions:\n\t - fallback (MultiSigWalletWithDailyLimitFactory.sol#144-149)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet.external_call uses assembly (MultiSigWalletWithDailyLimitFactory.sol#293-311)\n\t- MultiSigWalletWithDailyLimitFactory.sol#295-310\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function getInstantiationCount(address creator)\n\n        public\n\n        constant\n\n        returns (uint)\n\n    {\n\n        return instantiations[creator].length;\n",
                    "message": "Factory.getInstantiationCount (MultiSigWalletWithDailyLimitFactory.sol#26-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": 149,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "MultiSigWallet.fallback (MultiSigWalletWithDailyLimitFactory.sol#144-149) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWalletWithDailyLimitFactory.sol#171-181) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint i=0; i<owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.length -= 1;\n\n        if (required > owners.length)\n\n            changeRequirement(owners.length);\n\n        OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWalletWithDailyLimitFactory.sol#185-200) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        OwnerRemoval(owner);\n\n        OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWalletWithDailyLimitFactory.sol#205-220) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n\n        public\n\n        returns (uint transactionId)\n\n    {\n\n        transactionId = addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWalletWithDailyLimitFactory.sol#238-244) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": 269,
                    "vulnerability_code": "    function revokeConfirmation(uint transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWalletWithDailyLimitFactory.sol#261-269) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]])\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWalletWithDailyLimitFactory.sol#360-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 383,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWalletWithDailyLimitFactory.sol#374-383) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        constant\n\n        returns (address[])\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWalletWithDailyLimitFactory.sol#387-393) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 414,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n\n        public\n\n        constant\n\n        returns (address[] _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        _confirmations = new address[](count);\n\n        for (i=0; i<count; i++)\n\n            _confirmations[i] = confirmationsTemp[i];\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWalletWithDailyLimitFactory.sol#398-414) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": 440,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint[] _transactionIds)\n\n    {\n\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n            {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        _transactionIds = new uint[](to - from);\n\n        for (i=from; i<to; i++)\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWalletWithDailyLimitFactory.sol#422-440) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": 485,
                    "vulnerability_code": "    function changeDailyLimit(uint _dailyLimit)\n\n        public\n\n        onlyWallet\n\n    {\n\n        dailyLimit = _dailyLimit;\n\n        DailyLimitChange(_dailyLimit);\n",
                    "message": "MultiSigWalletWithDailyLimit.changeDailyLimit (MultiSigWalletWithDailyLimitFactory.sol#479-485) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": 546,
                    "vulnerability_code": "    function calcMaxWithdraw()\n\n        public\n\n        constant\n\n        returns (uint)\n\n    {\n\n        if (now > lastDay + 24 hours)\n\n            return dailyLimit;\n\n        if (dailyLimit < spentToday)\n\n            return 0;\n\n        return dailyLimit - spentToday;\n",
                    "message": "MultiSigWalletWithDailyLimit.calcMaxWithdraw (MultiSigWalletWithDailyLimitFactory.sol#536-546) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": 572,
                    "vulnerability_code": "    function create(address[] _owners, uint _required, uint _dailyLimit)\n\n        public\n\n        returns (address wallet)\n\n    {\n\n        wallet = new MultiSigWalletWithDailyLimit(_owners, _required, _dailyLimit);\n\n        register(wallet);\n",
                    "message": "MultiSigWalletWithDailyLimitFactory.create (MultiSigWalletWithDailyLimitFactory.sol#566-572) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in MultiSigWalletWithDailyLimitFactory.sol:\n\t- pragma solidity^0.4.15 (MultiSigWalletWithDailyLimitFactory.sol#5): it allows old versions\n\t- pragma solidity^0.4.15 (MultiSigWalletWithDailyLimitFactory.sol#50): it allows old versions\n\t- pragma solidity^0.4.15 (MultiSigWalletWithDailyLimitFactory.sol#445): it allows old versions\n\t- pragma solidity^0.4.15 (MultiSigWalletWithDailyLimitFactory.sol#551): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 167,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n\n        public\n\n        validRequirement(_owners.length, _required)\n\n    {\n\n        for (uint i=0; i<_owners.length; i++) {\n\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\n\n            isOwner[_owners[i]] = true;\n\n        }\n\n        owners = _owners;\n\n        required = _required;\n",
                    "message": "Function 'MultiSigWallet.MultiSigWallet' (MultiSigWalletWithDailyLimitFactory.sol#157-167) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_owners' of MultiSigWallet.MultiSigWallet (MultiSigWalletWithDailyLimitFactory.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.MultiSigWallet (MultiSigWalletWithDailyLimitFactory.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWalletWithDailyLimitFactory.sol#224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet.external_call' (MultiSigWalletWithDailyLimitFactory.sol#293-311) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n\n        public\n\n        MultiSigWallet(_owners, _required)\n\n    {\n\n        dailyLimit = _dailyLimit;\n",
                    "message": "Function 'MultiSigWalletWithDailyLimit.MultiSigWalletWithDailyLimit' (MultiSigWalletWithDailyLimitFactory.sol#470-475) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": "Parameter '_dailyLimit' of MultiSigWalletWithDailyLimit.MultiSigWalletWithDailyLimit (MultiSigWalletWithDailyLimitFactory.sol#470) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeDailyLimit(uint _dailyLimit)\n",
                    "message": "Parameter '_dailyLimit' of MultiSigWalletWithDailyLimit.changeDailyLimit (MultiSigWalletWithDailyLimitFactory.sol#479) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": "Parameter '_owners' of MultiSigWalletWithDailyLimitFactory.create (MultiSigWalletWithDailyLimitFactory.sol#566) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": "Parameter '_required' of MultiSigWalletWithDailyLimitFactory.create (MultiSigWalletWithDailyLimitFactory.sol#566) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": "Parameter '_dailyLimit' of MultiSigWalletWithDailyLimitFactory.create (MultiSigWalletWithDailyLimitFactory.sol#566) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getInstantiationCount(address creator)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function calcMaxWithdraw()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required, uint _dailyLimit)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/MultiSigWallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "Contract locking ether found in MultiSigWallet.sol:\n\tContract MultiSigWallet has payable functions:\n\t - fallback (MultiSigWallet.sol#97-102)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet.external_call uses assembly (MultiSigWallet.sol#246-264)\n\t- MultiSigWallet.sol#248-263\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "MultiSigWallet.fallback (MultiSigWallet.sol#97-102) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 134,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWallet.sol#124-134) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint i=0; i<owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.length -= 1;\n\n        if (required > owners.length)\n\n            changeRequirement(owners.length);\n\n        OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWallet.sol#138-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        OwnerRemoval(owner);\n\n        OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWallet.sol#158-173) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": 197,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n\n        public\n\n        returns (uint transactionId)\n\n    {\n\n        transactionId = addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWallet.sol#191-197) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function revokeConfirmation(uint transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWallet.sol#214-222) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": 321,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]])\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWallet.sol#313-321) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": 336,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWallet.sol#327-336) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        constant\n\n        returns (address[])\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWallet.sol#340-346) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": 367,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n\n        public\n\n        constant\n\n        returns (address[] _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        _confirmations = new address[](count);\n\n        for (i=0; i<count; i++)\n\n            _confirmations[i] = confirmationsTemp[i];\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWallet.sol#351-367) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint[] _transactionIds)\n\n    {\n\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n            {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        _transactionIds = new uint[](to - from);\n\n        for (i=from; i<to; i++)\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWallet.sol#375-393) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in MultiSigWallet.sol:\n\t- pragma solidity^0.4.15 (MultiSigWallet.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n\n        public\n\n        validRequirement(_owners.length, _required)\n\n    {\n\n        for (uint i=0; i<_owners.length; i++) {\n\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\n\n            isOwner[_owners[i]] = true;\n\n        }\n\n        owners = _owners;\n\n        required = _required;\n",
                    "message": "Function 'MultiSigWallet.MultiSigWallet' (MultiSigWallet.sol#110-120) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_owners' of MultiSigWallet.MultiSigWallet (MultiSigWallet.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.MultiSigWallet (MultiSigWallet.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWallet.sol#177) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet.external_call' (MultiSigWallet.sol#246-264) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "  function setCompleted(uint completed) restricted {\n\n    last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#17-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "  function upgrade(address new_address) restricted {\n\n    Migrations upgraded = Migrations(new_address);\n\n    upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#21-24) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity^0.4.15 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": 15,
                    "vulnerability_code": "  function Migrations() {\n\n    owner = msg.sender;\n",
                    "message": "Function 'Migrations.Migrations' (Migrations.sol#13-15) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function upgrade(address new_address) restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function Migrations() {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function setCompleted(uint completed) restricted {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function upgrade(address new_address) restricted {\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/MultiSigWalletFactory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]])\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required)\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!isOwner[_owners[i]] && _owners[i] != 0);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (   pending && !transactions[i].executed\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                || executed && transactions[i].executed)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<count; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=from; i<to; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": 149,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "Contract locking ether found in MultiSigWalletFactory.sol:\n\tContract MultiSigWallet has payable functions:\n\t - fallback (MultiSigWalletFactory.sol#144-149)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet.external_call uses assembly (MultiSigWalletFactory.sol#293-311)\n\t- MultiSigWalletFactory.sol#295-310\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 32,
                    "vulnerability_code": "    function getInstantiationCount(address creator)\n\n        public\n\n        constant\n\n        returns (uint)\n\n    {\n\n        return instantiations[creator].length;\n",
                    "message": "Factory.getInstantiationCount (MultiSigWalletFactory.sol#26-32) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": 149,
                    "vulnerability_code": "    function()\n\n        payable\n\n    {\n\n        if (msg.value > 0)\n\n            Deposit(msg.sender, msg.value);\n",
                    "message": "MultiSigWallet.fallback (MultiSigWalletFactory.sol#144-149) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWalletFactory.sol#171-181) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 200,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint i=0; i<owners.length - 1; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        owners.length -= 1;\n\n        if (required > owners.length)\n\n            changeRequirement(owners.length);\n\n        OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWalletFactory.sol#185-200) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 220,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        OwnerRemoval(owner);\n\n        OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWalletFactory.sol#205-220) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n\n        public\n\n        returns (uint transactionId)\n\n    {\n\n        transactionId = addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWalletFactory.sol#238-244) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": 269,
                    "vulnerability_code": "    function revokeConfirmation(uint transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWalletFactory.sol#261-269) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": 368,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]])\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWalletFactory.sol#360-368) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 383,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint count)\n\n    {\n\n        for (uint i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n                count += 1;\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWalletFactory.sol#374-383) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": 393,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        constant\n\n        returns (address[])\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWalletFactory.sol#387-393) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": 414,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n\n        public\n\n        constant\n\n        returns (address[] _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<owners.length; i++)\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        _confirmations = new address[](count);\n\n        for (i=0; i<count; i++)\n\n            _confirmations[i] = confirmationsTemp[i];\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWalletFactory.sol#398-414) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": 440,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n\n        public\n\n        constant\n\n        returns (uint[] _transactionIds)\n\n    {\n\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n\n        uint count = 0;\n\n        uint i;\n\n        for (i=0; i<transactionCount; i++)\n\n            if (   pending && !transactions[i].executed\n\n                || executed && transactions[i].executed)\n\n            {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        _transactionIds = new uint[](to - from);\n\n        for (i=from; i<to; i++)\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWalletFactory.sol#422-440) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": 465,
                    "vulnerability_code": "    function create(address[] _owners, uint _required)\n\n        public\n\n        returns (address wallet)\n\n    {\n\n        wallet = new MultiSigWallet(_owners, _required);\n\n        register(wallet);\n",
                    "message": "MultiSigWalletFactory.create (MultiSigWalletFactory.sol#459-465) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in MultiSigWalletFactory.sol:\n\t- pragma solidity^0.4.15 (MultiSigWalletFactory.sol#5): it allows old versions\n\t- pragma solidity^0.4.15 (MultiSigWalletFactory.sol#50): it allows old versions\n\t- pragma solidity^0.4.15 (MultiSigWalletFactory.sol#445): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 167,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n\n        public\n\n        validRequirement(_owners.length, _required)\n\n    {\n\n        for (uint i=0; i<_owners.length; i++) {\n\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\n\n            isOwner[_owners[i]] = true;\n\n        }\n\n        owners = _owners;\n\n        required = _required;\n",
                    "message": "Function 'MultiSigWallet.MultiSigWallet' (MultiSigWalletFactory.sol#157-167) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_owners' of MultiSigWallet.MultiSigWallet (MultiSigWalletFactory.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.MultiSigWallet (MultiSigWalletFactory.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWalletFactory.sol#224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": 311,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet.external_call' (MultiSigWalletFactory.sol#293-311) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required)\n",
                    "message": "Parameter '_owners' of MultiSigWalletFactory.create (MultiSigWalletFactory.sol#459) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required)\n",
                    "message": "Parameter '_required' of MultiSigWalletFactory.create (MultiSigWalletFactory.sol#459) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getInstantiationCount(address creator)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isConfirmed(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getOwners()\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmations(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length - 1; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<transactionCount; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<_owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i=0; i<owners.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 5,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function MultiSigWallet(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function submitTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTransaction(address destination, uint value, bytes data)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address[] _confirmations)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint[] _transactionIds)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function create(address[] _owners, uint _required)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function()\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/TestCalls.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "\tfunction receive1uint(uint a) setMsgFields payable public {\n\n\t\tuint1 = a;\n",
                    "message": "Contract locking ether found in TestCalls.sol:\n\tContract TestCalls has payable functions:\n\t - receive1uint (TestCalls.sol#29-31)\n\t - receive2uints (TestCalls.sol#33-36)\n\t - receive1bytes (TestCalls.sol#38-40)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 31,
                    "vulnerability_code": "\tfunction receive1uint(uint a) setMsgFields payable public {\n\n\t\tuint1 = a;\n",
                    "message": "TestCalls.receive1uint (TestCalls.sol#29-31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 36,
                    "vulnerability_code": "\tfunction receive2uints(uint a, uint b) setMsgFields payable public {\n\n\t\tuint1 = a;\n\n\t\tuint2 = b;\n",
                    "message": "TestCalls.receive2uints (TestCalls.sol#33-36) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "\tfunction receive1bytes(bytes c) setMsgFields payable public {\n\n\t\tbyteArray1 = c;\n",
                    "message": "TestCalls.receive1bytes (TestCalls.sol#38-40) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "\tfunction nonPayable() setMsgFields public {\n",
                    "message": "TestCalls.nonPayable (TestCalls.sol#42-43) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in TestCalls.sol:\n\t- pragma solidity^0.4.15 (TestCalls.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 27,
                    "vulnerability_code": "\tfunction TestCalls() setMsgFields public {\n\n\t\t// This constructor will be used to test the creation via multisig wallet\n",
                    "message": "Function 'TestCalls.TestCalls' (TestCalls.sol#25-27) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TestCalls {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\tfunction receive1bytes(bytes c) setMsgFields payable public {\n",
                    "message": null
                }
            ]
        }
    },
    "MultiSigWallet-4776fd2c648c71eda48dcfbf740091284128ad8e/contracts/TestToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        totalSupply += _value;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function issueTokens(address _to, uint256 _value)\n\n        public\n\n    {\n\n        balances[_to] += _value;\n\n        totalSupply += _value;\n",
                    "message": "TestToken.issueTokens (TestToken.sol#35-40) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] -= _value;\n\n        balances[_to] += _value;\n\n        Transfer(msg.sender, _to, _value);\n\n        return true;\n",
                    "message": "TestToken.transfer (TestToken.sol#55-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": 81,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] += _value;\n\n        balances[_from] -= _value;\n\n        allowed[_from][msg.sender] -= _value;\n\n        Transfer(_from, _to, _value);\n\n        return true;\n",
                    "message": "TestToken.transferFrom (TestToken.sol#71-81) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        allowed[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n",
                    "message": "TestToken.approve (TestToken.sol#87-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n\n        constant\n\n        public\n\n        returns (uint256 remaining)\n\n    {\n\n        return allowed[_owner][_spender];\n",
                    "message": "TestToken.allowance (TestToken.sol#100-106) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 117,
                    "vulnerability_code": "    function balanceOf(address _owner)\n\n        constant\n\n        public\n\n        returns (uint256 balance)\n\n    {\n\n        return balances[_owner];\n",
                    "message": "TestToken.balanceOf (TestToken.sol#111-117) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": "Detected issues with version pragma in TestToken.sol:\n\t- pragma solidity^0.4.15 (TestToken.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function issueTokens(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of TestToken.issueTokens (TestToken.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function issueTokens(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of TestToken.issueTokens (TestToken.sol#35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)\n",
                    "message": "Parameter '_to' of TestToken.transfer (TestToken.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)\n",
                    "message": "Parameter '_value' of TestToken.transfer (TestToken.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_from' of TestToken.transferFrom (TestToken.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of TestToken.transferFrom (TestToken.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of TestToken.transferFrom (TestToken.sol#71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of TestToken.approve (TestToken.sol#87) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of TestToken.approve (TestToken.sol#87) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of TestToken.allowance (TestToken.sol#100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of TestToken.allowance (TestToken.sol#100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of TestToken.balanceOf (TestToken.sol#111) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.15;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) allowed;\n",
                    "message": null
                }
            ]
        }
    }
}