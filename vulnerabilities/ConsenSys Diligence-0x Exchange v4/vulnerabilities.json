{
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-libs/contracts/test/TestLibMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibMath.sol#38-42)\n\t- TestLibMath.sol#39-41\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in TestLibMath.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- TestLibMath.sol#21 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#47 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#80 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#145 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#205 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#433 declares pragma solidity^0.5.9\n\t- TestLibMath.sol#434 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": 454,
                    "vulnerability_code": "    function safeGetPartialAmountFloor(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.safeGetPartialAmountFloor(numerator, denominator, target);\n",
                    "message": "TestLibMath.safeGetPartialAmountFloor (TestLibMath.sol#444-454) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function safeGetPartialAmountCeil(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.safeGetPartialAmountCeil(numerator, denominator, target);\n",
                    "message": "TestLibMath.safeGetPartialAmountCeil (TestLibMath.sol#462-472) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": 489,
                    "vulnerability_code": "    function getPartialAmountFloor(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.getPartialAmountFloor(numerator, denominator, target);\n",
                    "message": "TestLibMath.getPartialAmountFloor (TestLibMath.sol#479-489) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 506,
                    "vulnerability_code": "    function getPartialAmountCeil(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 partialAmount)\n\n    {\n\n        return LibMath.getPartialAmountCeil(numerator, denominator, target);\n",
                    "message": "TestLibMath.getPartialAmountCeil (TestLibMath.sol#496-506) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function isRoundingErrorFloor(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (bool isError)\n\n    {\n\n        return LibMath.isRoundingErrorFloor(numerator, denominator, target);\n",
                    "message": "TestLibMath.isRoundingErrorFloor (TestLibMath.sol#513-523) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": 540,
                    "vulnerability_code": "    function isRoundingErrorCeil(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        public\n\n        pure\n\n        returns (bool isError)\n\n    {\n\n        return LibMath.isRoundingErrorCeil(numerator, denominator, target);\n",
                    "message": "TestLibMath.isRoundingErrorCeil (TestLibMath.sol#530-540) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibMath.sol:\n\t- pragma solidity^0.5.9 (TestLibMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#145): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#205): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibMath.sol#433): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (TestLibMath.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (TestLibMath.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrors.DivisionByZeroError' (TestLibMath.sol#159-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrors.RoundingError' (TestLibMath.sol#167-182) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-libs/contracts/src/IWallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IWallet.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IWallet.sol#21 declares pragma solidity^0.5.9\n\t- IWallet.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IWallet.sol:\n\t- pragma solidity^0.5.9 (IWallet.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant LEGACY_WALLET_MAGIC_VALUE = 0xb0671381;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-libs/contracts/src/LibMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibMath.sol#38-42)\n\t- LibMath.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibMath.sol:\n\t- pragma solidity^0.5.9 (LibMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#145): it allows old versions\n\t- pragma solidity^0.5.9 (LibMath.sol#205): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibMath.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibMath.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": 165,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrors.DivisionByZeroError' (LibMath.sol#159-165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 182,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrors.RoundingError' (LibMath.sol#167-182) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-libs/contracts/src/LibMathRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibMathRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibMathRichErrors.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 23,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrors.DivisionByZeroError' (LibMathRichErrors.sol#17-23) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": 40,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrors.RoundingError' (LibMathRichErrors.sol#25-40) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange/contracts/src/interfaces/IAssetProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxy.sol:\n\t- pragma solidity^0.5.9 (IAssetProxy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange/contracts/src/interfaces/IProtocolFees.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IProtocolFees.sol:\n\t- pragma solidity^0.5.9 (IProtocolFees.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange/contracts/src/interfaces/ITransferSimulator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in ITransferSimulator.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- ITransferSimulator.sol#21 declares pragma solidity^0.5.9\n\t- ITransferSimulator.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function simulateDispatchTransferFromCalls(\n\n        bytes[] memory assetData,\n\n        address[] memory fromAddresses,\n\n        address[] memory toAddresses,\n\n        uint256[] memory amounts\n\n    )\n",
                    "message": "ITransferSimulator.simulateDispatchTransferFromCalls (ITransferSimulator.sol#38-44) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ITransferSimulator.sol:\n\t- pragma solidity^0.5.9 (ITransferSimulator.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange/contracts/src/interfaces/IAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (IAssetProxyDispatcher.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/coordinator/contracts/src/MixinSignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNATURE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            hash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_ORIGIN_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedOrigin\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_APPROVAL_SIGNATURE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transactionHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approverAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_32"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (MixinSignatureValidator.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (MixinSignatureValidator.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (MixinSignatureValidator.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (MixinSignatureValidator.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (MixinSignatureValidator.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (MixinSignatureValidator.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (MixinSignatureValidator.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (MixinSignatureValidator.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (MixinSignatureValidator.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (MixinSignatureValidator.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (MixinSignatureValidator.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (MixinSignatureValidator.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (MixinSignatureValidator.sol#84-88)\n\t- MixinSignatureValidator.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (MixinSignatureValidator.sol#122-127)\n\t- MixinSignatureValidator.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (MixinSignatureValidator.sol#132-137)\n\t- MixinSignatureValidator.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (MixinSignatureValidator.sol#143-243)\n\t- MixinSignatureValidator.sol#148-153\n\t- MixinSignatureValidator.sol#176-206\n\t- MixinSignatureValidator.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (MixinSignatureValidator.sol#284-312)\n\t- MixinSignatureValidator.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (MixinSignatureValidator.sol#317-337)\n\t- MixinSignatureValidator.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (MixinSignatureValidator.sol#354-378)\n\t- MixinSignatureValidator.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (MixinSignatureValidator.sol#384-422)\n\t- MixinSignatureValidator.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (MixinSignatureValidator.sol#428-447)\n\t- MixinSignatureValidator.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (MixinSignatureValidator.sol#453-471)\n\t- MixinSignatureValidator.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (MixinSignatureValidator.sol#494-516)\n\t- MixinSignatureValidator.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (MixinSignatureValidator.sol#523-527)\n\t- MixinSignatureValidator.sol#524-526\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": 575,
                    "vulnerability_code": "    function getSignerAddress(bytes32 hash, bytes memory signature)\n\n        public\n\n        pure\n",
                    "message": "ICoordinatorSignatureValidator.getSignerAddress (MixinSignatureValidator.sol#572-575) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 807,
                    "vulnerability_code": "    function getSignerAddress(bytes32 hash, bytes memory signature)\n\n        public\n\n        pure\n\n        returns (address signerAddress)\n\n    {\n\n        uint256 signatureLength = signature.length;\n\n        if (signatureLength == 0) {\n\n            LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n                LibCoordinatorRichErrors.SignatureErrorCodes.INVALID_LENGTH,\n\n                hash,\n\n                signature\n\n            ));\n\n        }\n\n\n\n        // Pop last byte off of signature byte array.\n\n        uint8 signatureTypeRaw = uint8(signature[signature.length - 1]);\n\n\n\n        // Ensure signature is supported\n\n        if (signatureTypeRaw >= uint8(SignatureType.NSignatureTypes)) {\n\n            LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n                LibCoordinatorRichErrors.SignatureErrorCodes.UNSUPPORTED,\n\n                hash,\n\n                signature\n\n            ));\n\n        }\n\n\n\n        SignatureType signatureType = SignatureType(signatureTypeRaw);\n\n\n\n        // Always illegal signature.\n\n        // This is always an implicit option since a signer can create a\n\n        // signature array with invalid type or length. We may as well make\n\n        // it an explicit option. This aids testing and analysis. It is\n\n        // also the initialization value for the enum type.\n\n        if (signatureType == SignatureType.Illegal) {\n\n            LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n                LibCoordinatorRichErrors.SignatureErrorCodes.ILLEGAL,\n\n                hash,\n\n                signature\n\n            ));\n\n\n\n        // Always invalid signature.\n\n        // Like Illegal, this is always implicitly available and therefore\n\n        // offered explicitly. It can be implicitly created by providing\n\n        // a correctly formatted but incorrect signature.\n\n        } else if (signatureType == SignatureType.Invalid) {\n\n            LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n                LibCoordinatorRichErrors.SignatureErrorCodes.INVALID,\n\n                hash,\n\n                signature\n\n            ));\n\n\n\n        // Signature using EIP712\n\n        } else if (signatureType == SignatureType.EIP712) {\n\n            if (signatureLength != 66) {\n\n                LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n                    LibCoordinatorRichErrors.SignatureErrorCodes.INVALID_LENGTH,\n\n                    hash,\n\n                    signature\n\n                ));\n\n            }\n\n            uint8 v = uint8(signature[0]);\n\n            bytes32 r = signature.readBytes32(1);\n\n            bytes32 s = signature.readBytes32(33);\n\n            signerAddress = ecrecover(\n\n                hash,\n\n                v,\n\n                r,\n\n                s\n\n            );\n\n            return signerAddress;\n\n\n\n        // Signed using web3.eth_sign\n\n        } else if (signatureType == SignatureType.EthSign) {\n\n            if (signatureLength != 66) {\n\n                LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n                    LibCoordinatorRichErrors.SignatureErrorCodes.INVALID_LENGTH,\n\n                    hash,\n\n                    signature\n\n                ));\n\n            }\n\n            uint8 v = uint8(signature[0]);\n\n            bytes32 r = signature.readBytes32(1);\n\n            bytes32 s = signature.readBytes32(33);\n\n            signerAddress = ecrecover(\n\n                keccak256(abi.encodePacked(\n\n                    \"\\x19Ethereum Signed Message:\\n32\",\n\n                    hash\n\n                )),\n\n                v,\n\n                r,\n\n                s\n\n            );\n\n            return signerAddress;\n\n        }\n\n\n\n        // Anything else is illegal (We do not return false because\n\n        // the signature may actually be valid, just not in a format\n\n        // that we currently support. In this case returning false\n\n        // may lead the caller to incorrectly believe that the\n\n        // signature was invalid.)\n\n        LibRichErrors.rrevert(LibCoordinatorRichErrors.SignatureError(\n\n            LibCoordinatorRichErrors.SignatureErrorCodes.UNSUPPORTED,\n\n            hash,\n\n            signature\n\n        ));\n",
                    "message": "MixinSignatureValidator.getSignerAddress (MixinSignatureValidator.sol#702-807) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinSignatureValidator.sol:\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#550): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#598): it allows old versions\n\t- pragma solidity^0.5.9 (MixinSignatureValidator.sol#688): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (MixinSignatureValidator.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (MixinSignatureValidator.sol#78-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": 637,
                    "vulnerability_code": "    function SignatureError(\n\n        SignatureErrorCodes errorCode,\n\n        bytes32 hash,\n\n        bytes memory signature\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNATURE_ERROR_SELECTOR,\n\n            errorCode,\n\n            hash,\n\n            signature\n\n        );\n",
                    "message": "Function 'LibCoordinatorRichErrors.SignatureError' (MixinSignatureValidator.sol#622-637) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 639,
                    "vulnerability_to_line": 650,
                    "vulnerability_code": "    function InvalidOriginError(\n\n        address expectedOrigin\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_ORIGIN_ERROR_SELECTOR,\n\n            expectedOrigin\n\n        );\n",
                    "message": "Function 'LibCoordinatorRichErrors.InvalidOriginError' (MixinSignatureValidator.sol#639-650) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": 665,
                    "vulnerability_code": "    function InvalidApprovalSignatureError(\n\n        bytes32 transactionHash,\n\n        address approverAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_APPROVAL_SIGNATURE_ERROR_SELECTOR,\n\n            transactionHash,\n\n            approverAddress\n\n        );\n",
                    "message": "Function 'LibCoordinatorRichErrors.InvalidApprovalSignatureError' (MixinSignatureValidator.sol#652-665) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x779c5223;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa458d7ff;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 619,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xd789b640;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/coordinator/contracts/src/libs/LibCoordinatorRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNATURE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            hash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_ORIGIN_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedOrigin\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_APPROVAL_SIGNATURE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transactionHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approverAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibCoordinatorRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibCoordinatorRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function SignatureError(\n\n        SignatureErrorCodes errorCode,\n\n        bytes32 hash,\n\n        bytes memory signature\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNATURE_ERROR_SELECTOR,\n\n            errorCode,\n\n            hash,\n\n            signature\n\n        );\n",
                    "message": "Function 'LibCoordinatorRichErrors.SignatureError' (LibCoordinatorRichErrors.sol#45-60) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function InvalidOriginError(\n\n        address expectedOrigin\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_ORIGIN_ERROR_SELECTOR,\n\n            expectedOrigin\n\n        );\n",
                    "message": "Function 'LibCoordinatorRichErrors.InvalidOriginError' (LibCoordinatorRichErrors.sol#62-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function InvalidApprovalSignatureError(\n\n        bytes32 transactionHash,\n\n        address approverAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_APPROVAL_SIGNATURE_ERROR_SELECTOR,\n\n            transactionHash,\n\n            approverAddress\n\n        );\n",
                    "message": "Function 'LibCoordinatorRichErrors.InvalidApprovalSignatureError' (LibCoordinatorRichErrors.sol#75-88) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x779c5223;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa458d7ff;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xd789b640;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/coordinator/contracts/src/registry/CoordinatorRegistry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MixinCoordinatorRegistryCore()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in CoordinatorRegistry.sol:\n\t- pragma solidity^0.5.9 (CoordinatorRegistry.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (CoordinatorRegistry.sol#66): it allows old versions\n\t- pragma solidity^0.5.9 (CoordinatorRegistry.sol#115): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/coordinator/contracts/src/registry/MixinCoordinatorRegistryCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinCoordinatorRegistryCore.sol:\n\t- pragma solidity^0.5.9 (MixinCoordinatorRegistryCore.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinCoordinatorRegistryCore.sol#66): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/coordinator/contracts/src/registry/interfaces/ICoordinatorRegistryCore.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ICoordinatorRegistryCore.sol:\n\t- pragma solidity^0.5.9 (ICoordinatorRegistryCore.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/coordinator/contracts/src/interfaces/ICoordinatorSignatureValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 46,
                    "vulnerability_code": "    function getSignerAddress(bytes32 hash, bytes memory signature)\n\n        public\n\n        pure\n",
                    "message": "ICoordinatorSignatureValidator.getSignerAddress (ICoordinatorSignatureValidator.sol#43-46) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ICoordinatorSignatureValidator.sol:\n\t- pragma solidity^0.5.9 (ICoordinatorSignatureValidator.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/broker/contracts/src/libs/LibBrokerRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_FROM_ADDRESS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AMOUNTS_LENGTH_MUST_EQUAL_ONE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amountsLength\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TOO_FEW_BROKER_ASSETS_PROVIDED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numBrokeredAssets\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_FUNCTION_SELECTOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_ERC_1155_PROXY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibBrokerRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibBrokerRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function InvalidFromAddressError(\n\n        address from\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_FROM_ADDRESS_ERROR_SELECTOR,\n\n            from\n\n        );\n",
                    "message": "Function 'LibBrokerRichErrors.InvalidFromAddressError' (LibBrokerRichErrors.sol#47-58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function AmountsLengthMustEqualOneError(\n\n        uint256 amountsLength\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AMOUNTS_LENGTH_MUST_EQUAL_ONE_ERROR_SELECTOR,\n\n            amountsLength\n\n        );\n",
                    "message": "Function 'LibBrokerRichErrors.AmountsLengthMustEqualOneError' (LibBrokerRichErrors.sol#60-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 84,
                    "vulnerability_code": "    function TooFewBrokerAssetsProvidedError(\n\n        uint256 numBrokeredAssets\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TOO_FEW_BROKER_ASSETS_PROVIDED_ERROR_SELECTOR,\n\n            numBrokeredAssets\n\n        );\n",
                    "message": "Function 'LibBrokerRichErrors.TooFewBrokerAssetsProvidedError' (LibBrokerRichErrors.sol#73-84) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": 97,
                    "vulnerability_code": "    function InvalidFunctionSelectorError(\n\n        bytes4 selector\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_FUNCTION_SELECTOR_ERROR_SELECTOR,\n\n            selector\n\n        );\n",
                    "message": "Function 'LibBrokerRichErrors.InvalidFunctionSelectorError' (LibBrokerRichErrors.sol#86-97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": 110,
                    "vulnerability_code": "    function OnlyERC1155ProxyError(\n\n        address sender\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_ERC_1155_PROXY_ERROR_SELECTOR,\n\n            sender\n\n        );\n",
                    "message": "Function 'LibBrokerRichErrors.OnlyERC1155ProxyError' (LibBrokerRichErrors.sol#99-110) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x906bfb3c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xba9be200;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x55272586;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x540943f1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xccc529af;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/broker/contracts/src/interfaces/IGodsUnchained.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IGodsUnchained.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IGodsUnchained.sol#21 declares pragma solidity^0.5.9\n\t- IGodsUnchained.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IGodsUnchained.sol:\n\t- pragma solidity^0.5.9 (IGodsUnchained.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint16 proto, uint8 quality);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/broker/contracts/src/interfaces/IPropertyValidator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IPropertyValidator.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IPropertyValidator.sol#21 declares pragma solidity^0.5.9\n\t- IPropertyValidator.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IPropertyValidator.sol:\n\t- pragma solidity^0.5.9 (IPropertyValidator.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/test/DummyMultipleReturnERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        DummyERC20Token(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= MAX_MINT_AMOUNT,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"VALUE_TOO_LARGE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_TRANSFER_SHOULD_THROW",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/test/DummyNoReturnERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        DummyERC20Token(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= MAX_MINT_AMOUNT,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"VALUE_TOO_LARGE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 749,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 750,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 756,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 793,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 768,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/test/TestLibERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(0).approve.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            spender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(0).transfer.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(0).transferFrom.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                IERC20Token(0).allowance.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owner,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 764,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            )\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                IERC20Token(0).balanceOf.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            )\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 955,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 956,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        target = new TestLibERC20TokenTarget();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenDecimals = uint8(LibBytes.readUint256(resultData, 0));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance_ = LibBytes.readUint256(resultData, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 768,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance = LibBytes.readUint256(resultData, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_36"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibERC20Token.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestLibERC20Token.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestLibERC20Token.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestLibERC20Token.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestLibERC20Token.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestLibERC20Token.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestLibERC20Token.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestLibERC20Token.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestLibERC20Token.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestLibERC20Token.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestLibERC20Token.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestLibERC20Token.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": 925,
                    "vulnerability_code": "    function _execute() private view {\n\n        if (_shouldRevert) {\n\n            bytes memory revertData = _revertData;\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        bytes memory returnData = _returnData;\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "TestLibERC20TokenTarget._execute (TestLibERC20Token.sol#918-925) is declared view but contains assembly code\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance\n",
                    "message": "LibERC20Token.approve.allowance (local variable @ TestLibERC20Token.sol#656) shadows:\n\t- LibERC20Token.allowance (function @ TestLibERC20Token.sol#754-769)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibERC20Token.sol#38-42)\n\t- TestLibERC20Token.sol#39-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestLibERC20Token.sol#122-127)\n\t- TestLibERC20Token.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestLibERC20Token.sol#132-137)\n\t- TestLibERC20Token.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestLibERC20Token.sol#143-243)\n\t- TestLibERC20Token.sol#148-153\n\t- TestLibERC20Token.sol#176-206\n\t- TestLibERC20Token.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestLibERC20Token.sol#284-312)\n\t- TestLibERC20Token.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestLibERC20Token.sol#317-337)\n\t- TestLibERC20Token.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestLibERC20Token.sol#354-378)\n\t- TestLibERC20Token.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestLibERC20Token.sol#384-422)\n\t- TestLibERC20Token.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestLibERC20Token.sol#428-447)\n\t- TestLibERC20Token.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestLibERC20Token.sol#453-471)\n\t- TestLibERC20Token.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestLibERC20Token.sol#494-516)\n\t- TestLibERC20Token.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestLibERC20Token.sol#523-527)\n\t- TestLibERC20Token.sol#524-526\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": 925,
                    "vulnerability_code": "    function _execute() private view {\n\n        if (_shouldRevert) {\n\n            bytes memory revertData = _revertData;\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        bytes memory returnData = _returnData;\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "TestLibERC20TokenTarget._execute uses assembly (TestLibERC20Token.sol#918-925)\n\t- TestLibERC20Token.sol#921\n\t- TestLibERC20Token.sol#924\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibERC20Token.sol:\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#550): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#640): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#839): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibERC20Token.sol#948): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 746,
                    "vulnerability_code": "    function decimals(address token)\n\n        internal\n\n        view\n\n        returns (uint8 tokenDecimals)\n\n    {\n\n        tokenDecimals = 18;\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(DECIMALS_CALL_DATA);\n\n        if (didSucceed && resultData.length == 32) {\n\n            tokenDecimals = uint8(LibBytes.readUint256(resultData, 0));\n\n        }\n",
                    "message": "Low level call in LibERC20Token.decimals (TestLibERC20Token.sol#736-746):\n\t-(didSucceed,resultData) = token.staticcall(DECIMALS_CALL_DATA) TestLibERC20Token.sol#742\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": 769,
                    "vulnerability_code": "    function allowance(address token, address owner, address spender)\n\n        internal\n\n        view\n\n        returns (uint256 allowance_)\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(\n\n            abi.encodeWithSelector(\n\n                IERC20Token(0).allowance.selector,\n\n                owner,\n\n                spender\n\n            )\n\n        );\n\n        if (didSucceed && resultData.length == 32) {\n\n            allowance_ = LibBytes.readUint256(resultData, 0);\n\n        }\n",
                    "message": "Low level call in LibERC20Token.allowance (TestLibERC20Token.sol#754-769):\n\t-(didSucceed,resultData) = token.staticcall(abi.encodeWithSelector(IERC20Token(0).allowance.selector,owner,spender)) TestLibERC20Token.sol#759-765\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": 790,
                    "vulnerability_code": "    function balanceOf(address token, address owner)\n\n        internal\n\n        view\n\n        returns (uint256 balance)\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(\n\n            abi.encodeWithSelector(\n\n                IERC20Token(0).balanceOf.selector,\n\n                owner\n\n            )\n\n        );\n\n        if (didSucceed && resultData.length == 32) {\n\n            balance = LibBytes.readUint256(resultData, 0);\n\n        }\n",
                    "message": "Low level call in LibERC20Token.balanceOf (TestLibERC20Token.sol#776-790):\n\t-(didSucceed,resultData) = token.staticcall(abi.encodeWithSelector(IERC20Token(0).balanceOf.selector,owner)) TestLibERC20Token.sol#781-786\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": 816,
                    "vulnerability_code": "    function _callWithOptionalBooleanResult(\n\n        address target,\n\n        bytes memory callData\n\n    )\n\n        private\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = target.call(callData);\n\n        if (didSucceed) {\n\n            if (resultData.length == 0) {\n\n                return;\n\n            }\n\n            if (resultData.length == 32) {\n\n                uint256 result = LibBytes.readUint256(resultData, 0);\n\n                if (result == 1) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        LibRichErrors.rrevert(resultData);\n",
                    "message": "Low level call in LibERC20Token._callWithOptionalBooleanResult (TestLibERC20Token.sol#797-816):\n\t-(didSucceed,resultData) = target.call(callData) TestLibERC20Token.sol#803\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibERC20Token.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestLibERC20Token.sol#82-88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": 816,
                    "vulnerability_code": "    function _callWithOptionalBooleanResult(\n\n        address target,\n\n        bytes memory callData\n\n    )\n\n        private\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = target.call(callData);\n\n        if (didSucceed) {\n\n            if (resultData.length == 0) {\n\n                return;\n\n            }\n\n            if (resultData.length == 32) {\n\n                uint256 result = LibBytes.readUint256(resultData, 0);\n\n                if (result == 1) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        LibRichErrors.rrevert(resultData);\n",
                    "message": "Function 'LibERC20Token._callWithOptionalBooleanResult' (TestLibERC20Token.sol#797-816) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 918,
                    "vulnerability_to_line": 925,
                    "vulnerability_code": "    function _execute() private view {\n\n        if (_shouldRevert) {\n\n            bytes memory revertData = _revertData;\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        bytes memory returnData = _returnData;\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "Function 'TestLibERC20TokenTarget._execute' (TestLibERC20Token.sol#918-925) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 640,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 839,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 948,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant private DECIMALS_CALL_DATA = hex\"313ce567\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _shouldRevert;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes private _revertData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes private _returnData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 705,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(DECIMALS_CALL_DATA);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = target.call(callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBehavior(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 959,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function testApprove(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 866,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata revertData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 867,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata returnData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 872,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _revertData = revertData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _returnData = returnData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 961,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata revertData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata returnData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata returnData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address spender,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 968,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        target.setBehavior(shouldRevert, revertData, returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 968,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        target.setBehavior(shouldRevert, revertData, returnData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        LibERC20Token.approve(address(target), spender, allowance);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        LibERC20Token.approve(address(target), spender, allowance);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        LibERC20Token.approve(address(target), spender, allowance);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 969,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        LibERC20Token.approve(address(target), spender, allowance);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/test/DummyERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= MAX_MINT_AMOUNT,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"VALUE_TOO_LARGE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/test/TestLibERC20TokenTarget.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function _execute() private view {\n\n        if (_shouldRevert) {\n\n            bytes memory revertData = _revertData;\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        bytes memory returnData = _returnData;\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "TestLibERC20TokenTarget._execute (TestLibERC20TokenTarget.sol#100-107) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function _execute() private view {\n\n        if (_shouldRevert) {\n\n            bytes memory revertData = _revertData;\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        bytes memory returnData = _returnData;\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "TestLibERC20TokenTarget._execute uses assembly (TestLibERC20TokenTarget.sol#100-107)\n\t- TestLibERC20TokenTarget.sol#103\n\t- TestLibERC20TokenTarget.sol#106\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibERC20TokenTarget.sol:\n\t- pragma solidity^0.5.9 (TestLibERC20TokenTarget.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function _execute() private view {\n\n        if (_shouldRevert) {\n\n            bytes memory revertData = _revertData;\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        bytes memory returnData = _returnData;\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "Function 'TestLibERC20TokenTarget._execute' (TestLibERC20TokenTarget.sol#100-107) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _shouldRevert;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes private _revertData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes private _returnData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBehavior(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata revertData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata returnData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _revertData = revertData;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _returnData = returnData;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/test/UntransferrableDummyERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 659,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 730,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _decimals,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _totalSupply\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        DummyERC20Token(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _symbol,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 532,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 533,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 535,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 541,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _value <= MAX_MINT_AMOUNT,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"VALUE_TOO_LARGE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 756,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            false,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TRANSFER_DISABLED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE",
                    "vulnerability_from_line": 747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setBalance(address _target, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/WETH9.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(allowance[src][msg.sender] >= wad);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance[src][msg.sender] -= wad;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8  public decimals = 18;\n",
                    "message": "WETH9.decimals should be constant (WETH9.sol#25)\nWETH9.name should be constant (WETH9.sol#23)\nWETH9.symbol should be constant (WETH9.sol#24)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function withdraw(uint wad) public {\n\n        require(balanceOf[msg.sender] >= wad);\n\n        balanceOf[msg.sender] -= wad;\n\n        msg.sender.transfer(wad);\n\n        emit Withdrawal(msg.sender, wad);\n",
                    "message": "WETH9.withdraw (WETH9.sol#42-47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 51,
                    "vulnerability_code": "    function totalSupply() public view returns (uint) {\n\n        return address(this).balance;\n",
                    "message": "WETH9.totalSupply (WETH9.sol#49-51) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function approve(address guy, uint wad) public returns (bool) {\n\n        allowance[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n",
                    "message": "WETH9.approve (WETH9.sol#53-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function transfer(address dst, uint wad) public returns (bool) {\n\n        return transferFrom(msg.sender, dst, wad);\n",
                    "message": "WETH9.transfer (WETH9.sol#59-61) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in WETH9.sol:\n\t- pragma solidity^0.5.9 (WETH9.sol#19): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/UnlimitedAllowanceERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_18"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply (UnlimitedAllowanceERC20Token.sol#119) is never initialized. It is used in:\n\t- totalSupply (UnlimitedAllowanceERC20Token.sol#208-214)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance = allowed[_from][msg.sender];\n",
                    "message": "UnlimitedAllowanceERC20Token.transferFrom.allowance (local variable @ UnlimitedAllowanceERC20Token.sol#279) shadows:\n\t- ERC20Token.allowance (function @ UnlimitedAllowanceERC20Token.sol#230-236)\n\t- IERC20Token.allowance (function @ UnlimitedAllowanceERC20Token.sol#85-88)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply should be constant (UnlimitedAllowanceERC20Token.sol#119)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in UnlimitedAllowanceERC20Token.sol:\n\t- pragma solidity^0.5.9 (UnlimitedAllowanceERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (UnlimitedAllowanceERC20Token.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (UnlimitedAllowanceERC20Token.sol#259): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (UnlimitedAllowanceERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (UnlimitedAllowanceERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (UnlimitedAllowanceERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (UnlimitedAllowanceERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (UnlimitedAllowanceERC20Token.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (UnlimitedAllowanceERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (UnlimitedAllowanceERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "Variable 'ERC20Token._totalSupply' (UnlimitedAllowanceERC20Token.sol#119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of UnlimitedAllowanceERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of UnlimitedAllowanceERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#273) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of UnlimitedAllowanceERC20Token.transferFrom (UnlimitedAllowanceERC20Token.sol#274) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/ERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply (ERC20Token.sol#119) is never initialized. It is used in:\n\t- totalSupply (ERC20Token.sol#208-214)\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "ERC20Token._totalSupply should be constant (ERC20Token.sol#119)\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC20Token.sol:\n\t- pragma solidity^0.5.9 (ERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Token.sol#111): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (ERC20Token.sol#125) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (ERC20Token.sol#156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (ERC20Token.sol#157) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (ERC20Token.sol#158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (ERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (ERC20Token.sol#193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (ERC20Token.sol#219) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (ERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (ERC20Token.sol#230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "Variable 'ERC20Token._totalSupply' (ERC20Token.sol#119) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/ZRXToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] += _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Transfer(msg.sender, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else { return false; }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] += _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Transfer(_from, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else { return false; }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (balances[_from] >= _value\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && allowance >= _value\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && balances[_to] + _value >= balances[_to]\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] += _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (allowance < MAX_UINT) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                allowed[_from][msg.sender] -= _value;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            Transfer(_from, _to, _value);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() constant returns (uint supply) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint balance) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool success) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint _value) returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender) constant returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint) balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint)) allowed;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant MAX_UINT = 2**256 - 1;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/LibERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(0).approve.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            spender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 663,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(0).transfer.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(0).transferFrom.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 725,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 760,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                IERC20Token(0).allowance.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owner,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 763,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 764,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            )\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 782,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 783,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                IERC20Token(0).balanceOf.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            )\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 743,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenDecimals = uint8(LibBytes.readUint256(resultData, 0));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 766,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance_ = LibBytes.readUint256(resultData, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 768,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance = LibBytes.readUint256(resultData, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_33"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibERC20Token.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (LibERC20Token.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (LibERC20Token.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (LibERC20Token.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (LibERC20Token.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (LibERC20Token.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (LibERC20Token.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (LibERC20Token.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (LibERC20Token.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (LibERC20Token.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (LibERC20Token.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (LibERC20Token.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance\n",
                    "message": "LibERC20Token.approve.allowance (local variable @ LibERC20Token.sol#656) shadows:\n\t- LibERC20Token.allowance (function @ LibERC20Token.sol#754-769)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibERC20Token.sol#38-42)\n\t- LibERC20Token.sol#39-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (LibERC20Token.sol#122-127)\n\t- LibERC20Token.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (LibERC20Token.sol#132-137)\n\t- LibERC20Token.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (LibERC20Token.sol#143-243)\n\t- LibERC20Token.sol#148-153\n\t- LibERC20Token.sol#176-206\n\t- LibERC20Token.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (LibERC20Token.sol#284-312)\n\t- LibERC20Token.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (LibERC20Token.sol#317-337)\n\t- LibERC20Token.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (LibERC20Token.sol#354-378)\n\t- LibERC20Token.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (LibERC20Token.sol#384-422)\n\t- LibERC20Token.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (LibERC20Token.sol#428-447)\n\t- LibERC20Token.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (LibERC20Token.sol#453-471)\n\t- LibERC20Token.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (LibERC20Token.sol#494-516)\n\t- LibERC20Token.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (LibERC20Token.sol#523-527)\n\t- LibERC20Token.sol#524-526\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibERC20Token.sol:\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#550): it allows old versions\n\t- pragma solidity^0.5.9 (LibERC20Token.sol#640): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 746,
                    "vulnerability_code": "    function decimals(address token)\n\n        internal\n\n        view\n\n        returns (uint8 tokenDecimals)\n\n    {\n\n        tokenDecimals = 18;\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(DECIMALS_CALL_DATA);\n\n        if (didSucceed && resultData.length == 32) {\n\n            tokenDecimals = uint8(LibBytes.readUint256(resultData, 0));\n\n        }\n",
                    "message": "Low level call in LibERC20Token.decimals (LibERC20Token.sol#736-746):\n\t-(didSucceed,resultData) = token.staticcall(DECIMALS_CALL_DATA) LibERC20Token.sol#742\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 754,
                    "vulnerability_to_line": 769,
                    "vulnerability_code": "    function allowance(address token, address owner, address spender)\n\n        internal\n\n        view\n\n        returns (uint256 allowance_)\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(\n\n            abi.encodeWithSelector(\n\n                IERC20Token(0).allowance.selector,\n\n                owner,\n\n                spender\n\n            )\n\n        );\n\n        if (didSucceed && resultData.length == 32) {\n\n            allowance_ = LibBytes.readUint256(resultData, 0);\n\n        }\n",
                    "message": "Low level call in LibERC20Token.allowance (LibERC20Token.sol#754-769):\n\t-(didSucceed,resultData) = token.staticcall(abi.encodeWithSelector(IERC20Token(0).allowance.selector,owner,spender)) LibERC20Token.sol#759-765\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": 790,
                    "vulnerability_code": "    function balanceOf(address token, address owner)\n\n        internal\n\n        view\n\n        returns (uint256 balance)\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = token.staticcall(\n\n            abi.encodeWithSelector(\n\n                IERC20Token(0).balanceOf.selector,\n\n                owner\n\n            )\n\n        );\n\n        if (didSucceed && resultData.length == 32) {\n\n            balance = LibBytes.readUint256(resultData, 0);\n\n        }\n",
                    "message": "Low level call in LibERC20Token.balanceOf (LibERC20Token.sol#776-790):\n\t-(didSucceed,resultData) = token.staticcall(abi.encodeWithSelector(IERC20Token(0).balanceOf.selector,owner)) LibERC20Token.sol#781-786\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": 816,
                    "vulnerability_code": "    function _callWithOptionalBooleanResult(\n\n        address target,\n\n        bytes memory callData\n\n    )\n\n        private\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = target.call(callData);\n\n        if (didSucceed) {\n\n            if (resultData.length == 0) {\n\n                return;\n\n            }\n\n            if (resultData.length == 32) {\n\n                uint256 result = LibBytes.readUint256(resultData, 0);\n\n                if (result == 1) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        LibRichErrors.rrevert(resultData);\n",
                    "message": "Low level call in LibERC20Token._callWithOptionalBooleanResult (LibERC20Token.sol#797-816):\n\t-(didSucceed,resultData) = target.call(callData) LibERC20Token.sol#803\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibERC20Token.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibERC20Token.sol#82-88) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": 816,
                    "vulnerability_code": "    function _callWithOptionalBooleanResult(\n\n        address target,\n\n        bytes memory callData\n\n    )\n\n        private\n\n    {\n\n        (bool didSucceed, bytes memory resultData) = target.call(callData);\n\n        if (didSucceed) {\n\n            if (resultData.length == 0) {\n\n                return;\n\n            }\n\n            if (resultData.length == 32) {\n\n                uint256 result = LibBytes.readUint256(resultData, 0);\n\n                if (result == 1) {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n        LibRichErrors.rrevert(resultData);\n",
                    "message": "Function 'LibERC20Token._callWithOptionalBooleanResult' (LibERC20Token.sol#797-816) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 640,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant private DECIMALS_CALL_DATA = hex\"313ce567\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 705,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 729,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(token, callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 742,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(DECIMALS_CALL_DATA);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = token.staticcall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = target.call(callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/MintableERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowed[_from][msg.sender] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 313,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 315,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_from] >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_BALANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance >= _value,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC20_INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balances[_to] + _value >= balances[_to],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UINT256_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (MintableERC20Token.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 allowance = allowed[_from][msg.sender];\n",
                    "message": "UnlimitedAllowanceERC20Token.transferFrom.allowance (local variable @ MintableERC20Token.sol#421) shadows:\n\t- ERC20Token.allowance (function @ MintableERC20Token.sol#372-378)\n\t- IERC20Token.allowance (function @ MintableERC20Token.sol#227-230)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (MintableERC20Token.sol#38-42)\n\t- MintableERC20Token.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MintableERC20Token.sol:\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#163): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#253): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#401): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC20Token.sol#471): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (MintableERC20Token.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (MintableERC20Token.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (MintableERC20Token.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of ERC20Token.transfer (MintableERC20Token.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.transfer (MintableERC20Token.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC20Token.transferFrom (MintableERC20Token.sol#298) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC20Token.transferFrom (MintableERC20Token.sol#299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of ERC20Token.transferFrom (MintableERC20Token.sol#300) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_spender' of ERC20Token.approve (MintableERC20Token.sol#335) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": "Parameter '_value' of ERC20Token.approve (MintableERC20Token.sol#335) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC20Token.balanceOf (MintableERC20Token.sol#361) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_owner' of ERC20Token.allowance (MintableERC20Token.sol#372) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address _owner, address _spender)\n",
                    "message": "Parameter '_spender' of ERC20Token.allowance (MintableERC20Token.sol#372) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "Variable 'ERC20Token._totalSupply' (MintableERC20Token.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of UnlimitedAllowanceERC20Token.transferFrom (MintableERC20Token.sol#414) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of UnlimitedAllowanceERC20Token.transferFrom (MintableERC20Token.sol#415) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _value\n",
                    "message": "Parameter '_value' of UnlimitedAllowanceERC20Token.transferFrom (MintableERC20Token.sol#416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": 493,
                    "vulnerability_code": "    function _mint(address _to, uint256 _value)\n\n        internal\n\n    {\n\n        balances[_to] = _value.safeAdd(balances[_to]);\n\n        _totalSupply = _totalSupply.safeAdd(_value);\n\n\n\n        emit Transfer(\n\n            address(0),\n\n            _to,\n\n            _value\n\n        );\n",
                    "message": "Function 'MintableERC20Token._mint' (MintableERC20Token.sol#482-493) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _value)\n",
                    "message": "Parameter '_to' of MintableERC20Token._mint (MintableERC20Token.sol#482) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _value)\n",
                    "message": "Parameter '_value' of MintableERC20Token._mint (MintableERC20Token.sol#482) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 509,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _value)\n\n        internal\n\n    {\n\n        balances[_owner] = balances[_owner].safeSub(_value);\n\n        _totalSupply = _totalSupply.safeSub(_value);\n\n\n\n        emit Transfer(\n\n            _owner,\n\n            address(0),\n\n            _value\n\n        );\n",
                    "message": "Function 'MintableERC20Token._burn' (MintableERC20Token.sol#498-509) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _value)\n",
                    "message": "Parameter '_owner' of MintableERC20Token._burn (MintableERC20Token.sol#498) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _value)\n",
                    "message": "Parameter '_value' of MintableERC20Token._burn (MintableERC20Token.sol#498) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _spender, uint256 _value)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/v06/IEtherTokenV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IEtherTokenV06.sol:\n\t- pragma solidity^0.6.5 (IEtherTokenV06.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (IEtherTokenV06.sol#119): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/v06/IERC20TokenV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IERC20TokenV06.sol:\n\t- pragma solidity^0.6.5 (IERC20TokenV06.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/v06/LibERC20TokenV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            token.approve.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            spender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 709,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            token.transfer.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 713,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 731,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes memory callData = abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            token.transferFrom.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 733,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            from,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = address(token).staticcall(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 768,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                token.allowance.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owner,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                spender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            )\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = address(token).staticcall(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                token.balanceOf.selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 793,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            )\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 751,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenDecimals = uint8(LibBytesV06.readUint256(resultData, 0));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            allowance_ = LibBytesV06.readUint256(resultData, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && resultData.length == 32) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance = LibBytesV06.readUint256(resultData, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 833,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (didSucceed && isSuccessfulResult(resultData)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 835,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant private DECIMALS_CALL_DATA = hex\"313ce567\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(address(token), callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 714,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(address(token), callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 737,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _callWithOptionalBooleanResult(address(token), callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 750,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = address(token).staticcall(DECIMALS_CALL_DATA);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = address(token).staticcall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = address(token).staticcall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool didSucceed, bytes memory resultData) = target.call(callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/interfaces/IERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC20Token.sol:\n\t- pragma solidity^0.5.9 (IERC20Token.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/interfaces/IEtherToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function deposit()\n\n        public\n",
                    "message": "IEtherToken.deposit (IEtherToken.sol#116-118) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function withdraw(uint256 amount)\n",
                    "message": "IEtherToken.withdraw (IEtherToken.sol#120-121) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IEtherToken.sol:\n\t- pragma solidity^0.5.9 (IEtherToken.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IEtherToken.sol#111): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IEtherToken is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/multisig/contracts/test/TestRejectEther.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestRejectEther.sol:\n\t- pragma solidity^0.5.9 (TestRejectEther.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/multisig/contracts/test/ContractCallReceiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (ContractCallReceiver.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (ContractCallReceiver.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (ContractCallReceiver.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (ContractCallReceiver.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (ContractCallReceiver.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (ContractCallReceiver.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (ContractCallReceiver.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (ContractCallReceiver.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (ContractCallReceiver.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (ContractCallReceiver.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (ContractCallReceiver.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (ContractCallReceiver.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": 578,
                    "vulnerability_code": "    function ()\n\n        external\n\n        payable\n\n    {\n\n        bytes4 selector = msg.data.readBytes4(0);\n\n        if (selector == ALWAYS_REVERT_SELECTOR) {\n\n            revert();\n\n        }\n\n\n\n        emit ContractCall(\n\n            selector,\n\n            msg.data,\n\n            msg.value\n\n        );\n",
                    "message": "Contract locking ether found in ContractCallReceiver.sol:\n\tContract ContractCallReceiver has payable functions:\n\t - fallback (ContractCallReceiver.sol#564-578)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (ContractCallReceiver.sol#84-88)\n\t- ContractCallReceiver.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (ContractCallReceiver.sol#122-127)\n\t- ContractCallReceiver.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (ContractCallReceiver.sol#132-137)\n\t- ContractCallReceiver.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (ContractCallReceiver.sol#143-243)\n\t- ContractCallReceiver.sol#148-153\n\t- ContractCallReceiver.sol#176-206\n\t- ContractCallReceiver.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (ContractCallReceiver.sol#284-312)\n\t- ContractCallReceiver.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (ContractCallReceiver.sol#317-337)\n\t- ContractCallReceiver.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (ContractCallReceiver.sol#354-378)\n\t- ContractCallReceiver.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (ContractCallReceiver.sol#384-422)\n\t- ContractCallReceiver.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (ContractCallReceiver.sol#428-447)\n\t- ContractCallReceiver.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (ContractCallReceiver.sol#453-471)\n\t- ContractCallReceiver.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (ContractCallReceiver.sol#494-516)\n\t- ContractCallReceiver.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (ContractCallReceiver.sol#523-527)\n\t- ContractCallReceiver.sol#524-526\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ContractCallReceiver.sol:\n\t- pragma solidity^0.5.9 (ContractCallReceiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ContractCallReceiver.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (ContractCallReceiver.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (ContractCallReceiver.sol#550): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (ContractCallReceiver.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (ContractCallReceiver.sol#78-80) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal ALWAYS_REVERT_SELECTOR = 0xF1F2F3F4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ContractCallReceiver {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (selector == ALWAYS_REVERT_SELECTOR) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/multisig/contracts/src/MultiSigWallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        validRequirement(_owners.length, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (owners[i] == owner) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (owners[i] == owner) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = newOwner;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                confirmationsTemp[count] = owners[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == address(this),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CALLABLE_BY_WALLET\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !isOwner[owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OWNER_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OWNER_DOESNT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transactions[transactionId].destination != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_DOESNT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            confirmations[transactionId][owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !confirmations[transactionId][owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_ALREADY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !transactions[transactionId].executed,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_ALREADY_EXECUTED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _address != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"NULL_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_REQUIREMENTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DUPLICATE_OR_NULL_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0,\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_REQUIREMENTS\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DUPLICATE_OR_NULL_OWNER\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < count; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_18"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": 132,
                    "vulnerability_code": "    function()\n\n        external\n\n        payable\n\n    {\n\n        if (msg.value > 0) {\n\n            emit Deposit(msg.sender, msg.value);\n\n        }\n",
                    "message": "Contract locking ether found in MultiSigWallet.sol:\n\tContract MultiSigWallet has payable functions:\n\t - fallback (MultiSigWallet.sol#125-132)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": 318,
                    "vulnerability_code": "    function _externalCall(\n\n        address destination,\n\n        uint256 value,\n\n        uint256 dataLength,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        returns (bool)\n\n    {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet._externalCall uses assembly (MultiSigWallet.sol#292-318)\n\t- MultiSigWallet.sol#302-316\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 170,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        emit OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWallet.sol#160-170) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": 191,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint256 i = 0; i < owners.length - 1; i++) {\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        }\n\n        owners.length -= 1;\n\n        if (required > owners.length) {\n\n            changeRequirement(owners.length);\n\n        }\n\n        emit OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWallet.sol#174-191) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 212,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint256 i = 0; i < owners.length; i++) {\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        emit OwnerRemoval(owner);\n\n        emit OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWallet.sol#196-212) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 236,
                    "vulnerability_code": "    function submitTransaction(address destination, uint256 value, bytes memory data)\n\n        public\n\n        returns (uint256 transactionId)\n\n    {\n\n        transactionId = _addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWallet.sol#230-236) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 253,
                    "vulnerability_to_line": 261,
                    "vulnerability_code": "    function revokeConfirmation(uint256 transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        emit Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWallet.sol#253-261) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": 383,
                    "vulnerability_code": "    function getConfirmationCount(uint256 transactionId)\n\n        public\n\n        view\n\n        returns (uint256 count)\n\n    {\n\n        for (uint256 i = 0; i < owners.length; i++) {\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                count += 1;\n\n            }\n\n        }\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWallet.sol#373-383) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": 399,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        view\n\n        returns (uint256 count)\n\n    {\n\n        for (uint256 i = 0; i < transactionCount; i++) {\n\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n\n                count += 1;\n\n            }\n\n        }\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWallet.sol#389-399) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": 409,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        view\n\n        returns (address[] memory)\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWallet.sol#403-409) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": 432,
                    "vulnerability_code": "    function getConfirmations(uint256 transactionId)\n\n        public\n\n        view\n\n        returns (address[] memory _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint256 count = 0;\n\n        uint256 i;\n\n        for (i = 0; i < owners.length; i++) {\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        }\n\n        _confirmations = new address[](count);\n\n        for (i = 0; i < count; i++) {\n\n            _confirmations[i] = confirmationsTemp[i];\n\n        }\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWallet.sol#414-432) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": 463,
                    "vulnerability_code": "    function getTransactionIds(\n\n        uint256 from,\n\n        uint256 to,\n\n        bool pending,\n\n        bool executed\n\n    )\n\n        public\n\n        view\n\n        returns (uint256[] memory _transactionIds)\n\n    {\n\n        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n\n        uint256 count = 0;\n\n        uint256 i;\n\n        for (i = 0; i < transactionCount; i++) {\n\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        }\n\n        _transactionIds = new uint256[](to - from);\n\n        for (i = from; i < to; i++) {\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n\n        }\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWallet.sol#440-463) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MultiSigWallet.sol:\n\t- pragma solidity^0.5.9 (MultiSigWallet.sol#4): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Parameter '_owners' of MultiSigWallet. (MultiSigWallet.sol#141) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required\n",
                    "message": "Parameter '_required' of MultiSigWallet. (MultiSigWallet.sol#142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint256 _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWallet.sol#216) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": 318,
                    "vulnerability_code": "    function _externalCall(\n\n        address destination,\n\n        uint256 value,\n\n        uint256 dataLength,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        returns (bool)\n\n    {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet._externalCall' (MultiSigWallet.sol#292-318) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": 365,
                    "vulnerability_code": "    function _addTransaction(\n\n        address destination,\n\n        uint256 value,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        notNull(destination)\n\n        returns (uint256 transactionId)\n\n    {\n\n        transactionId = transactionCount;\n\n        transactions[transactionId] = Transaction({\n\n            destination: destination,\n\n            value: value,\n\n            data: data,\n\n            executed: false\n\n        });\n\n        transactionCount += 1;\n\n        emit Submission(transactionId);\n",
                    "message": "Function 'MultiSigWallet._addTransaction' (MultiSigWallet.sol#347-365) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 394,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint256 transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 329,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 4,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/multisig/contracts/src/MultiSigWalletWithTimeLock.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        validRequirement(_owners.length, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 670,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWallet(_owners, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        secondsTimeLocked = _secondsTimeLocked;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (owners[i] == owner) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (owners[i] == owner) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = newOwner;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                confirmationsTemp[count] = owners[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == address(this),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CALLABLE_BY_WALLET\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !isOwner[owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OWNER_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OWNER_DOESNT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transactions[transactionId].destination != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_DOESNT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            confirmations[transactionId][owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !confirmations[transactionId][owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_ALREADY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !transactions[transactionId].executed,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_ALREADY_EXECUTED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _address != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"NULL_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_REQUIREMENTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DUPLICATE_OR_NULL_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            block.timestamp >= confirmationTimes[transactionId].safeAdd(secondsTimeLocked),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0,\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_REQUIREMENTS\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DUPLICATE_OR_NULL_OWNER\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!isTxFullyConfirmedBeforeConfirmation && isConfirmed(transactionId)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setConfirmationTime(transactionId, block.timestamp);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < count; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return"
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (MultiSigWalletWithTimeLock.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": 274,
                    "vulnerability_code": "    function()\n\n        external\n\n        payable\n\n    {\n\n        if (msg.value > 0) {\n\n            emit Deposit(msg.sender, msg.value);\n\n        }\n",
                    "message": "Contract locking ether found in MultiSigWalletWithTimeLock.sol:\n\tContract MultiSigWalletWithTimeLock has payable functions:\n\t - fallback (MultiSigWalletWithTimeLock.sol#267-274)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (MultiSigWalletWithTimeLock.sol#38-42)\n\t- MultiSigWalletWithTimeLock.sol#39-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": 460,
                    "vulnerability_code": "    function _externalCall(\n\n        address destination,\n\n        uint256 value,\n\n        uint256 dataLength,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        returns (bool)\n\n    {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "MultiSigWallet._externalCall uses assembly (MultiSigWalletWithTimeLock.sol#434-460)\n\t- MultiSigWalletWithTimeLock.sol#444-458\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function addOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerDoesNotExist(owner)\n\n        notNull(owner)\n\n        validRequirement(owners.length + 1, required)\n\n    {\n\n        isOwner[owner] = true;\n\n        owners.push(owner);\n\n        emit OwnerAddition(owner);\n",
                    "message": "MultiSigWallet.addOwner (MultiSigWalletWithTimeLock.sol#302-312) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": 333,
                    "vulnerability_code": "    function removeOwner(address owner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n    {\n\n        isOwner[owner] = false;\n\n        for (uint256 i = 0; i < owners.length - 1; i++) {\n\n            if (owners[i] == owner) {\n\n                owners[i] = owners[owners.length - 1];\n\n                break;\n\n            }\n\n        }\n\n        owners.length -= 1;\n\n        if (required > owners.length) {\n\n            changeRequirement(owners.length);\n\n        }\n\n        emit OwnerRemoval(owner);\n",
                    "message": "MultiSigWallet.removeOwner (MultiSigWalletWithTimeLock.sol#316-333) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": 354,
                    "vulnerability_code": "    function replaceOwner(address owner, address newOwner)\n\n        public\n\n        onlyWallet\n\n        ownerExists(owner)\n\n        ownerDoesNotExist(newOwner)\n\n    {\n\n        for (uint256 i = 0; i < owners.length; i++) {\n\n            if (owners[i] == owner) {\n\n                owners[i] = newOwner;\n\n                break;\n\n            }\n\n        }\n\n        isOwner[owner] = false;\n\n        isOwner[newOwner] = true;\n\n        emit OwnerRemoval(owner);\n\n        emit OwnerAddition(newOwner);\n",
                    "message": "MultiSigWallet.replaceOwner (MultiSigWalletWithTimeLock.sol#338-354) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function submitTransaction(address destination, uint256 value, bytes memory data)\n\n        public\n\n        returns (uint256 transactionId)\n\n    {\n\n        transactionId = _addTransaction(destination, value, data);\n\n        confirmTransaction(transactionId);\n",
                    "message": "MultiSigWallet.submitTransaction (MultiSigWalletWithTimeLock.sol#372-378) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 395,
                    "vulnerability_to_line": 403,
                    "vulnerability_code": "    function revokeConfirmation(uint256 transactionId)\n\n        public\n\n        ownerExists(msg.sender)\n\n        confirmed(transactionId, msg.sender)\n\n        notExecuted(transactionId)\n\n    {\n\n        confirmations[transactionId][msg.sender] = false;\n\n        emit Revocation(msg.sender, transactionId);\n",
                    "message": "MultiSigWallet.revokeConfirmation (MultiSigWalletWithTimeLock.sol#395-403) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": 525,
                    "vulnerability_code": "    function getConfirmationCount(uint256 transactionId)\n\n        public\n\n        view\n\n        returns (uint256 count)\n\n    {\n\n        for (uint256 i = 0; i < owners.length; i++) {\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                count += 1;\n\n            }\n\n        }\n",
                    "message": "MultiSigWallet.getConfirmationCount (MultiSigWalletWithTimeLock.sol#515-525) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n\n        public\n\n        view\n\n        returns (uint256 count)\n\n    {\n\n        for (uint256 i = 0; i < transactionCount; i++) {\n\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n\n                count += 1;\n\n            }\n\n        }\n",
                    "message": "MultiSigWallet.getTransactionCount (MultiSigWalletWithTimeLock.sol#531-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function getOwners()\n\n        public\n\n        view\n\n        returns (address[] memory)\n\n    {\n\n        return owners;\n",
                    "message": "MultiSigWallet.getOwners (MultiSigWalletWithTimeLock.sol#545-551) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": 574,
                    "vulnerability_code": "    function getConfirmations(uint256 transactionId)\n\n        public\n\n        view\n\n        returns (address[] memory _confirmations)\n\n    {\n\n        address[] memory confirmationsTemp = new address[](owners.length);\n\n        uint256 count = 0;\n\n        uint256 i;\n\n        for (i = 0; i < owners.length; i++) {\n\n            if (confirmations[transactionId][owners[i]]) {\n\n                confirmationsTemp[count] = owners[i];\n\n                count += 1;\n\n            }\n\n        }\n\n        _confirmations = new address[](count);\n\n        for (i = 0; i < count; i++) {\n\n            _confirmations[i] = confirmationsTemp[i];\n\n        }\n",
                    "message": "MultiSigWallet.getConfirmations (MultiSigWalletWithTimeLock.sol#556-574) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": 605,
                    "vulnerability_code": "    function getTransactionIds(\n\n        uint256 from,\n\n        uint256 to,\n\n        bool pending,\n\n        bool executed\n\n    )\n\n        public\n\n        view\n\n        returns (uint256[] memory _transactionIds)\n\n    {\n\n        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\n\n        uint256 count = 0;\n\n        uint256 i;\n\n        for (i = 0; i < transactionCount; i++) {\n\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n\n                transactionIdsTemp[count] = i;\n\n                count += 1;\n\n            }\n\n        }\n\n        _transactionIds = new uint256[](to - from);\n\n        for (i = from; i < to; i++) {\n\n            _transactionIds[i - from] = transactionIdsTemp[i];\n\n        }\n",
                    "message": "MultiSigWallet.getTransactionIds (MultiSigWalletWithTimeLock.sol#582-605) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 679,
                    "vulnerability_to_line": 685,
                    "vulnerability_code": "    function changeTimeLock(uint256 _secondsTimeLocked)\n\n        public\n\n        onlyWallet\n\n    {\n\n        secondsTimeLocked = _secondsTimeLocked;\n\n        emit TimeLockChange(_secondsTimeLocked);\n",
                    "message": "MultiSigWalletWithTimeLock.changeTimeLock (MultiSigWalletWithTimeLock.sol#679-685) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MultiSigWalletWithTimeLock.sol:\n\t- pragma solidity^0.5.9 (MultiSigWalletWithTimeLock.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MultiSigWalletWithTimeLock.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (MultiSigWalletWithTimeLock.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (MultiSigWalletWithTimeLock.sol#146): it allows old versions\n\t- pragma solidity^0.5.9 (MultiSigWalletWithTimeLock.sol#628): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (MultiSigWalletWithTimeLock.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (MultiSigWalletWithTimeLock.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (MultiSigWalletWithTimeLock.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Parameter '_owners' of MultiSigWallet. (MultiSigWalletWithTimeLock.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required\n",
                    "message": "Parameter '_required' of MultiSigWallet. (MultiSigWalletWithTimeLock.sol#284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeRequirement(uint256 _required)\n",
                    "message": "Parameter '_required' of MultiSigWallet.changeRequirement (MultiSigWalletWithTimeLock.sol#358) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": 460,
                    "vulnerability_code": "    function _externalCall(\n\n        address destination,\n\n        uint256 value,\n\n        uint256 dataLength,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        returns (bool)\n\n    {\n\n        bool result;\n\n        assembly {\n\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\n\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n\n            result := call(\n\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\n\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n\n                destination,\n\n                value,\n\n                d,\n\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n\n                x,\n\n                0                  // Output is ignored, therefore the output size is zero\n\n            )\n\n        }\n\n        return result;\n",
                    "message": "Function 'MultiSigWallet._externalCall' (MultiSigWalletWithTimeLock.sol#434-460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": 507,
                    "vulnerability_code": "    function _addTransaction(\n\n        address destination,\n\n        uint256 value,\n\n        bytes memory data\n\n    )\n\n        internal\n\n        notNull(destination)\n\n        returns (uint256 transactionId)\n\n    {\n\n        transactionId = transactionCount;\n\n        transactions[transactionId] = Transaction({\n\n            destination: destination,\n\n            value: value,\n\n            data: data,\n\n            executed: false\n\n        });\n\n        transactionCount += 1;\n\n        emit Submission(transactionId);\n",
                    "message": "Function 'MultiSigWallet._addTransaction' (MultiSigWalletWithTimeLock.sol#489-507) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Parameter '_secondsTimeLocked' of MultiSigWalletWithTimeLock. (MultiSigWalletWithTimeLock.sol#669) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 679,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function changeTimeLock(uint256 _secondsTimeLocked)\n",
                    "message": "Parameter '_secondsTimeLocked' of MultiSigWalletWithTimeLock.changeTimeLock (MultiSigWalletWithTimeLock.sol#679) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 724,
                    "vulnerability_to_line": 729,
                    "vulnerability_code": "    function _setConfirmationTime(uint256 transactionId, uint256 confirmationTime)\n\n        internal\n\n    {\n\n        confirmationTimes[transactionId] = confirmationTime;\n\n        emit ConfirmationTimeSet(transactionId, confirmationTime);\n",
                    "message": "Function 'MultiSigWalletWithTimeLock._setConfirmationTime' (MultiSigWalletWithTimeLock.sol#724-729) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint256 transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/multisig/contracts/src/ZeroExGovernor.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        transactionCount += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        validRequirement(_owners.length, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _secondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 670,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWallet(_owners, _required)\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        secondsTimeLocked = _secondsTimeLocked;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes4[] memory _functionSelectors,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _destinations,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint128[] memory _functionCallTimeLockSeconds,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] memory _owners,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _required,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _defaultSecondsTimeLocked\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        MultiSigWalletWithTimeLock(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[_owners[i]] = true;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (owners[i] == owner) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = owners[owners.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (owners[i] == owner) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                owners[i] = newOwner;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (count == required) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (confirmations[transactionId][owners[i]]) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                confirmationsTemp[count] = owners[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i != length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == address(this),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CALLABLE_BY_WALLET\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !isOwner[owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OWNER_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isOwner[owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"OWNER_DOESNT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transactions[transactionId].destination != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_DOESNT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            confirmations[transactionId][owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !confirmations[transactionId][owner],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_ALREADY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !transactions[transactionId].executed,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_ALREADY_EXECUTED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _address != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"NULL_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_REQUIREMENTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DUPLICATE_OR_NULL_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isConfirmed(transactionId),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TX_NOT_FULLY_CONFIRMED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            block.timestamp >= confirmationTimes[transactionId].safeAdd(secondsTimeLocked),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length == _destinations.length && length == _functionCallTimeLockSeconds.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"EQUAL_LENGTHS_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length == destinations.length && length == values.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"EQUAL_LENGTHS_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                didSucceed,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1373,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"FAILED_EXECUTION\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                block.timestamp >= transactionConfirmationTime.safeAdd(timeLock.secondsTimeLocked),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"CUSTOM_TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                block.timestamp >= transactionConfirmationTime.safeAdd(secondsTimeLocked),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DEFAULT_TIME_LOCK_INCOMPLETE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ownerCount <= MAX_OWNER_COUNT\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required <= ownerCount\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && _required != 0\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            && ownerCount != 0,\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INVALID_REQUIREMENTS\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                !isOwner[_owners[i]] && _owners[i] != address(0),\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"DUPLICATE_OR_NULL_OWNER\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1287,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length == _destinations.length && length == _functionCallTimeLockSeconds.length,\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"EQUAL_LENGTHS_REQUIRED\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length == destinations.length && length == values.length,\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"EQUAL_LENGTHS_REQUIRED\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 537,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                transactionIdsTemp[count] = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                count += 1;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!isTxFullyConfirmedBeforeConfirmation && isConfirmed(transactionId)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _setConfirmationTime(transactionId, block.timestamp);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < count; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 602,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = from; i < to; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i != length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length - 1; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < transactionCount; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < transactionCount; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getConfirmationCount(uint256 transactionId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 531,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTransactionCount(bool pending, bool executed)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < owners.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract MultiSigWallet {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 809,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 819,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1041,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1071,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 1369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (bool didSucceed,) = destinations[i].call.value(values[i])(data[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 810,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 820,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 835,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 863,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 895,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 994,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1018,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLibAddressArray.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            freeMemPtr,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressArrayEndPtr\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_41"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibAddressArray.sol#157-164) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestLibAddressArray.sol#199-208) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestLibAddressArray.sol#213-222) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestLibAddressArray.sol#228-329) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestLibAddressArray.sol#378-410) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestLibAddressArray.sol#415-437) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 490,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestLibAddressArray.sol#461-490) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestLibAddressArray.sol#496-539) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestLibAddressArray.sol#545-569) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestLibAddressArray.sol#575-598) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": 662,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestLibAddressArray.sol#635-662) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": 676,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestLibAddressArray.sol#669-676) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append (TestLibAddressArray.sol#712-766) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains (TestLibAddressArray.sol#772-802) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": 839,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf (TestLibAddressArray.sol#808-839) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 920,
                    "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
                    "message": "TestLibAddressArray.testAppendRealloc (TestLibAddressArray.sol#893-920) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibAddressArray.sol#157-164)\n\t- TestLibAddressArray.sol#161-163\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestLibAddressArray.sol#199-208)\n\t- TestLibAddressArray.sol#204-206\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestLibAddressArray.sol#213-222)\n\t- TestLibAddressArray.sol#218-220\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestLibAddressArray.sol#228-329)\n\t- TestLibAddressArray.sol#240-245\n\t- TestLibAddressArray.sol#268-295\n\t- TestLibAddressArray.sol#297-326\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestLibAddressArray.sol#378-410)\n\t- TestLibAddressArray.sol#405-408\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestLibAddressArray.sol#415-437)\n\t- TestLibAddressArray.sol#431-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 490,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestLibAddressArray.sol#461-490)\n\t- TestLibAddressArray.sol#483-488\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestLibAddressArray.sol#496-539)\n\t- TestLibAddressArray.sol#518-538\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestLibAddressArray.sol#545-569)\n\t- TestLibAddressArray.sol#565-567\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestLibAddressArray.sol#575-598)\n\t- TestLibAddressArray.sol#595-597\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": 662,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestLibAddressArray.sol#635-662)\n\t- TestLibAddressArray.sol#655-660\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": 676,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestLibAddressArray.sol#669-676)\n\t- TestLibAddressArray.sol#673-675\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append uses assembly (TestLibAddressArray.sol#712-766)\n\t- TestLibAddressArray.sol#723-727\n\t- TestLibAddressArray.sol#746-749\n\t- TestLibAddressArray.sol#757-763\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains uses assembly (TestLibAddressArray.sol#772-802)\n\t- TestLibAddressArray.sol#777-800\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": 839,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf uses assembly (TestLibAddressArray.sol#808-839)\n\t- TestLibAddressArray.sol#813-837\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 920,
                    "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
                    "message": "TestLibAddressArray.testAppendRealloc uses assembly (TestLibAddressArray.sol#893-920)\n\t- TestLibAddressArray.sol#906-911\n\t- TestLibAddressArray.sol#917-919\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in TestLibAddressArray.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- TestLibAddressArray.sol#21 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#67 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#126 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#187 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#699 declares pragma solidity^0.5.9\n\t- TestLibAddressArray.sol#862 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": 881,
                    "vulnerability_code": "    function publicAppend(address[] memory addressArray, address addressToAppend)\n\n        public\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        return addressArray.append(addressToAppend);\n",
                    "message": "TestLibAddressArray.publicAppend (TestLibAddressArray.sol#875-881) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": 920,
                    "vulnerability_code": "    function testAppendRealloc(\n\n        address[] memory addressArray,\n\n        int256 freeMemOffset,\n\n        address addressToAppend\n\n    )\n\n        public\n\n        pure\n\n        returns (\n\n            address[] memory result,\n\n            uint256 oldArrayMemStart,\n\n            uint256 newArrayMemStart\n\n        )\n\n    {\n\n        assembly {\n\n            // Remember the original memory address of the array.\n\n            oldArrayMemStart := addressArray\n\n            // Move the free memory pointer.\n\n            mstore(0x40, add(mload(0x40), freeMemOffset))\n\n        }\n\n\n\n        // Call append.\n\n        result = addressArray.append(addressToAppend);\n\n\n\n        // Get the new array memory address.\n\n        assembly {\n\n            newArrayMemStart := result\n\n        }\n",
                    "message": "TestLibAddressArray.testAppendRealloc (TestLibAddressArray.sol#893-920) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 926,
                    "vulnerability_to_line": 932,
                    "vulnerability_code": "    function publicContains(address[] memory addressArray, address target)\n\n        public\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        return addressArray.contains(target);\n",
                    "message": "TestLibAddressArray.publicContains (TestLibAddressArray.sol#926-932) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 938,
                    "vulnerability_to_line": 944,
                    "vulnerability_code": "    function publicIndexOf(address[] memory addressArray, address target)\n\n        public\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        (success, index) = addressArray.indexOf(target);\n",
                    "message": "TestLibAddressArray.publicIndexOf (TestLibAddressArray.sol#938-944) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibAddressArray.sol:\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#187): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddressArray.sol#699): it allows old versions\n\t- pragma solidity^0.5.5 (TestLibAddressArray.sol#862): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
                    "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (TestLibAddressArray.sol#31-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestLibAddressArray.sol#88-103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibAddressArray.sol#141-152) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5fc83722;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function testAppendRealloc(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function testAppendRealloc(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success, uint256 index)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 900,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success, uint256 index)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 906,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLibRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibRichErrors.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibRichErrors.sol#52-59)\n\t- TestLibRichErrors.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibRichErrors.sol:\n\t- pragma solidity^0.5.9 (TestLibRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibRichErrors.sol#82): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibRichErrors.sol#36-47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestRefundable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_16"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Refundable._refundNonZeroBalance (TestRefundable.sol#217-224) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (TestRefundable.sol#222)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestRefundable.sol#91-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestRefundable.sol#91-98)\n\t- TestRefundable.sol#95-97\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": 314,
                    "vulnerability_code": "    function nestedDisableRefundUntilEndFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        disableRefundUntilEndFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.nestedDisableRefundUntilEndFunction (TestRefundable.sol#306-314) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": 324,
                    "vulnerability_code": "    function mixedRefundModifierFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        refundFinalBalanceFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.mixedRefundModifierFunction (TestRefundable.sol#316-324) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestRefundable.sol:\n\t- pragma solidity^0.5.9 (TestRefundable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundable.sol#60): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundable.sol#121): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundable.sol#178): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundable.sol#268): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (TestRefundable.sol#31-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestRefundable.sol#75-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrors.rrevert(\n\n                LibReentrancyGuardRichErrors.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
                    "message": "Function 'ReentrancyGuard._lockMutexOrThrowIfAlreadyLocked' (TestRefundable.sol#137-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
                    "message": "Function 'ReentrancyGuard._unlockMutex' (TestRefundable.sol#150-155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": 215,
                    "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (TestRefundable.sol#209-215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalance' (TestRefundable.sol#217-224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": 230,
                    "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
                    "message": "Function 'Refundable._disableRefund' (TestRefundable.sol#226-230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
                    "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (TestRefundable.sol#232-237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
                    "message": "Function 'Refundable._areRefundsDisabled' (TestRefundable.sol#239-245) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _shouldNotRefund;\n",
                    "message": "Variable 'Refundable._shouldNotRefund' (TestRefundable.sol#185) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TestRefundable is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLibAddress.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract (TestLibAddress.sol#36-47) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract uses assembly (TestLibAddress.sol#36-47)\n\t- TestLibAddress.sol#45\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibAddress.sol:\n\t- pragma solidity^0.5.9 (TestLibAddress.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibAddress.sol#71): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLibSafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibSafeMath.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibSafeMath.sol#52-59)\n\t- TestLibSafeMath.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibSafeMath.sol:\n\t- pragma solidity^0.5.9 (TestLibSafeMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibSafeMath.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibSafeMath.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibSafeMath.sol#234): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibSafeMath.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (TestLibSafeMath.sol#91-106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (TestLibSafeMath.sol#108-121) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLogDecodingDownstream.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in TestLogDecodingDownstream.sol:\n\t- pragma solidity^0.5.5 (TestLogDecodingDownstream.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestOwnable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLibEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContract\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContract)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContract)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain (TestLibEIP712.sol#42-82) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message (TestLibEIP712.sol#89-113) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContract\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContract)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContract)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain uses assembly (TestLibEIP712.sol#42-82)\n\t- TestLibEIP712.sol#63-80\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (TestLibEIP712.sol#89-113)\n\t- TestLibEIP712.sol#101-111\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibEIP712.sol:\n\t- pragma solidity^0.5.9 (TestLibEIP712.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibEIP712.sol#136): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Domain(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function externalHashEIP712DomainSeperator(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string calldata version,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 chainid,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address verifyingcontractaddress\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes32)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return LibEIP712.hashEIP712Domain(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            version,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            verifyingcontractaddress\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestRefundableReceiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value != 0, \"Zero value should not be sent to this contract.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceWithinCall == msg.value, \"Incorrect inner balance\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 475,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceWithinCall == msg.value, \"Incorrect inner balance\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.value != 0, \"Zero value should not be sent to this contract.\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Refundable._refundNonZeroBalance (TestRefundableReceiver.sol#217-224) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (TestRefundableReceiver.sol#222)\n"
                },
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
                    "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#486-515) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(address(this).balance) (TestRefundableReceiver.sol#514)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestRefundableReceiver.sol#91-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
                    "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#486-515) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == 0,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == msg.value,Incorrect balance for TestRefundable)\n\t- require(bool,string)(address(this).balance == msg.value,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == 0,Incorrect balance for TestRefundable)\n"
                },
                {
                    "name": "incorrect-equality",
                    "vulnerability_from_line": 486,
                    "vulnerability_to_line": 515,
                    "vulnerability_code": "    function requireCorrectFinalBalancesAndState(\n\n        TestRefundable testRefundable,\n\n        bool shouldNotRefund\n\n    )\n\n        internal\n\n    {\n\n        // If `shouldNotRefund` was true, then this contract should have a balance of zero,\n\n        // and `testRefundable` should have a balance of `msg.value`. Otherwise, the opposite\n\n        // should be true.\n\n        if (shouldNotRefund) {\n\n            // Ensure that this contract's balance is zero.\n\n            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to `msg.value`.\n\n            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n\n        } else {\n\n            // Ensure that this contract's balance is `msg.value`.\n\n            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n\n\n\n            // Ensure that the other contract's balance is equal to zero.\n\n            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n\n        }\n\n\n\n        // Ensure that `shouldNotRefund` in TestRefundable is set to the parameter `shouldNotRefund`\n\n        // after the call (i.e. the value didn't change during the function call).\n\n        require(testRefundable.getShouldNotRefund() == shouldNotRefund, \"Incorrect shouldNotRefund value\");\n\n\n\n        // Drain the contract of funds so that subsequent tests don't have to account for leftover ether.\n\n        msg.sender.transfer(address(this).balance);\n",
                    "message": "TestRefundableReceiver.requireCorrectFinalBalancesAndState (TestRefundableReceiver.sol#486-515) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == 0,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == msg.value,Incorrect balance for TestRefundable)\n\t- require(bool,string)(address(this).balance == msg.value,Incorrect balance for TestRefundableReceiver)\n\t- require(bool,string)(address(testRefundable).balance == 0,Incorrect balance for TestRefundable)\nTestRefundableReceiver.testRefundNonZeroBalance (TestRefundableReceiver.sol#365-378) uses a dangerous strict equality:\n\t- require(bool,string)(address(this).balance == msg.value,A full refund was not provided by `refundNonzeroBalance`)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestRefundableReceiver.sol#91-98)\n\t- TestRefundableReceiver.sol#95-97\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": 314,
                    "vulnerability_code": "    function nestedDisableRefundUntilEndFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        disableRefundUntilEndFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.nestedDisableRefundUntilEndFunction (TestRefundableReceiver.sol#306-314) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 316,
                    "vulnerability_to_line": 324,
                    "vulnerability_code": "    function mixedRefundModifierFunction()\n\n        public\n\n        payable\n\n        disableRefundUntilEnd\n\n        returns (uint256)\n\n    {\n\n        refundFinalBalanceFunction();\n\n        return address(this).balance;\n",
                    "message": "TestRefundable.mixedRefundModifierFunction (TestRefundableReceiver.sol#316-324) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestRefundableReceiver.sol:\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#60): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#121): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#178): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#268): it allows old versions\n\t- pragma solidity^0.5.9 (TestRefundableReceiver.sol#347): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (TestRefundableReceiver.sol#31-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestRefundableReceiver.sol#75-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrors.rrevert(\n\n                LibReentrancyGuardRichErrors.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
                    "message": "Function 'ReentrancyGuard._lockMutexOrThrowIfAlreadyLocked' (TestRefundableReceiver.sol#137-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
                    "message": "Function 'ReentrancyGuard._unlockMutex' (TestRefundableReceiver.sol#150-155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": 215,
                    "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (TestRefundableReceiver.sol#209-215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalance' (TestRefundableReceiver.sol#217-224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": 230,
                    "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
                    "message": "Function 'Refundable._disableRefund' (TestRefundableReceiver.sol#226-230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
                    "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (TestRefundableReceiver.sol#232-237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
                    "message": "Function 'Refundable._areRefundsDisabled' (TestRefundableReceiver.sol#239-245) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _shouldNotRefund;\n",
                    "message": "Variable 'Refundable._shouldNotRefund' (TestRefundableReceiver.sol#185) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"A full refund was not provided by `refundNonzeroBalance`\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == 0, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == msg.value, \"Incorrect balance for TestRefundable\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(this).balance == msg.value, \"Incorrect balance for TestRefundableReceiver\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_BALANCE_EQUALITY",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(address(testRefundable).balance == 0, \"Incorrect balance for TestRefundable\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TestRefundable is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLibBytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_43"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibBytes.sol#111-118) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestLibBytes.sol#153-162) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestLibBytes.sol#167-176) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestLibBytes.sol#182-283) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestLibBytes.sol#332-364) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestLibBytes.sol#369-391) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 444,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestLibBytes.sol#415-444) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": 493,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestLibBytes.sol#450-493) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestLibBytes.sol#499-523) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": 552,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestLibBytes.sol#529-552) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": 616,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestLibBytes.sol#589-616) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 630,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestLibBytes.sol#623-630) is declared view but contains assembly code\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        lhs.popLastByte();\n\n        rhs.popLastByte();\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEqualsPop1 (TestLibBytes.sol#684-693) does not use the value returned by external calls:\n\t-lhs.popLastByte() (TestLibBytes.sol#689)\n\t-rhs.popLastByte() (TestLibBytes.sol#690)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibBytes.sol#111-118)\n\t- TestLibBytes.sol#115-117\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestLibBytes.sol#153-162)\n\t- TestLibBytes.sol#158-160\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestLibBytes.sol#167-176)\n\t- TestLibBytes.sol#172-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestLibBytes.sol#182-283)\n\t- TestLibBytes.sol#194-199\n\t- TestLibBytes.sol#222-249\n\t- TestLibBytes.sol#251-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestLibBytes.sol#332-364)\n\t- TestLibBytes.sol#359-362\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestLibBytes.sol#369-391)\n\t- TestLibBytes.sol#385-389\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 444,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestLibBytes.sol#415-444)\n\t- TestLibBytes.sol#437-442\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": 493,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestLibBytes.sol#450-493)\n\t- TestLibBytes.sol#472-492\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestLibBytes.sol#499-523)\n\t- TestLibBytes.sol#519-521\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": 552,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestLibBytes.sol#529-552)\n\t- TestLibBytes.sol#549-551\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": 616,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestLibBytes.sol#589-616)\n\t- TestLibBytes.sol#609-614\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 630,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestLibBytes.sol#623-630)\n\t- TestLibBytes.sol#627-629\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 662,
                    "vulnerability_to_line": 669,
                    "vulnerability_code": "    function publicPopLastByte(bytes memory b)\n\n        public\n\n        pure\n\n        returns (bytes memory, bytes1 result)\n\n    {\n\n        result = b.popLastByte();\n\n        return (b, result);\n",
                    "message": "TestLibBytes.publicPopLastByte (TestLibBytes.sol#662-669) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 675,
                    "vulnerability_to_line": 682,
                    "vulnerability_code": "    function publicEquals(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEquals (TestLibBytes.sol#675-682) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n\n        public\n\n        pure\n\n        returns (bool equal)\n\n    {\n\n        lhs.popLastByte();\n\n        rhs.popLastByte();\n\n        equal = lhs.equals(rhs);\n\n        return equal;\n",
                    "message": "TestLibBytes.publicEqualsPop1 (TestLibBytes.sol#684-693) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": 709,
                    "vulnerability_code": "    function publicReadAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (address result)\n\n    {\n\n        result = b.readAddress(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadAddress (TestLibBytes.sol#699-709) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 715,
                    "vulnerability_to_line": 726,
                    "vulnerability_code": "    function publicWriteAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeAddress(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteAddress (TestLibBytes.sol#715-726) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 732,
                    "vulnerability_to_line": 742,
                    "vulnerability_code": "    function publicReadBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        result = b.readBytes32(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytes32 (TestLibBytes.sol#732-742) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 748,
                    "vulnerability_to_line": 759,
                    "vulnerability_code": "    function publicWriteBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeBytes32(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteBytes32 (TestLibBytes.sol#748-759) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": 775,
                    "vulnerability_code": "    function publicReadUint256(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (uint256 result)\n\n    {\n\n        result = b.readUint256(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadUint256 (TestLibBytes.sol#765-775) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 781,
                    "vulnerability_to_line": 792,
                    "vulnerability_code": "    function publicWriteUint256(\n\n        bytes memory b,\n\n        uint256 index,\n\n        uint256 input\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        b.writeUint256(index, input);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteUint256 (TestLibBytes.sol#781-792) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": 808,
                    "vulnerability_code": "    function publicReadBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        result = b.readBytes4(index);\n\n        return result;\n",
                    "message": "TestLibBytes.publicReadBytes4 (TestLibBytes.sol#798-808) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": 838,
                    "vulnerability_code": "    function testMemcpy(\n\n        bytes memory mem,\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        public // not external, we need input in memory\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        // Sanity check. Overflows are not checked.\n\n        require(source + length <= mem.length);\n\n        require(dest + length <= mem.length);\n\n\n\n        // Get pointer to memory contents\n\n        uint256 offset = mem.contentAddress();\n\n\n\n        // Execute memCopy adjusted for memory array location\n\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n\n\n        // Return modified memory contents\n\n        return mem;\n",
                    "message": "TestLibBytes.testMemcpy (TestLibBytes.sol#816-838) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 845,
                    "vulnerability_to_line": 856,
                    "vulnerability_code": "    function publicSlice(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory result, bytes memory original)\n\n    {\n\n        result = LibBytes.slice(b, from, to);\n\n        return (result, b);\n",
                    "message": "TestLibBytes.publicSlice (TestLibBytes.sol#845-856) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 864,
                    "vulnerability_to_line": 875,
                    "vulnerability_code": "    function publicSliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory result, bytes memory original)\n\n    {\n\n        result = LibBytes.sliceDestructive(b, from, to);\n\n        return (result, b);\n",
                    "message": "TestLibBytes.publicSliceDestructive (TestLibBytes.sol#864-875) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": 897,
                    "vulnerability_code": "    function publicWriteLength(\n\n        bytes memory b,\n\n        uint256 length,\n\n        bytes memory extraBytes\n\n    )\n\n        public\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        uint256 bEnd = b.contentAddress() + b.length;\n\n        LibBytes.memCopy(bEnd, extraBytes.contentAddress(), extraBytes.length);\n\n        b.writeLength(length);\n\n        return b;\n",
                    "message": "TestLibBytes.publicWriteLength (TestLibBytes.sol#884-897) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 911,
                    "vulnerability_code": "    function assertBytesUnchangedAfterLengthReset(\n\n        bytes memory b,\n\n        uint256 tempLength\n\n    )\n\n        public\n\n        pure\n\n    {\n\n        uint256 length = b.length;\n\n        bytes memory bCopy = b.slice(0, length);\n\n        b.writeLength(tempLength);\n\n        b.writeLength(length);\n\n        assert(b.equals(bCopy));\n",
                    "message": "TestLibBytes.assertBytesUnchangedAfterLengthReset (TestLibBytes.sol#899-911) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibBytes.sol:\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#141): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibBytes.sol#653): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestLibBytes.sol#42-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibBytes.sol#95-106) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory, bytes1 result)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory result, bytes memory original)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 871,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory result, bytes memory original)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/test/TestLogDecoding.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": 104,
                    "vulnerability_code": "    function emitEventsLocalAndDownstream()\n\n        public\n\n    {\n\n        emitEvent();\n\n        emitEventDownstream();\n",
                    "message": "TestLogDecoding.emitEventsLocalAndDownstream (TestLogDecoding.sol#99-104) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": "Detected issues with version pragma in TestLogDecoding.sol:\n\t- pragma solidity^0.5.5 (TestLogDecoding.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (TestLogDecoding.sol#72): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibEIP1271.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibEIP1271.sol:\n\t- pragma solidity^0.5.9 (LibEIP1271.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public EIP1271_MAGIC_VALUE = 0x20c13b0b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/ReentrancyGuard.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (ReentrancyGuard.sol#91-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (ReentrancyGuard.sol#91-98)\n\t- ReentrancyGuard.sol#95-97\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ReentrancyGuard.sol:\n\t- pragma solidity^0.5.9 (ReentrancyGuard.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ReentrancyGuard.sol#60): it allows old versions\n\t- pragma solidity^0.5.9 (ReentrancyGuard.sol#121): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (ReentrancyGuard.sol#31-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (ReentrancyGuard.sol#75-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrors.rrevert(\n\n                LibReentrancyGuardRichErrors.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
                    "message": "Function 'ReentrancyGuard._lockMutexOrThrowIfAlreadyLocked' (ReentrancyGuard.sol#137-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
                    "message": "Function 'ReentrancyGuard._unlockMutex' (ReentrancyGuard.sol#150-155) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/Authorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 265,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Ownable()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 463,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibSafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibSafeMath.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibSafeMath.sol#52-59)\n\t- LibSafeMath.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibSafeMath.sol:\n\t- pragma solidity^0.5.9 (LibSafeMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeMath.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeMath.sol#126): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibSafeMath.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibSafeMath.sol#91-106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibSafeMath.sol#108-121) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibFractions.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibFractions.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibFractions.sol#52-59)\n\t- LibFractions.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibFractions.sol:\n\t- pragma solidity^0.5.9 (LibFractions.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibFractions.sol#64): it allows old versions\n\t- pragma solidity^0.5.9 (LibFractions.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (LibFractions.sol#216): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibFractions.sol#36-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibFractions.sol#91-106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibFractions.sol#108-121) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/D18.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(b) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(int256(a) >= 0, \"D18/DECIMAL_VALUE_TOO_BIG\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(r / a == b && r / b == a, \"D18/DECIMAL_MUL_OVERFLOW\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(b != 0, \"D18/DECIMAL_DIV_BY_ZERO\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(a != MIN_INT256_VALUE || b != -1, \"D18/DECIMAL_DIV_OVERFLOW\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !((a < 0 && b < 0 && r > a) || (a > 0 && b > 0 && r < a)),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"D18/DECIMAL_ADD_OVERFLOW\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(r / a == b && r / b == a, \"D18/DECIMAL_MUL_OVERFLOW\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !((a < 0 && b < 0 && r > a) || (a > 0 && b > 0 && r < a)),\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"D18/DECIMAL_ADD_OVERFLOW\"\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in D18.sol:\n\t- pragma solidity^0.5.16 (D18.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _mul(int256 a, int256 b)\n\n        private\n\n        pure\n\n        returns (int256 r)\n\n    {\n\n        if (a == 0 || b == 0) {\n\n            return 0;\n\n        }\n\n        r = a * b;\n\n        require(r / a == b && r / b == a, \"D18/DECIMAL_MUL_OVERFLOW\");\n\n        return r;\n",
                    "message": "Function 'D18._mul' (D18.sol#213-224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": 235,
                    "vulnerability_code": "    function _div(int256 a, int256 b)\n\n        private\n\n        pure\n\n        returns (int256 r)\n\n    {\n\n        require(b != 0, \"D18/DECIMAL_DIV_BY_ZERO\");\n\n        require(a != MIN_INT256_VALUE || b != -1, \"D18/DECIMAL_DIV_OVERFLOW\");\n\n        r = a / b;\n",
                    "message": "Function 'D18._div' (D18.sol#227-235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 248,
                    "vulnerability_code": "    function _add(int256 a, int256 b)\n\n        private\n\n        pure\n\n        returns (int256 r)\n\n    {\n\n        r = a + b;\n\n        require(\n\n            !((a < 0 && b < 0 && r > a) || (a > 0 && b > 0 && r < a)),\n\n            \"D18/DECIMAL_ADD_OVERFLOW\"\n\n        );\n",
                    "message": "Function 'D18._add' (D18.sol#238-248) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant PRECISION = 18;\n",
                    "message": "D18.PRECISION (D18.sol#28) is never used in D18\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant PRECISION = 18;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant DECIMAL_ONE = int256(10 ** PRECISION);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant MIN_INT256_VALUE = int256(0x8000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContract\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContract)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContract)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain (LibEIP712.sol#42-82) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message (LibEIP712.sol#89-113) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function hashEIP712Domain(\n\n        string memory name,\n\n        string memory version,\n\n        uint256 chainId,\n\n        address verifyingContract\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\n\n\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n\n        //     keccak256(bytes(name)),\n\n        //     keccak256(bytes(version)),\n\n        //     chainId,\n\n        //     uint256(verifyingContract)\n\n        // ))\n\n\n\n        assembly {\n\n            // Calculate hashes of dynamic data\n\n            let nameHash := keccak256(add(name, 32), mload(name))\n\n            let versionHash := keccak256(add(version, 32), mload(version))\n\n\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            // Store params in memory\n\n            mstore(memPtr, schemaHash)\n\n            mstore(add(memPtr, 32), nameHash)\n\n            mstore(add(memPtr, 64), versionHash)\n\n            mstore(add(memPtr, 96), chainId)\n\n            mstore(add(memPtr, 128), verifyingContract)\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 160)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Domain uses assembly (LibEIP712.sol#42-82)\n\t- LibEIP712.sol#63-80\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibEIP712.hashEIP712Message uses assembly (LibEIP712.sol#89-113)\n\t- LibEIP712.sol#101-111\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibEIP712.sol:\n\t- pragma solidity^0.5.9 (LibEIP712.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Domain(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibSafeMathRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibSafeMathRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibSafeMathRichErrors.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": 45,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibSafeMathRichErrors.sol#30-45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 60,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibSafeMathRichErrors.sol#47-60) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibAddress.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract (LibAddress.sol#36-47) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // XXX Currently there is no better way to check if there is a contract in an address\n\n        // than to check the size of the code at that address.\n\n        // See https://ethereum.stackexchange.com/a/14016/36603\n\n        // for more details about how this works.\n\n        // TODO Check this again before the Serenity release, because all addresses will be\n\n        // contracts then.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly { size := extcodesize(account) }\n\n        return size > 0;\n",
                    "message": "LibAddress.isContract uses assembly (LibAddress.sol#36-47)\n\t- LibAddress.sol#45\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAddress.sol:\n\t- pragma solidity^0.5.9 (LibAddress.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/DeploymentConstants.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in DeploymentConstants.sol:\n\t- pragma solidity^0.5.9 (DeploymentConstants.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function _getKyberNetworkProxyAddress()\n\n        internal\n\n        view\n\n        returns (address kyberAddress)\n\n    {\n\n        return KYBER_NETWORK_PROXY_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getKyberNetworkProxyAddress' (DeploymentConstants.sol#158-164) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": 174,
                    "vulnerability_code": "    function _getKyberHintHandlerAddress()\n\n        internal\n\n        view\n\n        returns (address hintHandlerAddress)\n\n    {\n\n        return KYBER_HINT_HANDLER_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getKyberHintHandlerAddress' (DeploymentConstants.sol#168-174) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": 184,
                    "vulnerability_code": "    function _getWethAddress()\n\n        internal\n\n        view\n\n        returns (address wethAddress)\n\n    {\n\n        return WETH_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getWethAddress' (DeploymentConstants.sol#178-184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": 194,
                    "vulnerability_code": "    function _getUniswapExchangeFactoryAddress()\n\n        internal\n\n        view\n\n        returns (address uniswapAddress)\n\n    {\n\n        return UNISWAP_EXCHANGE_FACTORY_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getUniswapExchangeFactoryAddress' (DeploymentConstants.sol#188-194) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 204,
                    "vulnerability_code": "    function _getUniswapV2Router01Address()\n\n        internal\n\n        view\n\n        returns (address uniswapRouterAddress)\n\n    {\n\n        return UNISWAP_V2_ROUTER_01_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getUniswapV2Router01Address' (DeploymentConstants.sol#198-204) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": 214,
                    "vulnerability_code": "    function _getEth2DaiAddress()\n\n        internal\n\n        view\n\n        returns (address eth2daiAddress)\n\n    {\n\n        return ETH2DAI_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getEth2DaiAddress' (DeploymentConstants.sol#208-214) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _getERC20BridgeProxyAddress()\n\n        internal\n\n        view\n\n        returns (address erc20BridgeProxyAddress)\n\n    {\n\n        return ERC20_BRIDGE_PROXY_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getERC20BridgeProxyAddress' (DeploymentConstants.sol#218-224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 234,
                    "vulnerability_code": "    function _getDaiAddress()\n\n        internal\n\n        view\n\n        returns (address daiAddress)\n\n    {\n\n        return DAI_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getDaiAddress' (DeploymentConstants.sol#228-234) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function _getChaiAddress()\n\n        internal\n\n        view\n\n        returns (address chaiAddress)\n\n    {\n\n        return CHAI_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getChaiAddress' (DeploymentConstants.sol#238-244) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": 254,
                    "vulnerability_code": "    function _getDevUtilsAddress()\n\n        internal\n\n        view\n\n        returns (address devUtils)\n\n    {\n\n        return DEV_UTILS_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getDevUtilsAddress' (DeploymentConstants.sol#248-254) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": 264,
                    "vulnerability_code": "    function _getDydxAddress()\n\n        internal\n\n        view\n\n        returns (address dydxAddress)\n\n    {\n\n        return DYDX_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getDydxAddress' (DeploymentConstants.sol#258-264) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": 274,
                    "vulnerability_code": "    function _getGstAddress()\n\n        internal\n\n        view\n\n        returns (address gst)\n\n    {\n\n        return GST_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getGstAddress' (DeploymentConstants.sol#268-274) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": 284,
                    "vulnerability_code": "    function _getGstCollectorAddress()\n\n        internal\n\n        view\n\n        returns (address collector)\n\n    {\n\n        return GST_COLLECTOR_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getGstCollectorAddress' (DeploymentConstants.sol#278-284) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": 294,
                    "vulnerability_code": "    function _getMUsdAddress()\n\n        internal\n\n        view\n\n        returns (address musd)\n\n    {\n\n        return MUSD_ADDRESS;\n",
                    "message": "Function 'DeploymentConstants._getMUsdAddress' (DeploymentConstants.sol#288-294) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": 304,
                    "vulnerability_code": "    function _getMooniswapAddress()\n\n        internal\n\n        view\n\n        returns (address)\n\n    {\n\n        return MOONISWAP_REGISTRY;\n",
                    "message": "Function 'DeploymentConstants._getMooniswapAddress' (DeploymentConstants.sol#298-304) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": 314,
                    "vulnerability_code": "    function _getDODORegistryAddress()\n\n        internal\n\n        view\n\n        returns (address)\n\n    {\n\n        return DODO_REGISTRY;\n",
                    "message": "Function 'DeploymentConstants._getDODORegistryAddress' (DeploymentConstants.sol#308-314) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 318,
                    "vulnerability_to_line": 324,
                    "vulnerability_code": "    function _getDODOHelperAddress()\n\n        internal\n\n        view\n\n        returns (address)\n\n    {\n\n        return DODO_HELPER;\n",
                    "message": "Function 'DeploymentConstants._getDODOHelperAddress' (DeploymentConstants.sol#318-324) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n",
                    "message": "DeploymentConstants.KYBER_ETH_ADDRESS (DeploymentConstants.sol#50) is never used in DeploymentConstants\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private KYBER_NETWORK_PROXY_ADDRESS = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private KYBER_HINT_HANDLER_ADDRESS = 0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private UNISWAP_EXCHANGE_FACTORY_ADDRESS = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private UNISWAP_V2_ROUTER_01_ADDRESS = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private ETH2DAI_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private ERC20_BRIDGE_PROXY_ADDRESS = 0x8ED95d1746bf1E4dAb58d8ED4724f1Ef95B20Db0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private CHAI_ADDRESS = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DEV_UTILS_ADDRESS = 0x74134CF88b21383713E096a5ecF59e297dc7f547;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DYDX_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private GST_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private GST_COLLECTOR_ADDRESS = 0x000000D3b08566BE75A6DB803C03C85C0c1c5B96;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private MUSD_ADDRESS = 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private MOONISWAP_REGISTRY = 0x71CD6666064C3A1354a3B4dca5fA1E2D3ee7D303;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DODO_REGISTRY = 0x3A97247DF274a17C59A3bd12735ea3FcDFb49950;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DODO_HELPER = 0x533dA777aeDCE766CEAe696bf90f8541A4bA80Eb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private KYBER_NETWORK_PROXY_ADDRESS = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private KYBER_HINT_HANDLER_ADDRESS = 0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private UNISWAP_EXCHANGE_FACTORY_ADDRESS = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private UNISWAP_V2_ROUTER_01_ADDRESS = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private ETH2DAI_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private ERC20_BRIDGE_PROXY_ADDRESS = 0x8ED95d1746bf1E4dAb58d8ED4724f1Ef95B20Db0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private CHAI_ADDRESS = 0x06AF07097C9Eeb7fD685c692751D5C66dB49c215;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DEV_UTILS_ADDRESS = 0x74134CF88b21383713E096a5ecF59e297dc7f547;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DYDX_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private GST_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private GST_COLLECTOR_ADDRESS = 0x000000D3b08566BE75A6DB803C03C85C0c1c5B96;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private MUSD_ADDRESS = 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private MOONISWAP_REGISTRY = 0x71CD6666064C3A1354a3B4dca5fA1E2D3ee7D303;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DODO_REGISTRY = 0x3A97247DF274a17C59A3bd12735ea3FcDFb49950;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant private DODO_HELPER = 0x533dA777aeDCE766CEAe696bf90f8541A4bA80Eb;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibAddressArray.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            freeMemPtr,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressArrayEndPtr\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_34"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibAddressArray.sol#157-164) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (LibAddressArray.sol#199-208) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (LibAddressArray.sol#213-222) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (LibAddressArray.sol#228-329) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (LibAddressArray.sol#378-410) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (LibAddressArray.sol#415-437) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 490,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (LibAddressArray.sol#461-490) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (LibAddressArray.sol#496-539) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (LibAddressArray.sol#545-569) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (LibAddressArray.sol#575-598) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": 662,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (LibAddressArray.sol#635-662) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": 676,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (LibAddressArray.sol#669-676) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append (LibAddressArray.sol#712-766) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains (LibAddressArray.sol#772-802) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": 839,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf (LibAddressArray.sol#808-839) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 164,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibAddressArray.sol#157-164)\n\t- LibAddressArray.sol#161-163\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (LibAddressArray.sol#199-208)\n\t- LibAddressArray.sol#204-206\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": 222,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (LibAddressArray.sol#213-222)\n\t- LibAddressArray.sol#218-220\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 329,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (LibAddressArray.sol#228-329)\n\t- LibAddressArray.sol#240-245\n\t- LibAddressArray.sol#268-295\n\t- LibAddressArray.sol#297-326\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 410,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (LibAddressArray.sol#378-410)\n\t- LibAddressArray.sol#405-408\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (LibAddressArray.sol#415-437)\n\t- LibAddressArray.sol#431-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 490,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (LibAddressArray.sol#461-490)\n\t- LibAddressArray.sol#483-488\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": 539,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (LibAddressArray.sol#496-539)\n\t- LibAddressArray.sol#518-538\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (LibAddressArray.sol#545-569)\n\t- LibAddressArray.sol#565-567\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": 598,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (LibAddressArray.sol#575-598)\n\t- LibAddressArray.sol#595-597\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": 662,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (LibAddressArray.sol#635-662)\n\t- LibAddressArray.sol#655-660\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": 676,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (LibAddressArray.sol#669-676)\n\t- LibAddressArray.sol#673-675\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": 766,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n\n        internal\n\n        pure\n\n        returns (address[] memory)\n\n    {\n\n        // Get stats on address array and free memory\n\n        uint256 freeMemPtr = 0;\n\n        uint256 addressArrayBeginPtr = 0;\n\n        uint256 addressArrayEndPtr = 0;\n\n        uint256 addressArrayLength = addressArray.length;\n\n        uint256 addressArrayMemSizeInBytes = 32 + (32 * addressArrayLength);\n\n        assembly {\n\n            freeMemPtr := mload(0x40)\n\n            addressArrayBeginPtr := addressArray\n\n            addressArrayEndPtr := add(addressArray, addressArrayMemSizeInBytes)\n\n        }\n\n\n\n        // Cases for `freeMemPtr`:\n\n        //  `freeMemPtr` == `addressArrayEndPtr`: Nothing occupies memory after `addressArray`\n\n        //  `freeMemPtr` > `addressArrayEndPtr`: Some value occupies memory after `addressArray`\n\n        //  `freeMemPtr` < `addressArrayEndPtr`: Memory has not been managed properly.\n\n        if (freeMemPtr < addressArrayEndPtr) {\n\n            LibRichErrors.rrevert(LibAddressArrayRichErrors.MismanagedMemoryError(\n\n                freeMemPtr,\n\n                addressArrayEndPtr\n\n            ));\n\n        }\n\n\n\n        // If free memory begins at the end of `addressArray`\n\n        // then we can append `addressToAppend` directly.\n\n        // Otherwise, we must copy the array to free memory\n\n        // before appending new values to it.\n\n        if (freeMemPtr > addressArrayEndPtr) {\n\n            LibBytes.memCopy(freeMemPtr, addressArrayBeginPtr, addressArrayMemSizeInBytes);\n\n            assembly {\n\n                addressArray := freeMemPtr\n\n                addressArrayBeginPtr := addressArray\n\n            }\n\n        }\n\n\n\n        // Append `addressToAppend`\n\n        addressArrayLength += 1;\n\n        addressArrayMemSizeInBytes += 32;\n\n        addressArrayEndPtr = addressArrayBeginPtr + addressArrayMemSizeInBytes;\n\n        freeMemPtr = addressArrayEndPtr;\n\n        assembly {\n\n            // Store new array length\n\n            mstore(addressArray, addressArrayLength)\n\n\n\n            // Update `freeMemPtr`\n\n            mstore(0x40, freeMemPtr)\n\n        }\n\n        addressArray[addressArrayLength - 1] = addressToAppend;\n\n        return addressArray;\n",
                    "message": "LibAddressArray.append uses assembly (LibAddressArray.sol#712-766)\n\t- LibAddressArray.sol#723-727\n\t- LibAddressArray.sol#746-749\n\t- LibAddressArray.sol#757-763\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success to true\n\n                    success := 1\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return success;\n",
                    "message": "LibAddressArray.contains uses assembly (LibAddressArray.sol#772-802)\n\t- LibAddressArray.sol#777-800\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": 839,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n\n        internal\n\n        pure\n\n        returns (bool success, uint256 index)\n\n    {\n\n        assembly {\n\n\n\n            // Calculate byte length of array\n\n            let arrayByteLen := mul(mload(addressArray), 32)\n\n            // Calculate beginning of array contents\n\n            let arrayContentsStart := add(addressArray, 32)\n\n            // Calclulate end of array contents\n\n            let arrayContentsEnd := add(arrayContentsStart, arrayByteLen)\n\n\n\n            // Loop through array\n\n            for {let i:= arrayContentsStart} lt(i, arrayContentsEnd) {i := add(i, 32)} {\n\n\n\n                // Load array element\n\n                let arrayElement := mload(i)\n\n\n\n                // Return true if array element equals target\n\n                if eq(target, arrayElement) {\n\n                    // Set success and index\n\n                    success := 1\n\n                    index := div(sub(i, arrayContentsStart), 32)\n\n                    // Break loop\n\n                    i := arrayContentsEnd\n\n                }\n\n            }\n\n        }\n\n        return (success, index);\n",
                    "message": "LibAddressArray.indexOf uses assembly (LibAddressArray.sol#808-839)\n\t- LibAddressArray.sol#813-837\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAddressArray.sol:\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#126): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#187): it allows old versions\n\t- pragma solidity^0.5.9 (LibAddressArray.sol#699): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
                    "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (LibAddressArray.sol#31-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibAddressArray.sol#88-103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibAddressArray.sol#141-152) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5fc83722;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 669,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(address[] memory addressArray, address addressToAppend)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contains(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(address[] memory addressArray, address target)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bool success, uint256 index)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 655,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 757,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/Refundable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Refundable._refundNonZeroBalance (Refundable.sol#217-224) sends eth to arbitrary user\n\tDangerous calls:\n\t- msg.sender.transfer(balance) (Refundable.sol#222)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (Refundable.sol#91-98) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 98,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (Refundable.sol#91-98)\n\t- Refundable.sol#95-97\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in Refundable.sol:\n\t- pragma solidity^0.5.9 (Refundable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (Refundable.sol#60): it allows old versions\n\t- pragma solidity^0.5.9 (Refundable.sol#121): it allows old versions\n\t- pragma solidity^0.5.9 (Refundable.sol#178): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (Refundable.sol#31-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 86,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (Refundable.sol#75-86) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": 148,
                    "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrors.rrevert(\n\n                LibReentrancyGuardRichErrors.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
                    "message": "Function 'ReentrancyGuard._lockMutexOrThrowIfAlreadyLocked' (Refundable.sol#137-148) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
                    "message": "Function 'ReentrancyGuard._unlockMutex' (Refundable.sol#150-155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 209,
                    "vulnerability_to_line": 215,
                    "vulnerability_code": "    function _refundNonZeroBalanceIfEnabled()\n\n        internal\n\n    {\n\n        if (!_areRefundsDisabled()) {\n\n            _refundNonZeroBalance();\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalanceIfEnabled' (Refundable.sol#209-215) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 224,
                    "vulnerability_code": "    function _refundNonZeroBalance()\n\n        internal\n\n    {\n\n        uint256 balance = address(this).balance;\n\n        if (balance > 0) {\n\n            msg.sender.transfer(balance);\n\n        }\n",
                    "message": "Function 'Refundable._refundNonZeroBalance' (Refundable.sol#217-224) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": 230,
                    "vulnerability_code": "    function _disableRefund()\n\n        internal\n\n    {\n\n        _shouldNotRefund = true;\n",
                    "message": "Function 'Refundable._disableRefund' (Refundable.sol#226-230) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function _enableAndRefundNonZeroBalance()\n\n        internal\n\n    {\n\n        _shouldNotRefund = false;\n\n        _refundNonZeroBalance();\n",
                    "message": "Function 'Refundable._enableAndRefundNonZeroBalance' (Refundable.sol#232-237) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": 245,
                    "vulnerability_code": "    function _areRefundsDisabled()\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _shouldNotRefund;\n",
                    "message": "Function 'Refundable._areRefundsDisabled' (Refundable.sol#239-245) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool internal _shouldNotRefund;\n",
                    "message": "Variable 'Refundable._shouldNotRefund' (Refundable.sol#185) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibBytes.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibBytes.sol#111-118) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (LibBytes.sol#153-162) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (LibBytes.sol#167-176) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (LibBytes.sol#182-283) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (LibBytes.sol#332-364) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (LibBytes.sol#369-391) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 444,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (LibBytes.sol#415-444) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": 493,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (LibBytes.sol#450-493) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (LibBytes.sol#499-523) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": 552,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (LibBytes.sol#529-552) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": 616,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (LibBytes.sol#589-616) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 630,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (LibBytes.sol#623-630) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 118,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibBytes.sol#111-118)\n\t- LibBytes.sol#115-117\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (LibBytes.sol#153-162)\n\t- LibBytes.sol#158-160\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": 176,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (LibBytes.sol#167-176)\n\t- LibBytes.sol#172-174\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (LibBytes.sol#182-283)\n\t- LibBytes.sol#194-199\n\t- LibBytes.sol#222-249\n\t- LibBytes.sol#251-280\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (LibBytes.sol#332-364)\n\t- LibBytes.sol#359-362\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (LibBytes.sol#369-391)\n\t- LibBytes.sol#385-389\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": 444,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (LibBytes.sol#415-444)\n\t- LibBytes.sol#437-442\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": 493,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (LibBytes.sol#450-493)\n\t- LibBytes.sol#472-492\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 523,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (LibBytes.sol#499-523)\n\t- LibBytes.sol#519-521\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": 552,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (LibBytes.sol#529-552)\n\t- LibBytes.sol#549-551\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": 616,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n\n                LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (LibBytes.sol#589-616)\n\t- LibBytes.sol#609-614\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": 630,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (LibBytes.sol#623-630)\n\t- LibBytes.sol#627-629\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibBytes.sol:\n\t- pragma solidity^0.5.9 (LibBytes.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibBytes.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (LibBytes.sol#141): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibBytes.sol#42-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": 106,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibBytes.sol#95-106) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibAuthorizableRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAuthorizableRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibAuthorizableRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function AuthorizedAddressMismatchError(\n\n        address authorized,\n\n        address target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n\n            authorized,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.AuthorizedAddressMismatchError' (LibAuthorizableRichErrors.sol#51-64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 79,
                    "vulnerability_code": "    function IndexOutOfBoundsError(\n\n        uint256 index,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n\n            index,\n\n            length\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.IndexOutOfBoundsError' (LibAuthorizableRichErrors.sol#66-79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function SenderNotAuthorizedError(address sender)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n\n            sender\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.SenderNotAuthorizedError' (LibAuthorizableRichErrors.sol#81-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "    function TargetAlreadyAuthorizedError(address target)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.TargetAlreadyAuthorizedError' (LibAuthorizableRichErrors.sol#92-101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": 112,
                    "vulnerability_code": "    function TargetNotAuthorizedError(address target)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrors.TargetNotAuthorizedError' (LibAuthorizableRichErrors.sol#103-112) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "    function ZeroCantBeAuthorizedError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ZERO_CANT_BE_AUTHORIZED_ERROR_BYTES;\n",
                    "message": "Function 'LibAuthorizableRichErrors.ZeroCantBeAuthorizedError' (LibAuthorizableRichErrors.sol#114-120) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibAddressArrayRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            MISMANAGED_MEMORY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            freeMemPtr,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            addressArrayEndPtr\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAddressArrayRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibAddressArrayRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function MismanagedMemoryError(\n\n        uint256 freeMemPtr,\n\n        uint256 addressArrayEndPtr\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            MISMANAGED_MEMORY_ERROR_SELECTOR,\n\n            freeMemPtr,\n\n            addressArrayEndPtr\n\n        );\n",
                    "message": "Function 'LibAddressArrayRichErrors.MismanagedMemoryError' (LibAddressArrayRichErrors.sol#31-44) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5fc83722;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibBytesRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibBytesRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibBytesRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (LibBytesRichErrors.sol#42-57) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibReentrancyGuardRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibReentrancyGuardRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibReentrancyGuardRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrors.IllegalReentrancyError' (LibReentrancyGuardRichErrors.sol#31-37) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibOwnableRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibOwnableRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibOwnableRichErrors.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 30,
                    "vulnerability_code": "    function OnlyOwnerError(\n\n        address sender,\n\n        address owner\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_OWNER_ERROR_SELECTOR,\n\n            sender,\n\n            owner\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.OnlyOwnerError' (LibOwnableRichErrors.sol#17-30) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 38,
                    "vulnerability_code": "    function TransferOwnerToZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return TRANSFER_OWNER_TO_ZERO_ERROR_BYTES;\n",
                    "message": "Function 'LibOwnableRichErrors.TransferOwnerToZeroError' (LibOwnableRichErrors.sol#32-38) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 10,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/LibRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibRichErrors.sol#52-59) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibRichErrors.sol#52-59)\n\t- LibRichErrors.sol#56-58\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function StandardError(\n\n        string memory message\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibRichErrors.sol#36-47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/LibBytesV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_27"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 115,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (LibBytesV06.sol#108-115) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytesV06.rawAddress (LibBytesV06.sol#150-159) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytesV06.contentAddress (LibBytesV06.sol#164-173) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytesV06.memCopy (LibBytesV06.sol#179-280) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.sliceDestructive (LibBytesV06.sol#330-362) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 389,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.popLastByte (LibBytesV06.sol#367-389) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": 442,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.readAddress (LibBytesV06.sol#413-442) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytesV06.writeAddress (LibBytesV06.sol#448-491) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": 521,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.readBytes32 (LibBytesV06.sol#497-521) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytesV06.writeBytes32 (LibBytesV06.sol#527-550) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": 614,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.readBytes4 (LibBytesV06.sol#587-614) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 628,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytesV06.writeLength (LibBytesV06.sol#621-628) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": 115,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (LibBytesV06.sol#108-115)\n\t- LibBytesV06.sol#112-114\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytesV06.rawAddress uses assembly (LibBytesV06.sol#150-159)\n\t- LibBytesV06.sol#155-157\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n\n        internal\n\n        pure\n\n        returns (uint256 memoryAddress)\n\n    {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytesV06.contentAddress uses assembly (LibBytesV06.sol#164-173)\n\t- LibBytesV06.sol#169-171\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function memCopy(\n\n        uint256 dest,\n\n        uint256 source,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} lt(source, sEnd) {} {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    // solhint-disable-next-line no-empty-blocks\n\n                    for {} slt(dest, dEnd) {} {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytesV06.memCopy uses assembly (LibBytesV06.sol#179-280)\n\t- LibBytesV06.sol#191-196\n\t- LibBytesV06.sol#219-246\n\t- LibBytesV06.sol#248-277\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": 362,
                    "vulnerability_code": "    function sliceDestructive(\n\n        bytes memory b,\n\n        uint256 from,\n\n        uint256 to\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory result)\n\n    {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                from,\n\n                to\n\n            ));\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                to,\n\n                b.length\n\n            ));\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.sliceDestructive uses assembly (LibBytesV06.sol#330-362)\n\t- LibBytesV06.sol#357-360\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": 389,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n\n        internal\n\n        pure\n\n        returns (bytes1 result)\n\n    {\n\n        if (b.length == 0) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                b.length,\n\n                0\n\n            ));\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.popLastByte uses assembly (LibBytesV06.sol#367-389)\n\t- LibBytesV06.sol#383-387\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": 442,
                    "vulnerability_code": "    function readAddress(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (address result)\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.readAddress uses assembly (LibBytesV06.sol#413-442)\n\t- LibBytesV06.sol#435-440\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function writeAddress(\n\n        bytes memory b,\n\n        uint256 index,\n\n        address input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 20) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                b.length,\n\n                index + 20 // 20 is length of address\n\n            ));\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytesV06.writeAddress uses assembly (LibBytesV06.sol#448-491)\n\t- LibBytesV06.sol#470-490\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": 521,
                    "vulnerability_code": "    function readBytes32(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.readBytes32 uses assembly (LibBytesV06.sol#497-521)\n\t- LibBytesV06.sol#517-519\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": 550,
                    "vulnerability_code": "    function writeBytes32(\n\n        bytes memory b,\n\n        uint256 index,\n\n        bytes32 input\n\n    )\n\n        internal\n\n        pure\n\n    {\n\n        if (b.length < index + 32) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                b.length,\n\n                index + 32\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytesV06.writeBytes32 uses assembly (LibBytesV06.sol#527-550)\n\t- LibBytesV06.sol#547-549\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": 614,
                    "vulnerability_code": "    function readBytes4(\n\n        bytes memory b,\n\n        uint256 index\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes4 result)\n\n    {\n\n        if (b.length < index + 4) {\n\n            LibRichErrorsV06.rrevert(LibBytesRichErrorsV06.InvalidByteOperationError(\n\n                LibBytesRichErrorsV06.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                b.length,\n\n                index + 4\n\n            ));\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytesV06.readBytes4 uses assembly (LibBytesV06.sol#587-614)\n\t- LibBytesV06.sol#607-612\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": 628,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytesV06.writeLength uses assembly (LibBytesV06.sol#621-628)\n\t- LibBytesV06.sol#625-627\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibBytesV06.sol:\n\t- pragma solidity^0.6.5 (LibBytesV06.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (LibBytesV06.sol#80): it allows old versions\n\t- pragma solidity^0.6.5 (LibBytesV06.sol#138): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrorsV06.InvalidByteOperationError' (LibBytesV06.sol#42-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 103,
                    "vulnerability_code": "    function StandardError(string memory message)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (LibBytesV06.sol#94-103) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 330,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 621,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 357,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 517,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 625,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/LibSafeMathV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (LibSafeMathV06.sol#49-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (LibSafeMathV06.sol#49-56)\n\t- LibSafeMathV06.sol#53-55\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibSafeMathV06.sol:\n\t- pragma solidity^0.6.5 (LibSafeMathV06.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (LibSafeMathV06.sol#79): it allows old versions\n\t- pragma solidity^0.6.5 (LibSafeMathV06.sol#159): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function StandardError(string memory message)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (LibSafeMathV06.sol#35-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrorsV06.Uint256BinOpError' (LibSafeMathV06.sol#106-121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrorsV06.Uint256DowncastError' (LibSafeMathV06.sol#123-136) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/LibMathV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (LibMathV06.sol#49-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (LibMathV06.sol#49-56)\n\t- LibMathV06.sol#53-55\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibMathV06.sol:\n\t- pragma solidity^0.6.5 (LibMathV06.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (LibMathV06.sol#79): it allows old versions\n\t- pragma solidity^0.6.5 (LibMathV06.sol#159): it allows old versions\n\t- pragma solidity^0.6.5 (LibMathV06.sol#349): it allows old versions\n\t- pragma solidity^0.6.5 (LibMathV06.sol#409): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function StandardError(string memory message)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (LibMathV06.sol#35-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": 121,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrorsV06.Uint256BinOpError' (LibMathV06.sol#106-121) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": 136,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrorsV06.Uint256DowncastError' (LibMathV06.sol#123-136) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": 369,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrorsV06.DivisionByZeroError' (LibMathV06.sol#363-369) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrorsV06.RoundingError' (LibMathV06.sol#371-386) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 360,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/AuthorizableV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 466,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        OwnableV06()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 314,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/OwnableV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/ReentrancyGuardV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (ReentrancyGuardV06.sol#88-95) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": 95,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (ReentrancyGuardV06.sol#88-95)\n\t- ReentrancyGuardV06.sol#92-94\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ReentrancyGuardV06.sol:\n\t- pragma solidity^0.6.5 (ReentrancyGuardV06.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (ReentrancyGuardV06.sol#60): it allows old versions\n\t- pragma solidity^0.6.5 (ReentrancyGuardV06.sol#118): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrorsV06.IllegalReentrancyError' (ReentrancyGuardV06.sol#31-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function StandardError(string memory message)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (ReentrancyGuardV06.sol#74-83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": 145,
                    "vulnerability_code": "    function _lockMutexOrThrowIfAlreadyLocked()\n\n        internal\n\n    {\n\n        // Ensure mutex is unlocked.\n\n        if (_locked) {\n\n            LibRichErrorsV06.rrevert(\n\n                LibReentrancyGuardRichErrorsV06.IllegalReentrancyError()\n\n            );\n\n        }\n\n        // Lock mutex.\n\n        _locked = true;\n",
                    "message": "Function 'ReentrancyGuardV06._lockMutexOrThrowIfAlreadyLocked' (ReentrancyGuardV06.sol#134-145) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 152,
                    "vulnerability_code": "    function _unlockMutex()\n\n        internal\n\n    {\n\n        // Unlock mutex.\n\n        _locked = false;\n",
                    "message": "Function 'ReentrancyGuardV06._unlockMutex' (ReentrancyGuardV06.sol#147-152) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _locked = false;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            STANDARD_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes(message)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (LibRichErrorsV06.sol#49-56) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n\n        internal\n\n        pure\n\n    {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (LibRichErrorsV06.sol#49-56)\n\t- LibRichErrorsV06.sol#53-55\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibRichErrorsV06.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function StandardError(string memory message)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            STANDARD_ERROR_SELECTOR,\n\n            bytes(message)\n\n        );\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (LibRichErrorsV06.sol#35-44) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibReentrancyGuardRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibReentrancyGuardRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibReentrancyGuardRichErrorsV06.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function IllegalReentrancyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ILLEGAL_REENTRANCY_ERROR_SELECTOR_BYTES;\n",
                    "message": "Function 'LibReentrancyGuardRichErrorsV06.IllegalReentrancyError' (LibReentrancyGuardRichErrorsV06.sol#31-37) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibOwnableRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_OWNER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibOwnableRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibOwnableRichErrorsV06.sol#20): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function OnlyOwnerError(\n\n        address sender,\n\n        address owner\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_OWNER_ERROR_SELECTOR,\n\n            sender,\n\n            owner\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrorsV06.OnlyOwnerError' (LibOwnableRichErrorsV06.sol#34-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function TransferOwnerToZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return TRANSFER_OWNER_TO_ZERO_ERROR_BYTES;\n",
                    "message": "Function 'LibOwnableRichErrorsV06.TransferOwnerToZeroError' (LibOwnableRichErrorsV06.sol#49-55) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibBytesRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            offset,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            required\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibBytesRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibBytesRichErrorsV06.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_BYTE_OPERATION_ERROR_SELECTOR,\n\n            errorCode,\n\n            offset,\n\n            required\n\n        );\n",
                    "message": "Function 'LibBytesRichErrorsV06.InvalidByteOperationError' (LibBytesRichErrorsV06.sol#42-57) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibMathRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ROUNDING_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            numerator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            denominator,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibMathRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibMathRichErrorsV06.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function DivisionByZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return DIVISION_BY_ZERO_ERROR;\n",
                    "message": "Function 'LibMathRichErrorsV06.DivisionByZeroError' (LibMathRichErrorsV06.sol#35-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function RoundingError(\n\n        uint256 numerator,\n\n        uint256 denominator,\n\n        uint256 target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ROUNDING_ERROR_SELECTOR,\n\n            numerator,\n\n            denominator,\n\n            target\n\n        );\n",
                    "message": "Function 'LibMathRichErrorsV06.RoundingError' (LibMathRichErrorsV06.sol#43-58) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x339f3de2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibAuthorizableRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            length\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibAuthorizableRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibAuthorizableRichErrorsV06.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function AuthorizedAddressMismatchError(\n\n        address authorized,\n\n        address target\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n\n            authorized,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrorsV06.AuthorizedAddressMismatchError' (LibAuthorizableRichErrorsV06.sol#51-64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 79,
                    "vulnerability_code": "    function IndexOutOfBoundsError(\n\n        uint256 index,\n\n        uint256 length\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n\n            index,\n\n            length\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrorsV06.IndexOutOfBoundsError' (LibAuthorizableRichErrorsV06.sol#66-79) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function SenderNotAuthorizedError(address sender)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n\n            sender\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrorsV06.SenderNotAuthorizedError' (LibAuthorizableRichErrorsV06.sol#81-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 101,
                    "vulnerability_code": "    function TargetAlreadyAuthorizedError(address target)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrorsV06.TargetAlreadyAuthorizedError' (LibAuthorizableRichErrorsV06.sol#92-101) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": 112,
                    "vulnerability_code": "    function TargetNotAuthorizedError(address target)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n\n            target\n\n        );\n",
                    "message": "Function 'LibAuthorizableRichErrorsV06.TargetNotAuthorizedError' (LibAuthorizableRichErrorsV06.sol#103-112) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": 120,
                    "vulnerability_code": "    function ZeroCantBeAuthorizedError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ZERO_CANT_BE_AUTHORIZED_ERROR_BYTES;\n",
                    "message": "Function 'LibAuthorizableRichErrorsV06.ZeroCantBeAuthorizedError' (LibAuthorizableRichErrorsV06.sol#114-120) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/errors/LibSafeMathRichErrorsV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_BINOP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UINT256_DOWNCAST_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibSafeMathRichErrorsV06.sol:\n\t- pragma solidity^0.6.5 (LibSafeMathRichErrorsV06.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function Uint256BinOpError(\n\n        BinOpErrorCodes errorCode,\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_BINOP_ERROR_SELECTOR,\n\n            errorCode,\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrorsV06.Uint256BinOpError' (LibSafeMathRichErrorsV06.sol#48-63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": 78,
                    "vulnerability_code": "    function Uint256DowncastError(\n\n        DowncastErrorCodes errorCode,\n\n        uint256 a\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n\n            errorCode,\n\n            a\n\n        );\n",
                    "message": "Function 'LibSafeMathRichErrorsV06.Uint256DowncastError' (LibSafeMathRichErrorsV06.sol#65-78) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/interfaces/IAuthorizableV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IAuthorizableV06.sol:\n\t- pragma solidity^0.6.5 (IAuthorizableV06.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (IAuthorizableV06.sol#60): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/v06/interfaces/IOwnableV06.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IOwnableV06.sol:\n\t- pragma solidity^0.6.5 (IOwnableV06.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/interfaces/IOwnable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IOwnable.sol#33-34) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IOwnable.sol:\n\t- pragma solidity^0.5.9 (IOwnable.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/utils/contracts/src/interfaces/IAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n",
                    "message": "IOwnable.transferOwnership (IAuthorizable.sol#33-34) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAuthorizable.sol:\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#57): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/test/TestCallTarget.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TestCallTarget/REVERT\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    fallback() external payable {\n\n        if (keccak256(msg.data) == keccak256(REVERTING_DATA)) {\n\n            revert(\"TestCallTarget/REVERT\");\n\n        }\n\n        emit CallTargetCalled(\n\n            address(this),\n\n            msg.sender,\n\n            msg.data,\n\n            msg.value\n\n        );\n\n        bytes4 rval = MAGIC_BYTES;\n\n        assembly {\n\n            mstore(0, rval)\n\n            return(0, 32)\n\n        }\n",
                    "message": "Contract locking ether found in TestCallTarget.sol:\n\tContract TestCallTarget has payable functions:\n\t - fallback (TestCallTarget.sol#37-52)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    fallback() external payable {\n\n        if (keccak256(msg.data) == keccak256(REVERTING_DATA)) {\n\n            revert(\"TestCallTarget/REVERT\");\n\n        }\n\n        emit CallTargetCalled(\n\n            address(this),\n\n            msg.sender,\n\n            msg.data,\n\n            msg.value\n\n        );\n\n        bytes4 rval = MAGIC_BYTES;\n\n        assembly {\n\n            mstore(0, rval)\n\n            return(0, 32)\n\n        }\n",
                    "message": "TestCallTarget.fallback uses assembly (TestCallTarget.sol#37-52)\n\t- TestCallTarget.sol#48-51\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in TestCallTarget.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- TestCallTarget.sol#21 declares pragma solidity^0.6.5\n\t- TestCallTarget.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in TestCallTarget.sol:\n\t- pragma solidity^0.6.5 (TestCallTarget.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 private constant MAGIC_BYTES = 0x12345678;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 private constant MAGIC_BYTES = 0x12345678;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes private constant REVERTING_DATA = hex\"1337\";\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    fallback() external payable {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (keccak256(msg.data) == keccak256(REVERTING_DATA)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (keccak256(msg.data) == keccak256(REVERTING_DATA)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (keccak256(msg.data) == keccak256(REVERTING_DATA)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TestCallTarget/REVERT\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TestCallTarget/REVERT\");\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/test/TestFeeCollectorController.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "init-variables-with-default-value",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public FEE_COLLECTOR_INIT_CODE_HASH = 0;\n",
                    "message": "Uninitialized variables are assigned with the types default value. Explicitly initializing a variable with its default value costs unnecessary gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public FEE_COLLECTOR_INIT_CODE_HASH = 0;\n",
                    "message": "TestFeeCollectorController.FEE_COLLECTOR_INIT_CODE_HASH should be constant (TestFeeCollectorController.sol#29)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in TestFeeCollectorController.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- TestFeeCollectorController.sol#21 declares pragma solidity^0.6.5\n\t- TestFeeCollectorController.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in TestFeeCollectorController.sol:\n\t- pragma solidity^0.6.5 (TestFeeCollectorController.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public FEE_COLLECTOR_INIT_CODE_HASH = 0;\n",
                    "message": "Variable 'TestFeeCollectorController.FEE_COLLECTOR_INIT_CODE_HASH' (TestFeeCollectorController.sol#29) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/test/TestMintableERC20Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceOf[owner] >= amount, \"TestMintableERC20Token/INSUFFICIENT_FUNDS\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                allowance[from][msg.sender] >= amount,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"TestMintableERC20Token/INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceOf[from] >= amount, \"TestMintableERC20Token/INSUFFICIENT_FUNDS\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceOf[owner] >= amount, \"TestMintableERC20Token/INSUFFICIENT_FUNDS\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                allowance[from][msg.sender] >= amount,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"TestMintableERC20Token/INSUFFICIENT_ALLOWANCE\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(balanceOf[from] >= amount, \"TestMintableERC20Token/INSUFFICIENT_FUNDS\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in TestMintableERC20Token.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- TestMintableERC20Token.sol#21 declares pragma solidity^0.6.5\n\t- TestMintableERC20Token.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in TestMintableERC20Token.sol:\n\t- pragma solidity^0.6.5 (TestMintableERC20Token.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/test/TestDelegateCaller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "delegatecall-to-arbitrary-address",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory resultData) = target.delegatecall(callData);\n",
                    "message": "An attacker may perform delegatecall() to an arbitrary address."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "controlled-delegatecall",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function executeDelegateCall(\n\n        address target,\n\n        bytes calldata callData\n\n    )\n\n        external\n\n    {\n\n        (bool success, bytes memory resultData) = target.delegatecall(callData);\n\n        if (!success) {\n\n            assembly { revert(add(resultData, 32), mload(resultData)) }\n\n        }\n\n        assembly { return(add(resultData, 32), mload(resultData)) }\n",
                    "message": "TestDelegateCaller.executeDelegateCall (TestDelegateCaller.sol#26-37) uses delegatecall to a input-controlled function id\n\t(success,resultData) = target.delegatecall(callData) (TestDelegateCaller.sol#32)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function executeDelegateCall(\n\n        address target,\n\n        bytes calldata callData\n\n    )\n\n        external\n\n    {\n\n        (bool success, bytes memory resultData) = target.delegatecall(callData);\n\n        if (!success) {\n\n            assembly { revert(add(resultData, 32), mload(resultData)) }\n\n        }\n\n        assembly { return(add(resultData, 32), mload(resultData)) }\n",
                    "message": "TestDelegateCaller.executeDelegateCall uses assembly (TestDelegateCaller.sol#26-37)\n\t- TestDelegateCaller.sol#34\n\t- TestDelegateCaller.sol#36\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in TestDelegateCaller.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- TestDelegateCaller.sol#21 declares pragma solidity^0.6.5\n\t- TestDelegateCaller.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in TestDelegateCaller.sol:\n\t- pragma solidity^0.6.5 (TestDelegateCaller.sol#21): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function executeDelegateCall(\n\n        address target,\n\n        bytes calldata callData\n\n    )\n\n        external\n\n    {\n\n        (bool success, bytes memory resultData) = target.delegatecall(callData);\n\n        if (!success) {\n\n            assembly { revert(add(resultData, 32), mload(resultData)) }\n\n        }\n\n        assembly { return(add(resultData, 32), mload(resultData)) }\n",
                    "message": "Low level call in TestDelegateCaller.executeDelegateCall (TestDelegateCaller.sol#26-37):\n\t-(success,resultData) = target.delegatecall(callData) TestDelegateCaller.sol#32\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory resultData) = target.delegatecall(callData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { revert(add(resultData, 32), mload(resultData)) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { return(add(resultData, 32), mload(resultData)) }\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/test/ITestSimpleFunctionRegistryFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in ITestSimpleFunctionRegistryFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- ITestSimpleFunctionRegistryFeature.sol#21 declares pragma solidity^0.6.5\n\t- ITestSimpleFunctionRegistryFeature.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ITestSimpleFunctionRegistryFeature.sol:\n\t- pragma solidity^0.6.5 (ITestSimpleFunctionRegistryFeature.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/test/TestPermissionlessTransformerDeployerSuicidal.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in TestPermissionlessTransformerDeployerSuicidal.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- TestPermissionlessTransformerDeployerSuicidal.sol#21 declares pragma solidity^0.6.5\n\t- TestPermissionlessTransformerDeployerSuicidal.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in TestPermissionlessTransformerDeployerSuicidal.sol:\n\t- pragma solidity^0.6.5 (TestPermissionlessTransformerDeployerSuicidal.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/migrations/LibMigrate.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            resultData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant MIGRATE_SUCCESS = 0x2c64c5ef;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory resultData) = target.delegatecall(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/migrations/LibBootstrap.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"NotImplementedError(bytes4)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidBootstrapCallerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actual,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expected\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidDieCallerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actual,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expected\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"BootstrapCallFailedError(address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 115,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            resultData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant BOOTSTRAP_SUCCESS = 0xd150751b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory resultData) = target.delegatecall(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/fixins/FixinEIP712.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyCallableBySelfError(address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"IllegalReentrancyError(bytes4,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            reentrancyFlags\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            resultData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (FixinEIP712.sol#39-43) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (FixinEIP712.sol#39-43)\n\t- FixinEIP712.sol#40-42\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 215,
                    "vulnerability_code": "    constructor(address zeroExAddress) internal {\n\n        // Compute `EIP712_DOMAIN_SEPARATOR`\n\n        {\n\n            uint256 chainId;\n\n            assembly { chainId := chainid() }\n\n            EIP712_DOMAIN_SEPARATOR = keccak256(\n\n                abi.encode(\n\n                    keccak256(\n\n                        \"EIP712Domain(\"\n\n                            \"string name,\"\n\n                            \"string version,\"\n\n                            \"uint256 chainId,\"\n\n                            \"address verifyingContract\"\n\n                        \")\"\n\n                    ),\n\n                    keccak256(\"ZeroEx\"),\n\n                    keccak256(\"1.0.0\"),\n\n                    chainId,\n\n                    zeroExAddress\n\n                )\n\n            );\n\n        }\n",
                    "message": "FixinEIP712.constructor uses assembly (FixinEIP712.sol#193-215)\n\t- FixinEIP712.sol#197\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in FixinEIP712.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- FixinEIP712.sol#22 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#66 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#117 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#182 declares pragma solidity^0.6.5\n\t- FixinEIP712.sol#183 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in FixinEIP712.sol:\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#22): it allows old versions\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#66): it allows old versions\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#117): it allows old versions\n\t- pragma solidity^0.6.5 (FixinEIP712.sol#182): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (FixinEIP712.sol#33-35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function OnlyCallableBySelfError(address sender)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyCallableBySelfError(address)\")),\n\n            sender\n\n        );\n",
                    "message": "Function 'LibCommonRichErrors.OnlyCallableBySelfError' (FixinEIP712.sol#73-82) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function IllegalReentrancyError(bytes4 selector, uint256 reentrancyFlags)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"IllegalReentrancyError(bytes4,uint256)\")),\n\n            selector,\n\n            reentrancyFlags\n\n        );\n",
                    "message": "Function 'LibCommonRichErrors.IllegalReentrancyError' (FixinEIP712.sol#84-94) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function OnlyOwnerError(\n\n        address sender,\n\n        address owner\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n\n            sender,\n\n            owner\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.OnlyOwnerError' (FixinEIP712.sol#124-137) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    function TransferOwnerToZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.TransferOwnerToZeroError' (FixinEIP712.sol#139-147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function MigrateCallFailedError(address target, bytes memory resultData)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n\n            target,\n\n            resultData\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.MigrateCallFailedError' (FixinEIP712.sol#149-159) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function _getEIP712Hash(bytes32 structHash)\n\n        internal\n\n        view\n\n        returns (bytes32 eip712Hash)\n\n    {\n\n        return keccak256(abi.encodePacked(\n\n            hex\"1901\",\n\n            EIP712_DOMAIN_SEPARATOR,\n\n            structHash\n\n        ));\n",
                    "message": "Function 'FixinEIP712._getEIP712Hash' (FixinEIP712.sol#217-227) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 public immutable EIP712_DOMAIN_SEPARATOR;\n",
                    "message": "Variable 'FixinEIP712.EIP712_DOMAIN_SEPARATOR' (FixinEIP712.sol#191) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { chainId := chainid() }\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/IOwnableFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in IOwnableFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- IOwnableFeature.sol#22 declares pragma solidity^0.6.5\n\t- IOwnableFeature.sol#59 declares pragma solidity^0.6.5\n\t- IOwnableFeature.sol#60 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IOwnableFeature.sol:\n\t- pragma solidity^0.6.5 (IOwnableFeature.sol#22): it allows old versions\n\t- pragma solidity^0.6.5 (IOwnableFeature.sol#59): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrate(address target, bytes calldata data, address newOwner) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrate(address target, bytes calldata data, address newOwner) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function migrate(address target, bytes calldata data, address newOwner) external;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/ILiquidityProviderFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in ILiquidityProviderFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- ILiquidityProviderFeature.sol#21 declares pragma solidity^0.6.5\n\t- ILiquidityProviderFeature.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ILiquidityProviderFeature.sol:\n\t- pragma solidity^0.6.5 (ILiquidityProviderFeature.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sellToLiquidityProvider(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable provider,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address recipient,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 sellAmount,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 minBuyAmount,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata auxiliaryData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256 boughtAmount);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/IFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in IFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- IFeature.sol#21 declares pragma solidity^0.6.5\n\t- IFeature.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IFeature.sol:\n\t- pragma solidity^0.6.5 (IFeature.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function FEATURE_NAME() external view returns (string memory name);\n",
                    "message": "Function 'IFeature.FEATURE_NAME' (IFeature.sol#31) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function FEATURE_VERSION() external view returns (uint256 version);\n",
                    "message": "Function 'IFeature.FEATURE_VERSION' (IFeature.sol#34) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/IBootstrapFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in IBootstrapFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- IBootstrapFeature.sol#21 declares pragma solidity^0.6.5\n\t- IBootstrapFeature.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IBootstrapFeature.sol:\n\t- pragma solidity^0.6.5 (IBootstrapFeature.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/ISimpleFunctionRegistryFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in ISimpleFunctionRegistryFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- ISimpleFunctionRegistryFeature.sol#21 declares pragma solidity^0.6.5\n\t- ISimpleFunctionRegistryFeature.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ISimpleFunctionRegistryFeature.sol:\n\t- pragma solidity^0.6.5 (ISimpleFunctionRegistryFeature.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/ISignatureValidatorFeature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in ISignatureValidatorFeature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- ISignatureValidatorFeature.sol#21 declares pragma solidity^0.6.5\n\t- ISignatureValidatorFeature.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ISignatureValidatorFeature.sol:\n\t- pragma solidity^0.6.5 (ISignatureValidatorFeature.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/features/libs/LibSignature.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32,address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            code,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            hash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            code,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 112,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            hash\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 113,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_11"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert (LibSignature.sol#39-43) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function getSignerOfHash(\n\n        bytes32 hash,\n\n        Signature memory signature\n\n    )\n\n        internal\n\n        pure\n\n        returns (address recovered)\n\n    {\n\n        // Ensure this is a signature type that can be validated against a hash.\n\n        _validateHashCompatibleSignature(hash, signature);\n\n\n\n        if (signature.signatureType == SignatureType.EIP712) {\n\n            // Signed using EIP712\n\n            recovered = ecrecover(\n\n                hash,\n\n                signature.v,\n\n                signature.r,\n\n                signature.s\n\n            );\n\n        } else if (signature.signatureType == SignatureType.ETHSIGN) {\n\n            // Signed using `eth_sign`\n\n            // Need to hash `hash` with \"\\x19Ethereum Signed Message:\\n32\" prefix\n\n            // in packed encoding.\n\n            bytes32 ethSignHash;\n\n            assembly {\n\n                // Use scratch space\n\n                mstore(0, ETH_SIGN_HASH_PREFIX) // length of 28 bytes\n\n                mstore(28, hash) // length of 32 bytes\n\n                ethSignHash := keccak256(0, 60)\n\n            }\n\n            recovered = ecrecover(\n\n                ethSignHash,\n\n                signature.v,\n\n                signature.r,\n\n                signature.s\n\n            );\n\n        }\n\n        // `recovered` can be null if the signature values are out of range.\n\n        if (recovered == address(0)) {\n\n            LibSignatureRichErrors.SignatureValidationError(\n\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n\n                hash\n\n            ).rrevert();\n\n        }\n",
                    "message": "LibSignature.getSignerOfHash (LibSignature.sol#181-225) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrorsV06.rrevert uses assembly (LibSignature.sol#39-43)\n\t- LibSignature.sol#40-42\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function getSignerOfHash(\n\n        bytes32 hash,\n\n        Signature memory signature\n\n    )\n\n        internal\n\n        pure\n\n        returns (address recovered)\n\n    {\n\n        // Ensure this is a signature type that can be validated against a hash.\n\n        _validateHashCompatibleSignature(hash, signature);\n\n\n\n        if (signature.signatureType == SignatureType.EIP712) {\n\n            // Signed using EIP712\n\n            recovered = ecrecover(\n\n                hash,\n\n                signature.v,\n\n                signature.r,\n\n                signature.s\n\n            );\n\n        } else if (signature.signatureType == SignatureType.ETHSIGN) {\n\n            // Signed using `eth_sign`\n\n            // Need to hash `hash` with \"\\x19Ethereum Signed Message:\\n32\" prefix\n\n            // in packed encoding.\n\n            bytes32 ethSignHash;\n\n            assembly {\n\n                // Use scratch space\n\n                mstore(0, ETH_SIGN_HASH_PREFIX) // length of 28 bytes\n\n                mstore(28, hash) // length of 32 bytes\n\n                ethSignHash := keccak256(0, 60)\n\n            }\n\n            recovered = ecrecover(\n\n                ethSignHash,\n\n                signature.v,\n\n                signature.r,\n\n                signature.s\n\n            );\n\n        }\n\n        // `recovered` can be null if the signature values are out of range.\n\n        if (recovered == address(0)) {\n\n            LibSignatureRichErrors.SignatureValidationError(\n\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n\n                hash\n\n            ).rrevert();\n\n        }\n",
                    "message": "LibSignature.getSignerOfHash uses assembly (LibSignature.sol#181-225)\n\t- LibSignature.sol#205-210\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in LibSignature.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- LibSignature.sol#22 declares pragma solidity^0.6.5\n\t- LibSignature.sol#66 declares pragma solidity^0.6.5\n\t- LibSignature.sol#137 declares pragma solidity^0.6.5\n\t- LibSignature.sol#138 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibSignature.sol:\n\t- pragma solidity^0.6.5 (LibSignature.sol#22): it allows old versions\n\t- pragma solidity^0.6.5 (LibSignature.sol#66): it allows old versions\n\t- pragma solidity^0.6.5 (LibSignature.sol#137): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrorsV06.StandardError' (LibSignature.sol#33-35) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": 99,
                    "vulnerability_code": "    function SignatureValidationError(\n\n        SignatureValidationErrorCodes code,\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes memory signature\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32,address,bytes)\")),\n\n            code,\n\n            hash,\n\n            signerAddress,\n\n            signature\n\n        );\n",
                    "message": "Function 'LibSignatureRichErrors.SignatureValidationError' (LibSignature.sol#82-99) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function SignatureValidationError(\n\n        SignatureValidationErrorCodes code,\n\n        bytes32 hash\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32)\")),\n\n            code,\n\n            hash\n\n        );\n",
                    "message": "Function 'LibSignatureRichErrors.SignatureValidationError' (LibSignature.sol#101-114) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function _validateHashCompatibleSignature(\n\n        bytes32 hash,\n\n        Signature memory signature\n\n    )\n\n        private\n\n        pure\n\n    {\n\n        // Ensure the r and s are within malleability limits.\n\n        if (uint256(signature.r) >= ECDSA_SIGNATURE_R_LIMIT ||\n\n            uint256(signature.s) >= ECDSA_SIGNATURE_S_LIMIT)\n\n        {\n\n            LibSignatureRichErrors.SignatureValidationError(\n\n                LibSignatureRichErrors.SignatureValidationErrorCodes.BAD_SIGNATURE_DATA,\n\n                hash\n\n            ).rrevert();\n\n        }\n\n\n\n        // Always illegal signature.\n\n        if (signature.signatureType == SignatureType.ILLEGAL) {\n\n            LibSignatureRichErrors.SignatureValidationError(\n\n                LibSignatureRichErrors.SignatureValidationErrorCodes.ILLEGAL,\n\n                hash\n\n            ).rrevert();\n\n        }\n\n\n\n        // Always invalid.\n\n        if (signature.signatureType == SignatureType.INVALID) {\n\n            LibSignatureRichErrors.SignatureValidationError(\n\n                LibSignatureRichErrors.SignatureValidationErrorCodes.ALWAYS_INVALID,\n\n                hash\n\n            ).rrevert();\n\n        }\n\n\n\n        // Solidity should check that the signature type is within enum range for us\n\n        // when abi-decoding.\n",
                    "message": "Function 'LibSignature._validateHashCompatibleSignature' (LibSignature.sol#230-265) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 147,
                    "vulnerability_code": "    uint256 private constant ETH_SIGN_HASH_PREFIX =\n",
                    "message": "LibSignature.ETH_SIGN_HASH_PREFIX (LibSignature.sol#146-147) is never used in LibSignature\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant ETH_SIGN_HASH_PREFIX =\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant ECDSA_SIGNATURE_R_LIMIT =\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant ECDSA_SIGNATURE_S_LIMIT = ECDSA_SIGNATURE_R_LIMIT / 2 + 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getSignerOfHash(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/storage/LibStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in LibStorage.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- LibStorage.sol#21 declares pragma solidity^0.6.5\n\t- LibStorage.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibStorage.sol:\n\t- pragma solidity^0.6.5 (LibStorage.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 private constant STORAGE_SLOT_EXP = 128;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/transformers/bridges/IBridgeAdapter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IBridgeAdapter.sol:\n\t- pragma solidity^0.6.5 (IBridgeAdapter.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/transformers/bridges/mixins/MixinAdapterAddresses.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in MixinAdapterAddresses.sol:\n\t- pragma solidity^0.6.5 (MixinAdapterAddresses.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/external/PermissionlessTransformerDeployer.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < extcode.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < extcode.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(deployedAddress != address(0), 'PermissionlessTransformerDeployer/DEPLOY_FAILED');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isDelegateCallSafe(deployedAddress), 'PermissionlessTransformerDeployer/UNSAFE_CODE');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(size > 0, 'PermissionlessTransformerDeployer/NO_CODE');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (op > 95 && op < 128) { // pushN\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                i += (op - 95);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                continue;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < extcode.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(deployedAddress != address(0), 'PermissionlessTransformerDeployer/DEPLOY_FAILED');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isDelegateCallSafe(deployedAddress), 'PermissionlessTransformerDeployer/UNSAFE_CODE');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(size > 0, 'PermissionlessTransformerDeployer/NO_CODE');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function isDelegateCallSafe(address target) public view returns (bool) {\n\n        uint256 size;\n\n        assembly { size := extcodesize(target) }\n\n        require(size > 0, 'PermissionlessTransformerDeployer/NO_CODE');\n\n\n\n        bytes memory extcode = new bytes(size);\n\n        assembly {\n\n            extcodecopy(target, add(extcode, 32), 0, size)\n\n        }\n\n\n\n        // Look for any reachable, impermissible opcodes.\n\n        bool reachable = true;\n\n        for (uint256 i = 0; i < extcode.length; i++) {\n\n            uint8 op = uint8(extcode[i]);\n\n\n\n            // If the opcode is a PUSH, skip over the push data.\n\n            if (op > 95 && op < 128) { // pushN\n\n                i += (op - 95);\n\n                continue;\n\n            }\n\n\n\n            if (reachable) {\n\n                // If execution is halted, mark subsequent opcodes unreachable.\n\n                if (\n\n                    op == 254 || // invalid\n\n                    op == 243 || // return\n\n                    op == 253 || // revert\n\n                    op == 86  || // jump\n\n                    op == 0      // stop\n\n                ) {\n\n                    reachable = false;\n\n                    continue;\n\n                }\n\n\n\n                // If opcode is impermissible, contract is unsafe.\n\n                if (\n\n                    op == 242 || // callcode\n\n                    op == 244 || // delegatecall\n\n                    op == 255 || // selfdestruct\n\n                    op == 240 || // create\n\n                    op == 245 || // create2\n\n                    op == 84  || // sload\n\n                    op == 85     // sstore\n\n                ) {\n\n                    return false;\n\n                }\n\n            } else if (op == 91) { // jumpdest\n\n                // After a JUMPDEST, opcodes are reachable again.\n\n                reachable = true;\n\n            }\n\n        }\n\n\n\n        return true; // No impermissible opcodes found.\n",
                    "message": "PermissionlessTransformerDeployer.isDelegateCallSafe (PermissionlessTransformerDeployer.sol#61-114) is declared view but contains assembly code\n"
                },
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function deploy(bytes memory bytecode, bytes32 salt)\n\n        public\n\n        payable\n\n        returns (address deployedAddress)\n\n    {\n\n        assembly {\n\n            deployedAddress := create2(callvalue(), add(bytecode, 32), mload(bytecode), salt)\n\n        }\n\n        require(deployedAddress != address(0), 'PermissionlessTransformerDeployer/DEPLOY_FAILED');\n\n        require(isDelegateCallSafe(deployedAddress), 'PermissionlessTransformerDeployer/UNSAFE_CODE');\n\n        toDeploymentSalt[deployedAddress] = salt;\n\n        toInitCodeHash[deployedAddress] = keccak256(bytecode);\n\n        emit Deployed(deployedAddress, salt, msg.sender);\n",
                    "message": "Contract locking ether found in PermissionlessTransformerDeployer.sol:\n\tContract PermissionlessTransformerDeployer has payable functions:\n\t - deploy (PermissionlessTransformerDeployer.sol#39-52)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function deploy(bytes memory bytecode, bytes32 salt)\n\n        public\n\n        payable\n\n        returns (address deployedAddress)\n\n    {\n\n        assembly {\n\n            deployedAddress := create2(callvalue(), add(bytecode, 32), mload(bytecode), salt)\n\n        }\n\n        require(deployedAddress != address(0), 'PermissionlessTransformerDeployer/DEPLOY_FAILED');\n\n        require(isDelegateCallSafe(deployedAddress), 'PermissionlessTransformerDeployer/UNSAFE_CODE');\n\n        toDeploymentSalt[deployedAddress] = salt;\n\n        toInitCodeHash[deployedAddress] = keccak256(bytecode);\n\n        emit Deployed(deployedAddress, salt, msg.sender);\n",
                    "message": "PermissionlessTransformerDeployer.deploy uses assembly (PermissionlessTransformerDeployer.sol#39-52)\n\t- PermissionlessTransformerDeployer.sol#44-46\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": 114,
                    "vulnerability_code": "    function isDelegateCallSafe(address target) public view returns (bool) {\n\n        uint256 size;\n\n        assembly { size := extcodesize(target) }\n\n        require(size > 0, 'PermissionlessTransformerDeployer/NO_CODE');\n\n\n\n        bytes memory extcode = new bytes(size);\n\n        assembly {\n\n            extcodecopy(target, add(extcode, 32), 0, size)\n\n        }\n\n\n\n        // Look for any reachable, impermissible opcodes.\n\n        bool reachable = true;\n\n        for (uint256 i = 0; i < extcode.length; i++) {\n\n            uint8 op = uint8(extcode[i]);\n\n\n\n            // If the opcode is a PUSH, skip over the push data.\n\n            if (op > 95 && op < 128) { // pushN\n\n                i += (op - 95);\n\n                continue;\n\n            }\n\n\n\n            if (reachable) {\n\n                // If execution is halted, mark subsequent opcodes unreachable.\n\n                if (\n\n                    op == 254 || // invalid\n\n                    op == 243 || // return\n\n                    op == 253 || // revert\n\n                    op == 86  || // jump\n\n                    op == 0      // stop\n\n                ) {\n\n                    reachable = false;\n\n                    continue;\n\n                }\n\n\n\n                // If opcode is impermissible, contract is unsafe.\n\n                if (\n\n                    op == 242 || // callcode\n\n                    op == 244 || // delegatecall\n\n                    op == 255 || // selfdestruct\n\n                    op == 240 || // create\n\n                    op == 245 || // create2\n\n                    op == 84  || // sload\n\n                    op == 85     // sstore\n\n                ) {\n\n                    return false;\n\n                }\n\n            } else if (op == 91) { // jumpdest\n\n                // After a JUMPDEST, opcodes are reachable again.\n\n                reachable = true;\n\n            }\n\n        }\n\n\n\n        return true; // No impermissible opcodes found.\n",
                    "message": "PermissionlessTransformerDeployer.isDelegateCallSafe uses assembly (PermissionlessTransformerDeployer.sol#61-114)\n\t- PermissionlessTransformerDeployer.sol#63\n\t- PermissionlessTransformerDeployer.sol#67-69\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in PermissionlessTransformerDeployer.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- PermissionlessTransformerDeployer.sol#21 declares pragma solidity^0.6.5\n\t- PermissionlessTransformerDeployer.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function deploy(bytes memory bytecode, bytes32 salt)\n\n        public\n\n        payable\n\n        returns (address deployedAddress)\n\n    {\n\n        assembly {\n\n            deployedAddress := create2(callvalue(), add(bytecode, 32), mload(bytecode), salt)\n\n        }\n\n        require(deployedAddress != address(0), 'PermissionlessTransformerDeployer/DEPLOY_FAILED');\n\n        require(isDelegateCallSafe(deployedAddress), 'PermissionlessTransformerDeployer/UNSAFE_CODE');\n\n        toDeploymentSalt[deployedAddress] = salt;\n\n        toInitCodeHash[deployedAddress] = keccak256(bytecode);\n\n        emit Deployed(deployedAddress, salt, msg.sender);\n",
                    "message": "PermissionlessTransformerDeployer.deploy (PermissionlessTransformerDeployer.sol#39-52) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in PermissionlessTransformerDeployer.sol:\n\t- pragma solidity^0.6.5 (PermissionlessTransformerDeployer.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < extcode.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < extcode.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract PermissionlessTransformerDeployer {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isDelegateCallSafe(address target) public view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/external/IFlashWallet.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in IFlashWallet.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- IFlashWallet.sol#22 declares pragma solidity^0.6.5\n\t- IFlashWallet.sol#59 declares pragma solidity^0.6.5\n\t- IFlashWallet.sol#60 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IFlashWallet.sol:\n\t- pragma solidity^0.6.5 (IFlashWallet.sol#22): it allows old versions\n\t- pragma solidity^0.6.5 (IFlashWallet.sol#59): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeCall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeDelegateCall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable target,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata callData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata callData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 value\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 77,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory resultData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable target,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata callData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory resultData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    receive() external payable;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/external/TransformerDeployer.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR, authorized, target);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR, index, length);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(SENDER_NOT_AUTHORIZED_ERROR_SELECTOR, sender);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 197,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR, target);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(TARGET_NOT_AUTHORIZED_ERROR_SELECTOR, target);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < initialAuthorities.length; ++i) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "inefficient-state-variable-increment",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        nonce += 1;\n",
                    "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public OwnableV06() {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address[] memory initialAuthorities) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < initialAuthorities.length; ++i) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _addAuthorizedAddress(initialAuthorities[i]);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < initialAuthorities.length; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(deployedAddress != address(0), 'TransformerDeployer/DEPLOY_FAILED');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(deployedAddress != address(0), 'TransformerDeployer/DEPLOY_FAILED');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR = 0x140a84db;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR = 0xe9f83771;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant SENDER_NOT_AUTHORIZED_ERROR_SELECTOR = 0xb65a25b9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR = 0xde16f1a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant TARGET_NOT_AUTHORIZED_ERROR_SELECTOR = 0xeb5108a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < initialAuthorities.length; ++i) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < initialAuthorities.length; ++i) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TransformerDeployer is\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 325,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function die(address payable ethRecipient) external;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function kill(IKillable target, address payable ethRecipient)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        target.die(ethRecipient);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit Killed(address(target), msg.sender);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit Killed(address(target), msg.sender);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit Killed(address(target), msg.sender);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit Killed(address(target), msg.sender);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/external/LibFeeCollector.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in LibFeeCollector.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- LibFeeCollector.sol#21 declares pragma solidity^0.6.5\n\t- LibFeeCollector.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibFeeCollector.sol:\n\t- pragma solidity^0.6.5 (LibFeeCollector.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (address payable feeCollectorAddress)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return address(uint256(keccak256(abi.encodePacked(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return address(uint256(keccak256(abi.encodePacked(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return address(uint256(keccak256(abi.encodePacked(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return address(uint256(keccak256(abi.encodePacked(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return address(uint256(keccak256(abi.encodePacked(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            byte(0xff),\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId, // pool ID is salt\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/external/IAllowanceTarget.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function executeCall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable target,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 130,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata callData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes memory resultData);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/external/ILiquidityProviderSandbox.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in ILiquidityProviderSandbox.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- ILiquidityProviderSandbox.sol#21 declares pragma solidity^0.6.5\n\t- ILiquidityProviderSandbox.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ILiquidityProviderSandbox.sol:\n\t- pragma solidity^0.6.5 (ILiquidityProviderSandbox.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibLiquidityProviderRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"LiquidityProviderIncompleteSellError(address,address,address,uint256,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            providerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            makerToken,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            takerToken,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sellAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            boughtAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minBuyAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibLiquidityProviderRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibLiquidityProviderRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function LiquidityProviderIncompleteSellError(\n\n        address providerAddress,\n\n        address makerToken,\n\n        address takerToken,\n\n        uint256 sellAmount,\n\n        uint256 boughtAmount,\n\n        uint256 minBuyAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"LiquidityProviderIncompleteSellError(address,address,address,uint256,uint256,uint256)\")),\n\n            providerAddress,\n\n            makerToken,\n\n            takerToken,\n\n            sellAmount,\n\n            boughtAmount,\n\n            minBuyAmount\n\n        );\n",
                    "message": "Function 'LibLiquidityProviderRichErrors.LiquidityProviderIncompleteSellError' (LibLiquidityProviderRichErrors.sol#28-49) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibSignatureRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32,address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            code,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            hash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signerAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            code,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            hash\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibSignatureRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibSignatureRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 54,
                    "vulnerability_code": "    function SignatureValidationError(\n\n        SignatureValidationErrorCodes code,\n\n        bytes32 hash,\n\n        address signerAddress,\n\n        bytes memory signature\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32,address,bytes)\")),\n\n            code,\n\n            hash,\n\n            signerAddress,\n\n            signature\n\n        );\n",
                    "message": "Function 'LibSignatureRichErrors.SignatureValidationError' (LibSignatureRichErrors.sol#37-54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": 69,
                    "vulnerability_code": "    function SignatureValidationError(\n\n        SignatureValidationErrorCodes code,\n\n        bytes32 hash\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"SignatureValidationError(uint8,bytes32)\")),\n\n            code,\n\n            hash\n\n        );\n",
                    "message": "Function 'LibSignatureRichErrors.SignatureValidationError' (LibSignatureRichErrors.sol#56-69) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibSpenderRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"SpenderERC20TransferFromFailedError(address,address,address,uint256,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            token,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            to,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibSpenderRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibSpenderRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function SpenderERC20TransferFromFailedError(\n\n        address token,\n\n        address owner,\n\n        address to,\n\n        uint256 amount,\n\n        bytes memory errorData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"SpenderERC20TransferFromFailedError(address,address,address,uint256,bytes)\")),\n\n            token,\n\n            owner,\n\n            to,\n\n            amount,\n\n            errorData\n\n        );\n",
                    "message": "Function 'LibSpenderRichErrors.SpenderERC20TransferFromFailedError' (LibSpenderRichErrors.sol#28-47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibWalletRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"WalletExecuteCallFailedError(address,address,bytes,uint256,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            wallet,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            callTarget,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            callData,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            callValue,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"WalletExecuteDelegateCallFailedError(address,address,bytes,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            wallet,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            callTarget,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            callData,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibWalletRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibWalletRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function WalletExecuteCallFailedError(\n\n        address wallet,\n\n        address callTarget,\n\n        bytes memory callData,\n\n        uint256 callValue,\n\n        bytes memory errorData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"WalletExecuteCallFailedError(address,address,bytes,uint256,bytes)\")),\n\n            wallet,\n\n            callTarget,\n\n            callData,\n\n            callValue,\n\n            errorData\n\n        );\n",
                    "message": "Function 'LibWalletRichErrors.WalletExecuteCallFailedError' (LibWalletRichErrors.sol#28-47) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function WalletExecuteDelegateCallFailedError(\n\n        address wallet,\n\n        address callTarget,\n\n        bytes memory callData,\n\n        bytes memory errorData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"WalletExecuteDelegateCallFailedError(address,address,bytes,bytes)\")),\n\n            wallet,\n\n            callTarget,\n\n            callData,\n\n            errorData\n\n        );\n",
                    "message": "Function 'LibWalletRichErrors.WalletExecuteDelegateCallFailedError' (LibWalletRichErrors.sol#49-66) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibTransformERC20RichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InsufficientEthAttachedError(uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethAttached,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethNeeded\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"IncompleteTransformERC20Error(address,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            outputToken,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            outputTokenAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minOutputTokenAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"NegativeTransformERC20OutputError(address,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            outputToken,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            outputTokenLostAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"TransformerFailedError(address,bytes,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transformer,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transformerData,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            resultData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyCallableByDeployerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            caller,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            deployer\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidExecutionContextError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actualContext,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedContext\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidTransformDataError(uint8,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCode,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            transformData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"IncompleteFillSellQuoteError(address,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sellToken,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            soldAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sellAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"IncompleteFillBuyQuoteError(address,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            buyToken,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            boughtAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            buyAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InsufficientTakerTokenError(uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokenBalance,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tokensNeeded\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InsufficientProtocolFeeError(uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethBalance,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 206,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethNeeded\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 217,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidERC20AssetDataError(bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assetData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidTakerFeeTokenError(address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            token\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_14"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibTransformERC20RichErrors.sol:\n\t- pragma solidity^0.6.5 (LibTransformERC20RichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function InsufficientEthAttachedError(\n\n        uint256 ethAttached,\n\n        uint256 ethNeeded\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InsufficientEthAttachedError(uint256,uint256)\")),\n\n            ethAttached,\n\n            ethNeeded\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InsufficientEthAttachedError' (LibTransformERC20RichErrors.sol#28-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function IncompleteTransformERC20Error(\n\n        address outputToken,\n\n        uint256 outputTokenAmount,\n\n        uint256 minOutputTokenAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"IncompleteTransformERC20Error(address,uint256,uint256)\")),\n\n            outputToken,\n\n            outputTokenAmount,\n\n            minOutputTokenAmount\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.IncompleteTransformERC20Error' (LibTransformERC20RichErrors.sol#43-58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function NegativeTransformERC20OutputError(\n\n        address outputToken,\n\n        uint256 outputTokenLostAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"NegativeTransformERC20OutputError(address,uint256)\")),\n\n            outputToken,\n\n            outputTokenLostAmount\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.NegativeTransformERC20OutputError' (LibTransformERC20RichErrors.sol#60-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function TransformerFailedError(\n\n        address transformer,\n\n        bytes memory transformerData,\n\n        bytes memory resultData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"TransformerFailedError(address,bytes,bytes)\")),\n\n            transformer,\n\n            transformerData,\n\n            resultData\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.TransformerFailedError' (LibTransformERC20RichErrors.sol#75-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function OnlyCallableByDeployerError(\n\n        address caller,\n\n        address deployer\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyCallableByDeployerError(address,address)\")),\n\n            caller,\n\n            deployer\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.OnlyCallableByDeployerError' (LibTransformERC20RichErrors.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function InvalidExecutionContextError(\n\n        address actualContext,\n\n        address expectedContext\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidExecutionContextError(address,address)\")),\n\n            actualContext,\n\n            expectedContext\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InvalidExecutionContextError' (LibTransformERC20RichErrors.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": 142,
                    "vulnerability_code": "    function InvalidTransformDataError(\n\n        InvalidTransformDataErrorCode errorCode,\n\n        bytes memory transformData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidTransformDataError(uint8,bytes)\")),\n\n            errorCode,\n\n            transformData\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InvalidTransformDataError' (LibTransformERC20RichErrors.sol#129-142) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": 161,
                    "vulnerability_code": "    function IncompleteFillSellQuoteError(\n\n        address sellToken,\n\n        uint256 soldAmount,\n\n        uint256 sellAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"IncompleteFillSellQuoteError(address,uint256,uint256)\")),\n\n            sellToken,\n\n            soldAmount,\n\n            sellAmount\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.IncompleteFillSellQuoteError' (LibTransformERC20RichErrors.sol#146-161) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": 178,
                    "vulnerability_code": "    function IncompleteFillBuyQuoteError(\n\n        address buyToken,\n\n        uint256 boughtAmount,\n\n        uint256 buyAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"IncompleteFillBuyQuoteError(address,uint256,uint256)\")),\n\n            buyToken,\n\n            boughtAmount,\n\n            buyAmount\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.IncompleteFillBuyQuoteError' (LibTransformERC20RichErrors.sol#163-178) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": 193,
                    "vulnerability_code": "    function InsufficientTakerTokenError(\n\n        uint256 tokenBalance,\n\n        uint256 tokensNeeded\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InsufficientTakerTokenError(uint256,uint256)\")),\n\n            tokenBalance,\n\n            tokensNeeded\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InsufficientTakerTokenError' (LibTransformERC20RichErrors.sol#180-193) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function InsufficientProtocolFeeError(\n\n        uint256 ethBalance,\n\n        uint256 ethNeeded\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InsufficientProtocolFeeError(uint256,uint256)\")),\n\n            ethBalance,\n\n            ethNeeded\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InsufficientProtocolFeeError' (LibTransformERC20RichErrors.sol#195-208) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": 221,
                    "vulnerability_code": "    function InvalidERC20AssetDataError(\n\n        bytes memory assetData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidERC20AssetDataError(bytes)\")),\n\n            assetData\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InvalidERC20AssetDataError' (LibTransformERC20RichErrors.sol#210-221) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": 234,
                    "vulnerability_code": "    function InvalidTakerFeeTokenError(\n\n        address token\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidTakerFeeTokenError(address)\")),\n\n            token\n\n        );\n",
                    "message": "Function 'LibTransformERC20RichErrors.InvalidTakerFeeTokenError' (LibTransformERC20RichErrors.sol#223-234) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibNativeOrdersRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"ProtocolFeeRefundFailed(address,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            receiver,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            refundAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OrderNotFillableByOriginError(bytes32,address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            txOrigin,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderTxOrigin\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OrderNotFillableError(bytes32,uint8)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderStatus\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OrderNotSignedByMakerError(bytes32,address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signer,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maker\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OrderNotFillableBySenderError(bytes32,address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderSender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OrderNotFillableByTakerError(bytes32,address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            taker,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderTaker\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"CancelSaltTooLowError(uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minValidSalt,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            oldMinValidSalt\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"FillOrKillFailedError(bytes32,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            takerTokenFilledAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            takerTokenFillAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyOrderMakerAllowed(bytes32,address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            orderHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maker\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibNativeOrdersRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibNativeOrdersRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function ProtocolFeeRefundFailed(\n\n        address receiver,\n\n        uint256 refundAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"ProtocolFeeRefundFailed(address,uint256)\")),\n\n            receiver,\n\n            refundAmount\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.ProtocolFeeRefundFailed' (LibNativeOrdersRichErrors.sol#28-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function OrderNotFillableByOriginError(\n\n        bytes32 orderHash,\n\n        address txOrigin,\n\n        address orderTxOrigin\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OrderNotFillableByOriginError(bytes32,address,address)\")),\n\n            orderHash,\n\n            txOrigin,\n\n            orderTxOrigin\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.OrderNotFillableByOriginError' (LibNativeOrdersRichErrors.sol#43-58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function OrderNotFillableError(\n\n        bytes32 orderHash,\n\n        uint8 orderStatus\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OrderNotFillableError(bytes32,uint8)\")),\n\n            orderHash,\n\n            orderStatus\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.OrderNotFillableError' (LibNativeOrdersRichErrors.sol#60-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function OrderNotSignedByMakerError(\n\n        bytes32 orderHash,\n\n        address signer,\n\n        address maker\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OrderNotSignedByMakerError(bytes32,address,address)\")),\n\n            orderHash,\n\n            signer,\n\n            maker\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.OrderNotSignedByMakerError' (LibNativeOrdersRichErrors.sol#75-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function OrderNotFillableBySenderError(\n\n        bytes32 orderHash,\n\n        address sender,\n\n        address orderSender\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OrderNotFillableBySenderError(bytes32,address,address)\")),\n\n            orderHash,\n\n            sender,\n\n            orderSender\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.OrderNotFillableBySenderError' (LibNativeOrdersRichErrors.sol#92-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 124,
                    "vulnerability_code": "    function OrderNotFillableByTakerError(\n\n        bytes32 orderHash,\n\n        address taker,\n\n        address orderTaker\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OrderNotFillableByTakerError(bytes32,address,address)\")),\n\n            orderHash,\n\n            taker,\n\n            orderTaker\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.OrderNotFillableByTakerError' (LibNativeOrdersRichErrors.sol#109-124) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function CancelSaltTooLowError(\n\n        uint256 minValidSalt,\n\n        uint256 oldMinValidSalt\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"CancelSaltTooLowError(uint256,uint256)\")),\n\n            minValidSalt,\n\n            oldMinValidSalt\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.CancelSaltTooLowError' (LibNativeOrdersRichErrors.sol#126-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function FillOrKillFailedError(\n\n        bytes32 orderHash,\n\n        uint256 takerTokenFilledAmount,\n\n        uint256 takerTokenFillAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"FillOrKillFailedError(bytes32,uint256,uint256)\")),\n\n            orderHash,\n\n            takerTokenFilledAmount,\n\n            takerTokenFillAmount\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.FillOrKillFailedError' (LibNativeOrdersRichErrors.sol#141-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": 173,
                    "vulnerability_code": "    function OnlyOrderMakerAllowed(\n\n        bytes32 orderHash,\n\n        address sender,\n\n        address maker\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyOrderMakerAllowed(bytes32,address,address)\")),\n\n            orderHash,\n\n            sender,\n\n            maker\n\n        );\n",
                    "message": "Function 'LibNativeOrdersRichErrors.OnlyOrderMakerAllowed' (LibNativeOrdersRichErrors.sol#158-173) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibMetaTransactionsRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidMetaTransactionsArrayLengthsError(uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxCount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signatureCount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionUnsupportedFunctionError(bytes32,bytes4)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionWrongSenderError(bytes32,address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedSender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionExpiredError(bytes32,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            time,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expirationTime\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionGasPriceError(bytes32,uint256,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            gasPrice,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            minGasPrice,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            maxGasPrice\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionInsufficientEthError(bytes32,uint256,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethBalance,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethRequired\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionInvalidSignatureError(bytes32,bytes,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            signature,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionAlreadyExecutedError(bytes32,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            executedBlockNumber\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 170,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MetaTransactionCallFailedError(bytes32,bytes,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            mtxHash,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            callData,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            returnData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibMetaTransactionsRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibMetaTransactionsRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function InvalidMetaTransactionsArrayLengthsError(\n\n        uint256 mtxCount,\n\n        uint256 signatureCount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidMetaTransactionsArrayLengthsError(uint256,uint256)\")),\n\n            mtxCount,\n\n            signatureCount\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.InvalidMetaTransactionsArrayLengthsError' (LibMetaTransactionsRichErrors.sol#28-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 56,
                    "vulnerability_code": "    function MetaTransactionUnsupportedFunctionError(\n\n        bytes32 mtxHash,\n\n        bytes4 selector\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionUnsupportedFunctionError(bytes32,bytes4)\")),\n\n            mtxHash,\n\n            selector\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionUnsupportedFunctionError' (LibMetaTransactionsRichErrors.sol#43-56) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function MetaTransactionWrongSenderError(\n\n        bytes32 mtxHash,\n\n        address sender,\n\n        address expectedSender\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionWrongSenderError(bytes32,address,address)\")),\n\n            mtxHash,\n\n            sender,\n\n            expectedSender\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionWrongSenderError' (LibMetaTransactionsRichErrors.sol#58-73) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": 90,
                    "vulnerability_code": "    function MetaTransactionExpiredError(\n\n        bytes32 mtxHash,\n\n        uint256 time,\n\n        uint256 expirationTime\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionExpiredError(bytes32,uint256,uint256)\")),\n\n            mtxHash,\n\n            time,\n\n            expirationTime\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionExpiredError' (LibMetaTransactionsRichErrors.sol#75-90) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 109,
                    "vulnerability_code": "    function MetaTransactionGasPriceError(\n\n        bytes32 mtxHash,\n\n        uint256 gasPrice,\n\n        uint256 minGasPrice,\n\n        uint256 maxGasPrice\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionGasPriceError(bytes32,uint256,uint256,uint256)\")),\n\n            mtxHash,\n\n            gasPrice,\n\n            minGasPrice,\n\n            maxGasPrice\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionGasPriceError' (LibMetaTransactionsRichErrors.sol#92-109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": 126,
                    "vulnerability_code": "    function MetaTransactionInsufficientEthError(\n\n        bytes32 mtxHash,\n\n        uint256 ethBalance,\n\n        uint256 ethRequired\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionInsufficientEthError(bytes32,uint256,uint256)\")),\n\n            mtxHash,\n\n            ethBalance,\n\n            ethRequired\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionInsufficientEthError' (LibMetaTransactionsRichErrors.sol#111-126) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": 143,
                    "vulnerability_code": "    function MetaTransactionInvalidSignatureError(\n\n        bytes32 mtxHash,\n\n        bytes memory signature,\n\n        bytes memory errData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionInvalidSignatureError(bytes32,bytes,bytes)\")),\n\n            mtxHash,\n\n            signature,\n\n            errData\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionInvalidSignatureError' (LibMetaTransactionsRichErrors.sol#128-143) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": 158,
                    "vulnerability_code": "    function MetaTransactionAlreadyExecutedError(\n\n        bytes32 mtxHash,\n\n        uint256 executedBlockNumber\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionAlreadyExecutedError(bytes32,uint256)\")),\n\n            mtxHash,\n\n            executedBlockNumber\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionAlreadyExecutedError' (LibMetaTransactionsRichErrors.sol#145-158) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": 175,
                    "vulnerability_code": "    function MetaTransactionCallFailedError(\n\n        bytes32 mtxHash,\n\n        bytes memory callData,\n\n        bytes memory returnData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MetaTransactionCallFailedError(bytes32,bytes,bytes)\")),\n\n            mtxHash,\n\n            callData,\n\n            returnData\n\n        );\n",
                    "message": "Function 'LibMetaTransactionsRichErrors.MetaTransactionCallFailedError' (LibMetaTransactionsRichErrors.sol#160-175) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibCommonRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyCallableBySelfError(address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"IllegalReentrancyError(bytes4,uint256)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            reentrancyFlags\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibCommonRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibCommonRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function OnlyCallableBySelfError(address sender)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyCallableBySelfError(address)\")),\n\n            sender\n\n        );\n",
                    "message": "Function 'LibCommonRichErrors.OnlyCallableBySelfError' (LibCommonRichErrors.sol#28-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function IllegalReentrancyError(bytes4 selector, uint256 reentrancyFlags)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"IllegalReentrancyError(bytes4,uint256)\")),\n\n            selector,\n\n            reentrancyFlags\n\n        );\n",
                    "message": "Function 'LibCommonRichErrors.IllegalReentrancyError' (LibCommonRichErrors.sol#39-49) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibOwnableRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            sender,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            resultData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibOwnableRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibOwnableRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function OnlyOwnerError(\n\n        address sender,\n\n        address owner\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"OnlyOwnerError(address,address)\")),\n\n            sender,\n\n            owner\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.OnlyOwnerError' (LibOwnableRichErrors.sol#28-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 51,
                    "vulnerability_code": "    function TransferOwnerToZeroError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.TransferOwnerToZeroError' (LibOwnableRichErrors.sol#43-51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function MigrateCallFailedError(address target, bytes memory resultData)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"MigrateCallFailedError(address,bytes)\")),\n\n            target,\n\n            resultData\n\n        );\n",
                    "message": "Function 'LibOwnableRichErrors.MigrateCallFailedError' (LibOwnableRichErrors.sol#53-63) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibProxyRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"NotImplementedError(bytes4)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidBootstrapCallerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actual,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expected\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"InvalidDieCallerError(address,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actual,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expected\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"BootstrapCallFailedError(address,bytes)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            resultData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibProxyRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibProxyRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 37,
                    "vulnerability_code": "    function NotImplementedError(bytes4 selector)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"NotImplementedError(bytes4)\")),\n\n            selector\n\n        );\n",
                    "message": "Function 'LibProxyRichErrors.NotImplementedError' (LibProxyRichErrors.sol#28-37) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function InvalidBootstrapCallerError(address actual, address expected)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidBootstrapCallerError(address,address)\")),\n\n            actual,\n\n            expected\n\n        );\n",
                    "message": "Function 'LibProxyRichErrors.InvalidBootstrapCallerError' (LibProxyRichErrors.sol#39-49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 61,
                    "vulnerability_code": "    function InvalidDieCallerError(address actual, address expected)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"InvalidDieCallerError(address,address)\")),\n\n            actual,\n\n            expected\n\n        );\n",
                    "message": "Function 'LibProxyRichErrors.InvalidDieCallerError' (LibProxyRichErrors.sol#51-61) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 73,
                    "vulnerability_code": "    function BootstrapCallFailedError(address target, bytes memory resultData)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"BootstrapCallFailedError(address,bytes)\")),\n\n            target,\n\n            resultData\n\n        );\n",
                    "message": "Function 'LibProxyRichErrors.BootstrapCallFailedError' (LibProxyRichErrors.sol#63-73) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/errors/LibSimpleFunctionRegistryRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4(keccak256(\"NotInRollbackHistoryError(bytes4,address)\")),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            selector,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            targetImpl\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibSimpleFunctionRegistryRichErrors.sol:\n\t- pragma solidity^0.6.5 (LibSimpleFunctionRegistryRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": 38,
                    "vulnerability_code": "    function NotInRollbackHistoryError(bytes4 selector, address targetImpl)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            bytes4(keccak256(\"NotInRollbackHistoryError(bytes4,address)\")),\n\n            selector,\n\n            targetImpl\n\n        );\n",
                    "message": "Function 'LibSimpleFunctionRegistryRichErrors.NotInRollbackHistoryError' (LibSimpleFunctionRegistryRichErrors.sol#28-38) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/vendor/ILiquidityProvider.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in ILiquidityProvider.sol:\n\t- pragma solidity^0.6.5 (ILiquidityProvider.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sellTokenForEth(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable recipient,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 minBuyAmount,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata auxiliaryData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256 boughtAmount);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/vendor/v3/LibOrderHash.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function getStructHash(IExchange.Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_ORDER_SCHEMA_HASH;\n\n        bytes memory makerAssetData = order.makerAssetData;\n\n        bytes memory takerAssetData = order.takerAssetData;\n\n        bytes memory makerFeeAssetData = order.makerFeeAssetData;\n\n        bytes memory takerFeeAssetData = order.takerFeeAssetData;\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP712_ORDER_SCHEMA_HASH,\n\n        //     uint256(order.makerAddress),\n\n        //     uint256(order.takerAddress),\n\n        //     uint256(order.feeRecipientAddress),\n\n        //     uint256(order.senderAddress),\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData),\n\n        //     keccak256(order.makerFeeAssetData),\n\n        //     keccak256(order.takerFeeAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Assert order offset (this is an internal error that should never be triggered)\n\n            if lt(order, 32) {\n\n                invalid()\n\n            }\n\n\n\n            // Calculate memory addresses that will be swapped out before hashing\n\n            let pos1 := sub(order, 32)\n\n            let pos2 := add(order, 320)\n\n            let pos3 := add(order, 352)\n\n            let pos4 := add(order, 384)\n\n            let pos5 := add(order, 416)\n\n\n\n            // Backup\n\n            let temp1 := mload(pos1)\n\n            let temp2 := mload(pos2)\n\n            let temp3 := mload(pos3)\n\n            let temp4 := mload(pos4)\n\n            let temp5 := mload(pos5)\n\n\n\n            // Hash in place\n\n            mstore(pos1, schemaHash)\n\n            mstore(pos2, keccak256(add(makerAssetData, 32), mload(makerAssetData)))        // store hash of makerAssetData\n\n            mstore(pos3, keccak256(add(takerAssetData, 32), mload(takerAssetData)))        // store hash of takerAssetData\n\n            mstore(pos4, keccak256(add(makerFeeAssetData, 32), mload(makerFeeAssetData)))  // store hash of makerFeeAssetData\n\n            mstore(pos5, keccak256(add(takerFeeAssetData, 32), mload(takerFeeAssetData)))  // store hash of takerFeeAssetData\n\n            result := keccak256(pos1, 480)\n\n\n\n            // Restore\n\n            mstore(pos1, temp1)\n\n            mstore(pos2, temp2)\n\n            mstore(pos3, temp3)\n\n            mstore(pos4, temp4)\n\n            mstore(pos5, temp5)\n\n        }\n\n        return result;\n",
                    "message": "LibOrderHash.getStructHash (LibOrderHash.sol#183-249) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibOrderHash._hashEIP712Message (LibOrderHash.sol#256-280) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": 249,
                    "vulnerability_code": "    function getStructHash(IExchange.Order memory order)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        bytes32 schemaHash = _EIP712_ORDER_SCHEMA_HASH;\n\n        bytes memory makerAssetData = order.makerAssetData;\n\n        bytes memory takerAssetData = order.takerAssetData;\n\n        bytes memory makerFeeAssetData = order.makerFeeAssetData;\n\n        bytes memory takerFeeAssetData = order.takerFeeAssetData;\n\n\n\n        // Assembly for more efficiently computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP712_ORDER_SCHEMA_HASH,\n\n        //     uint256(order.makerAddress),\n\n        //     uint256(order.takerAddress),\n\n        //     uint256(order.feeRecipientAddress),\n\n        //     uint256(order.senderAddress),\n\n        //     order.makerAssetAmount,\n\n        //     order.takerAssetAmount,\n\n        //     order.makerFee,\n\n        //     order.takerFee,\n\n        //     order.expirationTimeSeconds,\n\n        //     order.salt,\n\n        //     keccak256(order.makerAssetData),\n\n        //     keccak256(order.takerAssetData),\n\n        //     keccak256(order.makerFeeAssetData),\n\n        //     keccak256(order.takerFeeAssetData)\n\n        // ));\n\n\n\n        assembly {\n\n            // Assert order offset (this is an internal error that should never be triggered)\n\n            if lt(order, 32) {\n\n                invalid()\n\n            }\n\n\n\n            // Calculate memory addresses that will be swapped out before hashing\n\n            let pos1 := sub(order, 32)\n\n            let pos2 := add(order, 320)\n\n            let pos3 := add(order, 352)\n\n            let pos4 := add(order, 384)\n\n            let pos5 := add(order, 416)\n\n\n\n            // Backup\n\n            let temp1 := mload(pos1)\n\n            let temp2 := mload(pos2)\n\n            let temp3 := mload(pos3)\n\n            let temp4 := mload(pos4)\n\n            let temp5 := mload(pos5)\n\n\n\n            // Hash in place\n\n            mstore(pos1, schemaHash)\n\n            mstore(pos2, keccak256(add(makerAssetData, 32), mload(makerAssetData)))        // store hash of makerAssetData\n\n            mstore(pos3, keccak256(add(takerAssetData, 32), mload(takerAssetData)))        // store hash of takerAssetData\n\n            mstore(pos4, keccak256(add(makerFeeAssetData, 32), mload(makerFeeAssetData)))  // store hash of makerFeeAssetData\n\n            mstore(pos5, keccak256(add(takerFeeAssetData, 32), mload(takerFeeAssetData)))  // store hash of takerFeeAssetData\n\n            result := keccak256(pos1, 480)\n\n\n\n            // Restore\n\n            mstore(pos1, temp1)\n\n            mstore(pos2, temp2)\n\n            mstore(pos3, temp3)\n\n            mstore(pos4, temp4)\n\n            mstore(pos5, temp5)\n\n        }\n\n        return result;\n",
                    "message": "LibOrderHash.getStructHash uses assembly (LibOrderHash.sol#183-249)\n\t- LibOrderHash.sol#213-247\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "LibOrderHash._hashEIP712Message uses assembly (LibOrderHash.sol#256-280)\n\t- LibOrderHash.sol#268-278\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in LibOrderHash.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- LibOrderHash.sol#21 declares pragma solidity^0.6.5\n\t- LibOrderHash.sol#22 declares pragma experimentalABIEncoderV2\n\t- LibOrderHash.sol#136 declares pragma solidity^0.6.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in LibOrderHash.sol:\n\t- pragma solidity^0.6.5 (LibOrderHash.sol#21): it allows old versions\n\t- pragma solidity^0.6.5 (LibOrderHash.sol#136): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function EIP712_EXCHANGE_DOMAIN_HASH()\n\n        external\n\n        view\n",
                    "message": "Function 'IExchange.EIP712_EXCHANGE_DOMAIN_HASH' (LibOrderHash.sol#110-113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n\n        internal\n\n        pure\n\n        returns (bytes32 result)\n\n    {\n\n        // Assembly for more efficient computing:\n\n        // keccak256(abi.encodePacked(\n\n        //     EIP191_HEADER,\n\n        //     EIP712_DOMAIN_HASH,\n\n        //     hashStruct\n\n        // ));\n\n\n\n        assembly {\n\n            // Load free memory pointer\n\n            let memPtr := mload(64)\n\n\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\n\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n\n\n\n            // Compute hash\n\n            result := keccak256(memPtr, 66)\n\n        }\n\n        return result;\n",
                    "message": "Function 'LibOrderHash._hashEIP712Message' (LibOrderHash.sol#256-280) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getStructHash(IExchange.Order memory order)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/vendor/v3/IGasToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IGasToken.sol:\n\t- pragma solidity^0.6.5 (IGasToken.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/vendor/v3/IStaking.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IStaking.sol:\n\t- pragma solidity^0.6.5 (IStaking.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function joinStakingPoolAsMaker(bytes32) external;\n",
                    "message": "Parameter '' of IStaking.joinStakingPoolAsMaker (IStaking.sol#24) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function payProtocolFee(address, address, uint256) external payable;\n",
                    "message": "Parameter '' of IStaking.payProtocolFee (IStaking.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function payProtocolFee(address, address, uint256) external payable;\n",
                    "message": "Parameter '_scope_0' of IStaking.payProtocolFee (IStaking.sol#25) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function payProtocolFee(address, address, uint256) external payable;\n",
                    "message": "Parameter '_scope_1' of IStaking.payProtocolFee (IStaking.sol#25) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/vendor/v3/IERC20Bridge.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IERC20Bridge.sol:\n\t- pragma solidity^0.6.5 (IERC20Bridge.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/zero-ex/contracts/src/vendor/v3/IExchange.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Different versions of Solidity is used in IExchange.sol:\n\t- Version used: ['ABIEncoderV2', '^0.6.5']\n\t- IExchange.sol#21 declares pragma solidity^0.6.5\n\t- IExchange.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": "Detected issues with version pragma in IExchange.sol:\n\t- pragma solidity^0.6.5 (IExchange.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": 113,
                    "vulnerability_code": "    function EIP712_EXCHANGE_DOMAIN_HASH()\n\n        external\n\n        view\n",
                    "message": "Function 'IExchange.EIP712_EXCHANGE_DOMAIN_HASH' (IExchange.sol#110-113) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/extensions/contracts/src/MaximumGasPrice.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tx.gasprice <= DEFAULT_MAX_GAS_PRICE,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"MaximumGasPrice/GAS_PRICE_EXCEEDS_20_GWEI\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tx.gasprice <= maxGasPrice,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"MaximumGasPrice/GAS_PRICE_EXCEEDS_MAXIMUM\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tx.gasprice <= DEFAULT_MAX_GAS_PRICE,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"MaximumGasPrice/GAS_PRICE_EXCEEDS_20_GWEI\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            tx.gasprice <= maxGasPrice,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"MaximumGasPrice/GAS_PRICE_EXCEEDS_MAXIMUM\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in MaximumGasPrice.sol:\n\t- pragma solidity^0.5.16 (MaximumGasPrice.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant private DEFAULT_MAX_GAS_PRICE = 20 * (10 ** 9);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/extensions/contracts/src/rich-errors/LibWethUtilsRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UNREGISTERED_ASSET_PROXY_ERROR_SELECTOR);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_ETH_FOR_FEE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethFeeRequired,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethAvailable\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            DEFAULT_FUNCTION_WETH_CONTRACT_ONLY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ETH_FEE_LENGTH_MISMATCH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ethFeesLength,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 90,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            feeRecipientsLength\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibWethUtilsRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibWethUtilsRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 49,
                    "vulnerability_code": "    function UnregisteredAssetProxyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(UNREGISTERED_ASSET_PROXY_ERROR_SELECTOR);\n",
                    "message": "Function 'LibWethUtilsRichErrors.UnregisteredAssetProxyError' (LibWethUtilsRichErrors.sol#43-49) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function InsufficientEthForFeeError(\n\n        uint256 ethFeeRequired,\n\n        uint256 ethAvailable\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INSUFFICIENT_ETH_FOR_FEE_ERROR_SELECTOR,\n\n            ethFeeRequired,\n\n            ethAvailable\n\n        );\n",
                    "message": "Function 'LibWethUtilsRichErrors.InsufficientEthForFeeError' (LibWethUtilsRichErrors.sol#51-64) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 77,
                    "vulnerability_code": "    function DefaultFunctionWethContractOnlyError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            DEFAULT_FUNCTION_WETH_CONTRACT_ONLY_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibWethUtilsRichErrors.DefaultFunctionWethContractOnlyError' (LibWethUtilsRichErrors.sol#66-77) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": 92,
                    "vulnerability_code": "    function EthFeeLengthMismatchError(\n\n        uint256 ethFeesLength,\n\n        uint256 feeRecipientsLength\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ETH_FEE_LENGTH_MISMATCH_ERROR_SELECTOR,\n\n            ethFeesLength,\n\n            feeRecipientsLength\n\n        );\n",
                    "message": "Function 'LibWethUtilsRichErrors.EthFeeLengthMismatchError' (LibWethUtilsRichErrors.sol#79-92) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf3b96b8d;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xecf40fd9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x08b18698;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x3ecb6ceb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/extensions/contracts/src/rich-errors/LibAssetDataTransferRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSUPPORTED_ASSET_PROXY_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            proxyId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ERC721_AMOUNT_MUST_EQUAL_ONE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibAssetDataTransferRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibAssetDataTransferRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 46,
                    "vulnerability_code": "    function UnsupportedAssetProxyError(\n\n        bytes4 proxyId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSUPPORTED_ASSET_PROXY_ERROR_SELECTOR,\n\n            proxyId\n\n        );\n",
                    "message": "Function 'LibAssetDataTransferRichErrors.UnsupportedAssetProxyError' (LibAssetDataTransferRichErrors.sol#35-46) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": 59,
                    "vulnerability_code": "    function Erc721AmountMustEqualOneError(\n\n        uint256 amount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ERC721_AMOUNT_MUST_EQUAL_ONE_ERROR_SELECTOR,\n\n            amount\n\n        );\n",
                    "message": "Function 'LibAssetDataTransferRichErrors.Erc721AmountMustEqualOneError' (LibAssetDataTransferRichErrors.sol#48-59) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x7996a271;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbaffa474;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/integrations/contracts/test/TestFramework.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestFramework.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestFramework.sol#38-42)\n\t- TestFramework.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestFramework.sol:\n\t- pragma solidity^0.5.9 (TestFramework.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestFramework.sol#47): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestFramework.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant RICH_REVERT_ERROR_SELECTOR = 0x49a7e246;\n",
                    "message": "TestFramework.RICH_REVERT_ERROR_SELECTOR (TestFramework.sol#56) is never used in TestFramework\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 56,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant RICH_REVERT_ERROR_SELECTOR = 0x49a7e246;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/integrations/contracts/test/TestDydxUser.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            daiBalance > 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TestDydxUser/DAI_BALANCE_MUST_BE_NONZERO\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(DAI_ADDRESS).approve(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                DYDX_ADDRESS,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                daiBalance\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TestDydxUser/FAILED_TO_SET_DAI_ALLOWANCE\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            daiBalance > 0,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TestDydxUser/DAI_BALANCE_MUST_BE_NONZERO\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 154,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            IERC20Token(DAI_ADDRESS).approve(\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                DYDX_ADDRESS,\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                daiBalance\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TestDydxUser/FAILED_TO_SET_DAI_ALLOWANCE\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 159,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in TestDydxUser.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- TestDydxUser.sol#21 declares pragma solidity^0.5.9\n\t- TestDydxUser.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function init()\n\n        public\n\n        returns (bytes4)\n\n    {\n\n        // 1. Assert that this account has DAI.\n\n        uint256 daiBalance = IERC20Token(DAI_ADDRESS).balanceOf(address(this));\n\n        require(\n\n            daiBalance > 0,\n\n            \"TestDydxUser/DAI_BALANCE_MUST_BE_NONZERO\"\n\n        );\n\n\n\n        // 2. Set allowance for Dydx to transfer DAI.\n\n        require(\n\n            IERC20Token(DAI_ADDRESS).approve(\n\n                DYDX_ADDRESS,\n\n                daiBalance\n\n            ),\n\n            \"TestDydxUser/FAILED_TO_SET_DAI_ALLOWANCE\"\n\n        );\n\n\n\n        // 3. Add DydxBridge as operator on dydx.\n\n        //    This will revert on failure.\n\n        IDydx.OperatorArg[] memory operatorArgs = new IDydx.OperatorArg[](1);\n\n        operatorArgs[0] = IDydx.OperatorArg({\n\n            operator: DYDX_BRIDGE_ADDRESS,\n\n            trusted: true\n\n        });\n\n        IDydx(DYDX_ADDRESS).setOperators(operatorArgs);\n\n\n\n        // 4. Deposit 1/2 DAI balance into dydx. This allows us to test withdrawals.\n\n        // 4.i Create dydx account struct.\n\n        IDydx.AccountInfo[] memory accounts = new IDydx.AccountInfo[](1);\n\n        accounts[0] = IDydx.AccountInfo({\n\n            owner: address(this),\n\n            number: 0\n\n        });\n\n\n\n         // 4.ii Create dydx amount.\n\n        IDydx.AssetAmount memory dydxAmount = IDydx.AssetAmount({\n\n            sign: true,                                 // true if positive.\n\n            denomination: IDydx.AssetDenomination.Wei,  // Wei => actual token amount held in account.\n\n            ref: IDydx.AssetReference.Delta,            // Delta => a relative amount.\n\n            value: daiBalance / 2                       // amount to deposit.\n\n        });\n\n\n\n        // 4.iii Create dydx deposit action.\n\n        IDydx.ActionArgs[] memory actions = new IDydx.ActionArgs[](1);\n\n        actions[0] = IDydx.ActionArgs({\n\n            actionType: IDydx.ActionType.Deposit,           // deposit tokens.\n\n            amount: dydxAmount,                             // amount to deposit.\n\n            accountId: 0,                                   // index in the `accounts` when calling `operate`.\n\n            primaryMarketId: DYDX_DAI_MARKET_ID,            // indicates which token to deposit.\n\n            otherAddress: address(this),                    // deposit from the account owner.\n\n            // unused parameters\n\n            secondaryMarketId: 0,\n\n            otherAccountId: 0,\n\n            data: hex''\n\n        });\n\n\n\n        // 4.iv Deposit DAI into dydx. This will revert on failure.\n\n        IDydx(DYDX_ADDRESS).operate(\n\n            accounts,\n\n            actions\n\n        );\n\n\n\n        // Return magic bytes on success.\n\n        return MAGIC_BYTES;\n",
                    "message": "TestDydxUser.init (TestDydxUser.sol#141-208) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestDydxUser.sol:\n\t- pragma solidity^0.5.9 (TestDydxUser.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public constant DYDX_BRIDGE_ADDRESS = 0x55dC8f21D20D4c6ED3C82916A438A413ca68e335;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public constant DYDX_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/integrations/contracts/test/TestContractWrapper.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        revert(\"ERROR\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function throwInvalidOpcode() external returns (uint256) {\n\n        assembly {\n\n            invalid()\n\n        }\n",
                    "message": "TestContractWrapper.throwInvalidOpcode uses assembly (TestContractWrapper.sol#37-41)\n\t- TestContractWrapper.sol#38-40\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function returnForcedEmpty() external returns (uint256) {\n\n        assembly {\n\n            return(0x60, 0)\n\n        }\n",
                    "message": "TestContractWrapper.returnForcedEmpty uses assembly (TestContractWrapper.sol#43-47)\n\t- TestContractWrapper.sol#44-46\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": 55,
                    "vulnerability_code": "    function returnTruncated() external returns (uint256) {\n\n        uint256 v = VALID_RETURN_VALUE;\n\n        assembly {\n\n            mstore(0x0, v)\n\n            return(0x0, 16)\n\n        }\n",
                    "message": "TestContractWrapper.returnTruncated uses assembly (TestContractWrapper.sol#49-55)\n\t- TestContractWrapper.sol#51-54\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestContractWrapper.sol:\n\t- pragma solidity^0.5.9 (TestContractWrapper.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function throwStringRevert() external returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function throwEmptyRevert() external returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function throwInvalidOpcode() external returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function returnForcedEmpty() external returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function returnTruncated() external returns (uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/integrations/contracts/src/interfaces/IChainlinkAggregator.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IChainlinkAggregator.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IChainlinkAggregator.sol#21 declares pragma solidity^0.5.9\n\t- IChainlinkAggregator.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IChainlinkAggregator.sol:\n\t- pragma solidity^0.5.9 (IChainlinkAggregator.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/test/TestLibFixedMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (a == MIN_FIXED_VAL && b == -1) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_12"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestLibFixedMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath.ln (TestLibFixedMath.sol#322) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath.exp (TestLibFixedMath.sol#412) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestLibFixedMath.sol#38-42)\n\t- TestLibFixedMath.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestLibFixedMath.sol:\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#162): it allows old versions\n\t- pragma solidity^0.5.9 (TestLibFixedMath.sol#552): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestLibFixedMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (TestLibFixedMath.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (TestLibFixedMath.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (TestLibFixedMath.sol#124-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function _mul(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (a == 0 || b == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        if (c / a != b || c / b != a) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath._mul' (TestLibFixedMath.sol#487-499) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function _div(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        if (a == MIN_FIXED_VAL && b == -1) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        c = a / b;\n",
                    "message": "Function 'LibFixedMath._div' (TestLibFixedMath.sol#502-518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 530,
                    "vulnerability_code": "    function _add(int256 a, int256 b) private pure returns (int256 c) {\n\n        c = a + b;\n\n        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath._add' (TestLibFixedMath.sol#521-530) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant MIN_FIXED_VAL = int256(0x8000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1_SQUARED = int256(0x4000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MAX_VAL = FIXED_1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MAX_VAL = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/test/TestLibSafeDowncast.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/immutable/MixinConstants.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinConstants.sol:\n\t- pragma solidity^0.5.9 (MixinConstants.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/libs/LibSafeDowncast.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibSafeDowncast.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibSafeDowncast.sol#38-42)\n\t- LibSafeDowncast.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibSafeDowncast.sol:\n\t- pragma solidity^0.5.9 (LibSafeDowncast.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeDowncast.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (LibSafeDowncast.sol#98): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibSafeDowncast.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (LibSafeDowncast.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (LibSafeDowncast.sol#73-75) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/libs/LibFixedMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (a == MIN_FIXED_VAL && b == -1) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_12"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibFixedMath.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath.exp (LibFixedMath.sol#412) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath.ln (LibFixedMath.sol#322) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibFixedMath.sol#38-42)\n\t- LibFixedMath.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibFixedMath.sol:\n\t- pragma solidity^0.5.9 (LibFixedMath.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibFixedMath.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibFixedMath.sol#162): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibFixedMath.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (LibFixedMath.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (LibFixedMath.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (LibFixedMath.sol#124-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function _mul(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (a == 0 || b == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        if (c / a != b || c / b != a) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath._mul' (LibFixedMath.sol#487-499) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function _div(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        if (a == MIN_FIXED_VAL && b == -1) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        c = a / b;\n",
                    "message": "Function 'LibFixedMath._div' (LibFixedMath.sol#502-518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 530,
                    "vulnerability_code": "    function _add(int256 a, int256 b) private pure returns (int256 c) {\n\n        c = a + b;\n\n        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath._add' (LibFixedMath.sol#521-530) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant MIN_FIXED_VAL = int256(0x8000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1_SQUARED = int256(0x4000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MAX_VAL = FIXED_1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MAX_VAL = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/libs/LibStakingRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            EXCHANGE_MANAGER_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCodes,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            exchangeAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            amount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            balance\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 309,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 320,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epochEndTime,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 323,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentBlockTimestamp\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 334,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 336,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            senderAddress\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 366,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OPERATOR_SHARE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 367,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            errorCodes,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 369,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            operatorShare\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 370,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_EXISTENCE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            alreadyExists\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_PROTOCOL_FEE_PAYMENT_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedProtocolFeePaid,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actualProtocolFeePaid\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INITIALIZATION_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(code)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            INVALID_PARAM_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(code)\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 442,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            PREVIOUS_EPOCH_NOT_FINALIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            unfinalizedEpoch,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 444,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            unfinalizedPoolsRemaining\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            POOL_NOT_FINALIZED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            poolId,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epoch\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_20"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibStakingRichErrors.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibStakingRichErrors.sol#38-42)\n\t- LibStakingRichErrors.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibStakingRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibStakingRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibStakingRichErrors.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibStakingRichErrors.sol#161): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibStakingRichErrors.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 254,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function OnlyCallableByExchangeError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_EXCHANGE_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByExchangeError' (LibStakingRichErrors.sol#254-265) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function ExchangeManagerError(\n\n        ExchangeManagerErrorCodes errorCodes,\n\n        address exchangeAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            EXCHANGE_MANAGER_ERROR_SELECTOR,\n\n            errorCodes,\n\n            exchangeAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.ExchangeManagerError' (LibStakingRichErrors.sol#267-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": 295,
                    "vulnerability_code": "    function InsufficientBalanceError(\n\n        uint256 amount,\n\n        uint256 balance\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n\n            amount,\n\n            balance\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InsufficientBalanceError' (LibStakingRichErrors.sol#282-295) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": 310,
                    "vulnerability_code": "    function OnlyCallableByPoolOperatorError(\n\n        address senderAddress,\n\n        bytes32 poolId\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n\n            senderAddress,\n\n            poolId\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByPoolOperatorError' (LibStakingRichErrors.sol#297-310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function BlockTimestampTooLowError(\n\n        uint256 epochEndTime,\n\n        uint256 currentBlockTimestamp\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n\n            epochEndTime,\n\n            currentBlockTimestamp\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.BlockTimestampTooLowError' (LibStakingRichErrors.sol#312-325) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": 338,
                    "vulnerability_code": "    function OnlyCallableByStakingContractError(\n\n        address senderAddress\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n\n            senderAddress\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableByStakingContractError' (LibStakingRichErrors.sol#327-338) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 340,
                    "vulnerability_to_line": 346,
                    "vulnerability_code": "    function OnlyCallableIfInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfInCatastrophicFailureError' (LibStakingRichErrors.sol#340-346) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": 354,
                    "vulnerability_code": "    function OnlyCallableIfNotInCatastrophicFailureError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return ONLY_CALLABLE_IF_NOT_IN_CATASTROPHIC_FAILURE_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.OnlyCallableIfNotInCatastrophicFailureError' (LibStakingRichErrors.sol#348-354) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": 371,
                    "vulnerability_code": "    function OperatorShareError(\n\n        OperatorShareErrorCodes errorCodes,\n\n        bytes32 poolId,\n\n        uint32 operatorShare\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            OPERATOR_SHARE_ERROR_SELECTOR,\n\n            errorCodes,\n\n            poolId,\n\n            operatorShare\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.OperatorShareError' (LibStakingRichErrors.sol#356-371) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 373,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function PoolExistenceError(\n\n        bytes32 poolId,\n\n        bool alreadyExists\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            POOL_EXISTENCE_ERROR_SELECTOR,\n\n            poolId,\n\n            alreadyExists\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.PoolExistenceError' (LibStakingRichErrors.sol#373-386) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": 401,
                    "vulnerability_code": "    function InvalidProtocolFeePaymentError(\n\n        uint256 expectedProtocolFeePaid,\n\n        uint256 actualProtocolFeePaid\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_PROTOCOL_FEE_PAYMENT_ERROR_SELECTOR,\n\n            expectedProtocolFeePaid,\n\n            actualProtocolFeePaid\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidProtocolFeePaymentError' (LibStakingRichErrors.sol#388-401) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 403,
                    "vulnerability_to_line": 412,
                    "vulnerability_code": "    function InitializationError(InitializationErrorCodes code)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INITIALIZATION_ERROR_SELECTOR,\n\n            uint8(code)\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InitializationError' (LibStakingRichErrors.sol#403-412) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": 423,
                    "vulnerability_code": "    function InvalidParamValueError(InvalidParamValueErrorCodes code)\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            INVALID_PARAM_VALUE_ERROR_SELECTOR,\n\n            uint8(code)\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.InvalidParamValueError' (LibStakingRichErrors.sol#414-423) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": 431,
                    "vulnerability_code": "    function ProxyDestinationCannotBeNilError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return PROXY_DESTINATION_CANNOT_BE_NIL_ERROR;\n",
                    "message": "Function 'LibStakingRichErrors.ProxyDestinationCannotBeNilError' (LibStakingRichErrors.sol#425-431) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": 446,
                    "vulnerability_code": "    function PreviousEpochNotFinalizedError(\n\n        uint256 unfinalizedEpoch,\n\n        uint256 unfinalizedPoolsRemaining\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            PREVIOUS_EPOCH_NOT_FINALIZED_ERROR_SELECTOR,\n\n            unfinalizedEpoch,\n\n            unfinalizedPoolsRemaining\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.PreviousEpochNotFinalizedError' (LibStakingRichErrors.sol#433-446) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": 461,
                    "vulnerability_code": "    function PoolNotFinalizedError(\n\n        bytes32 poolId,\n\n        uint256 epoch\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            POOL_NOT_FINALIZED_ERROR_SELECTOR,\n\n            poolId,\n\n            epoch\n\n        );\n",
                    "message": "Function 'LibStakingRichErrors.PoolNotFinalizedError' (LibStakingRichErrors.sol#448-461) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 191,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb56d2df0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xb9588e43;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x84c8b7c9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x82ded785;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xa6bcde47;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xca1d07a2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x22df9597;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x9ae94f01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x0b02d773;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xfc45bd11;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x31d7a505;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x614b800a;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x5caa0b05;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/libs/LibCobbDouglas.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 510,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (a == MIN_FIXED_VAL && b == -1) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 511,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 516,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                a,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                b\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_13"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibCobbDouglas.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath.ln (LibCobbDouglas.sol#322) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        int256 y;\n",
                    "message": "y in LibFixedMath.exp (LibCobbDouglas.sol#412) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibCobbDouglas.sol#38-42)\n\t- LibCobbDouglas.sol#39-41\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in LibCobbDouglas.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- LibCobbDouglas.sol#21 declares pragma solidity^0.5.9\n\t- LibCobbDouglas.sol#65 declares pragma solidity^0.5.9\n\t- LibCobbDouglas.sol#162 declares pragma solidity^0.5.9\n\t- LibCobbDouglas.sol#553 declares pragma solidity^0.5.9\n\t- LibCobbDouglas.sol#554 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibCobbDouglas.sol:\n\t- pragma solidity^0.5.9 (LibCobbDouglas.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibCobbDouglas.sol#65): it allows old versions\n\t- pragma solidity^0.5.9 (LibCobbDouglas.sol#162): it allows old versions\n\t- pragma solidity^0.5.9 (LibCobbDouglas.sol#553): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibCobbDouglas.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (LibCobbDouglas.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (LibCobbDouglas.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (LibCobbDouglas.sol#124-139) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": 499,
                    "vulnerability_code": "    function _mul(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (a == 0 || b == 0) {\n\n            return 0;\n\n        }\n\n        c = a * b;\n\n        if (c / a != b || c / b != a) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath._mul' (LibCobbDouglas.sol#487-499) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 502,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function _div(int256 a, int256 b) private pure returns (int256 c) {\n\n        if (b == 0) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        if (a == MIN_FIXED_VAL && b == -1) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.DIVISION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n\n        c = a / b;\n",
                    "message": "Function 'LibFixedMath._div' (LibCobbDouglas.sol#502-518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 530,
                    "vulnerability_code": "    function _add(int256 a, int256 b) private pure returns (int256 c) {\n\n        c = a + b;\n\n        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\n\n            LibRichErrors.rrevert(LibFixedMathRichErrors.BinOpError(\n\n                LibFixedMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n\n                a,\n\n                b\n\n            ));\n\n        }\n",
                    "message": "Function 'LibFixedMath._add' (LibCobbDouglas.sol#521-530) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 379,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 385,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 426,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        z = z * y / FIXED_1; r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1 = int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant MIN_FIXED_VAL = int256(0x8000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant FIXED_1_SQUARED = int256(0x4000000000000000000000000000000000000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 175,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MAX_VAL = FIXED_1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant LN_MIN_VAL = int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MAX_VAL = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 181,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    int256 private constant EXP_MIN_VAL = -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/libs/LibFixedMathRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            SIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSIGNED_VALUE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            n\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 134,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            BIN_OP_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint8(error),\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            a,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (LibFixedMathRichErrors.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (LibFixedMathRichErrors.sol#38-42)\n\t- LibFixedMathRichErrors.sol#39-41\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibFixedMathRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibFixedMathRichErrors.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (LibFixedMathRichErrors.sol#65): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (LibFixedMathRichErrors.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": 107,
                    "vulnerability_code": "    function SignedValueError(\n\n        ValueErrorCodes error,\n\n        int256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            SIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.SignedValueError' (LibFixedMathRichErrors.sol#94-107) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": 122,
                    "vulnerability_code": "    function UnsignedValueError(\n\n        ValueErrorCodes error,\n\n        uint256 n\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSIGNED_VALUE_ERROR_SELECTOR,\n\n            uint8(error),\n\n            n\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.UnsignedValueError' (LibFixedMathRichErrors.sol#109-122) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 139,
                    "vulnerability_code": "    function BinOpError(\n\n        BinOpErrorCodes error,\n\n        int256 a,\n\n        int256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            BIN_OP_ERROR_SELECTOR,\n\n            uint8(error),\n\n            a,\n\n            b\n\n        );\n",
                    "message": "Function 'LibFixedMathRichErrors.BinOpError' (LibFixedMathRichErrors.sol#124-139) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xed2f26a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xbd79545f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x8c12dfe7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/sys/MixinAbstract.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in MixinAbstract.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- MixinAbstract.sol#21 declares pragma solidity^0.5.9\n\t- MixinAbstract.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinAbstract.sol:\n\t- pragma solidity^0.5.9 (MixinAbstract.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": 41,
                    "vulnerability_code": "    function _getUnfinalizedPoolRewards(bytes32 poolId)\n\n        internal\n\n        view\n\n        returns (\n\n            uint256 totalReward,\n\n            uint256 membersStake\n",
                    "message": "Function 'MixinAbstract._getUnfinalizedPoolRewards' (MixinAbstract.sol#35-41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function _assertPoolFinalizedLastEpoch(bytes32 poolId)\n\n        internal\n",
                    "message": "Function 'MixinAbstract._assertPoolFinalizedLastEpoch' (MixinAbstract.sol#45-47) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/interfaces/IStakingEvents.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingEvents.sol:\n\t- pragma solidity^0.5.9 (IStakingEvents.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/interfaces/IStorageInit.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStorageInit.sol:\n\t- pragma solidity^0.5.9 (IStorageInit.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/interfaces/IStructs.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStructs.sol:\n\t- pragma solidity^0.5.9 (IStructs.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/interfaces/IStakingProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IStakingProxy.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IStakingProxy.sol#21 declares pragma solidity^0.5.9\n\t- IStakingProxy.sol#117 declares pragma solidity^0.5.9\n\t- IStakingProxy.sol#118 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStakingProxy.sol:\n\t- pragma solidity^0.5.9 (IStakingProxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IStakingProxy.sol#117): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/interfaces/IStorage.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IStorage.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IStorage.sol#21 declares pragma solidity^0.5.9\n\t- IStorage.sol#128 declares pragma solidity^0.5.9\n\t- IStorage.sol#224 declares pragma solidity^0.5.9\n\t- IStorage.sol#225 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IStorage.sol:\n\t- pragma solidity^0.5.9 (IStorage.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IStorage.sol#128): it allows old versions\n\t- pragma solidity^0.5.9 (IStorage.sol#224): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/staking/contracts/src/interfaces/IZrxVault.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IZrxVault.sol:\n\t- pragma solidity^0.5.9 (IZrxVault.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/dev-utils/contracts/src/EthBalanceChecker.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function getEthBalances(address[] memory addresses)\n\n        public\n\n        view\n\n        returns (uint256[] memory)\n\n    {\n\n        uint256[] memory balances = new uint256[](addresses.length);\n\n        for (uint256 i = 0; i != addresses.length; i++) {\n\n            balances[i] = addresses[i].balance;\n\n        }\n\n        return balances;\n",
                    "message": "EthBalanceChecker.getEthBalances (EthBalanceChecker.sol#29-39) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": "Detected issues with version pragma in EthBalanceChecker.sol:\n\t- pragma solidity^0.5.16 (EthBalanceChecker.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != addresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.16;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/archive/Ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (Ownable.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (Ownable.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in Ownable.sol:\n\t- pragma solidity^0.5.9 (Ownable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (Ownable.sol#36): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/archive/MixinAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            currentAssetProxy == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ASSET_PROXY_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 256,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetProxy != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ASSET_PROXY_DOES_NOT_EXIST\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (amount > 0 && from != to) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 239,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Ensure assetData length is valid\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assetData.length > 3,\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 244,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            bytes4 assetProxyId;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": 211,
                    "vulnerability_code": "    function registerAssetProxy(address assetProxy)\n\n        external\n\n        onlyOwner\n\n    {\n\n        // Ensure that no asset proxy exists with current id.\n\n        bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\n\n        address currentAssetProxy = assetProxies[assetProxyId];\n\n        require(\n\n            currentAssetProxy == address(0),\n\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n\n        );\n\n\n\n        // Add asset proxy and log registration.\n\n        assetProxies[assetProxyId] = assetProxy;\n\n        emit AssetProxyRegistered(\n\n            assetProxyId,\n\n            assetProxy\n\n        );\n",
                    "message": "Reentrancy in MixinAssetProxyDispatcher.registerAssetProxy (MixinAssetProxyDispatcher.sol#193-211):\n\tExternal calls:\n\t- assetProxyId = IAssetProxy(assetProxy).getProxyId() (MixinAssetProxyDispatcher.sol#198)\n\tState variables written after the call(s):\n\t- assetProxies (MixinAssetProxyDispatcher.sol#206)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 328,
                    "vulnerability_code": "    function _dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0 && from != to) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n\n\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n\n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            //\n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n\n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input\n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
                    "message": "MixinAssetProxyDispatcher._dispatchTransferFrom uses assembly (MixinAssetProxyDispatcher.sol#229-328)\n\t- MixinAssetProxyDispatcher.sol#247-252\n\t- MixinAssetProxyDispatcher.sol#276-326\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (MixinAssetProxyDispatcher.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinAssetProxyDispatcher.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#133): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAssetProxyDispatcher.sol#179): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": 328,
                    "vulnerability_code": "    function _dispatchTransferFrom(\n\n        bytes memory assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        internal\n\n    {\n\n        // Do nothing if no amount should be transferred.\n\n        if (amount > 0 && from != to) {\n\n            // Ensure assetData length is valid\n\n            require(\n\n                assetData.length > 3,\n\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n\n            );\n\n\n\n            // Lookup assetProxy. We do not use `LibBytes.readBytes4` for gas efficiency reasons.\n\n            bytes4 assetProxyId;\n\n            assembly {\n\n                assetProxyId := and(mload(\n\n                    add(assetData, 32)),\n\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n\n                )\n\n            }\n\n            address assetProxy = assetProxies[assetProxyId];\n\n\n\n            // Ensure that assetProxy exists\n\n            require(\n\n                assetProxy != address(0),\n\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n\n            );\n\n\n\n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n\n            // The layout of this calldata is in the table below.\n\n            //\n\n            // | Area     | Offset | Length  | Contents                                    |\n\n            // | -------- |--------|---------|-------------------------------------------- |\n\n            // | Header   | 0      | 4       | function selector                           |\n\n            // | Params   |        | 4 * 32  | function parameters:                        |\n\n            // |          | 4      |         |   1. offset to assetData (*)                |\n\n            // |          | 36     |         |   2. from                                   |\n\n            // |          | 68     |         |   3. to                                     |\n\n            // |          | 100    |         |   4. amount                                 |\n\n            // | Data     |        |         | assetData:                                  |\n\n            // |          | 132    | 32      | assetData Length                            |\n\n            // |          | 164    | **      | assetData Contents                          |\n\n\n\n            assembly {\n\n                /////// Setup State ///////\n\n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n\n                let cdStart := mload(64)\n\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n\n                //  and includes 32-bytes for length.\n\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFromSelector`.\n\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n\n                // Notes:\n\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n\n                mstore(add(cdStart, 4), 128)\n\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(cdStart, 100), amount)\n\n\n\n                /////// Setup Data Area ///////\n\n                // This area holds `assetData`.\n\n                let dataArea := add(cdStart, 132)\n\n                // solhint-disable-next-line no-empty-blocks\n\n                for {} lt(dataArea, cdEnd) {} {\n\n                    mstore(dataArea, mload(assetData))\n\n                    dataArea := add(dataArea, 32)\n\n                    assetData := add(assetData, 32)\n\n                }\n\n\n\n                /////// Call `assetProxy.transferFrom` using the constructed calldata ///////\n\n                let success := call(\n\n                    gas,                    // forward all gas\n\n                    assetProxy,             // call address of asset proxy\n\n                    0,                      // don't send any ETH\n\n                    cdStart,                // pointer to start of input\n\n                    sub(cdEnd, cdStart),    // length of input\n\n                    cdStart,                // write output over input\n\n                    512                     // reserve 512 bytes for output\n\n                )\n\n                if iszero(success) {\n\n                    revert(cdStart, returndatasize())\n\n                }\n\n            }\n\n        }\n",
                    "message": "Function 'MixinAssetProxyDispatcher._dispatchTransferFrom' (MixinAssetProxyDispatcher.sol#229-328) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/archive/MixinAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (MixinAuthorizable.sol#57-64) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (MixinAuthorizable.sol#31) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinAuthorizable.sol:\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (MixinAuthorizable.sol#151): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/test/TestStaticCallTarget.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            target % 2 == 0,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_EVEN\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _state++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_28"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (TestStaticCallTarget.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (TestStaticCallTarget.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (TestStaticCallTarget.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (TestStaticCallTarget.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (TestStaticCallTarget.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (TestStaticCallTarget.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (TestStaticCallTarget.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (TestStaticCallTarget.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (TestStaticCallTarget.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (TestStaticCallTarget.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (TestStaticCallTarget.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (TestStaticCallTarget.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (TestStaticCallTarget.sol#84-88)\n\t- TestStaticCallTarget.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (TestStaticCallTarget.sol#122-127)\n\t- TestStaticCallTarget.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (TestStaticCallTarget.sol#132-137)\n\t- TestStaticCallTarget.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (TestStaticCallTarget.sol#143-243)\n\t- TestStaticCallTarget.sol#148-153\n\t- TestStaticCallTarget.sol#176-206\n\t- TestStaticCallTarget.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (TestStaticCallTarget.sol#284-312)\n\t- TestStaticCallTarget.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (TestStaticCallTarget.sol#317-337)\n\t- TestStaticCallTarget.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (TestStaticCallTarget.sol#354-378)\n\t- TestStaticCallTarget.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (TestStaticCallTarget.sol#384-422)\n\t- TestStaticCallTarget.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (TestStaticCallTarget.sol#428-447)\n\t- TestStaticCallTarget.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (TestStaticCallTarget.sol#453-471)\n\t- TestStaticCallTarget.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (TestStaticCallTarget.sol#494-516)\n\t- TestStaticCallTarget.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (TestStaticCallTarget.sol#523-527)\n\t- TestStaticCallTarget.sol#524-526\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestStaticCallTarget.sol:\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (TestStaticCallTarget.sol#550): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (TestStaticCallTarget.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (TestStaticCallTarget.sol#78-80) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _state;\n",
                    "message": "Variable 'TestStaticCallTarget._state' (TestStaticCallTarget.sol#556) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/test/TestERC20Bridge.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        testToken = new TestERC20BridgeToken();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 128,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": 168,
                    "vulnerability_code": "    function bridgeTransferFrom(\n\n        address tokenAddress,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes calldata bridgeData\n\n    )\n\n        external\n\n        returns (bytes4)\n\n    {\n\n        emit BridgeWithdrawTo(\n\n            tokenAddress,\n\n            from,\n\n            to,\n\n            amount,\n\n            bridgeData\n\n        );\n\n        // Unpack the bridgeData.\n\n        (\n\n            int256 transferAmount,\n\n            bytes memory revertData,\n\n            bytes memory returnData\n\n        ) = abi.decode(bridgeData, (int256, bytes, bytes));\n\n\n\n        // If `revertData` is set, revert.\n\n        if (revertData.length != 0) {\n\n            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n\n        }\n\n        // Increase `to`'s balance by `transferAmount`.\n\n        TestERC20BridgeToken(tokenAddress).addBalance(to, transferAmount);\n\n        // Return `returnData`.\n\n        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": "TestERC20Bridge.bridgeTransferFrom uses assembly (TestERC20Bridge.sol#136-168)\n\t- TestERC20Bridge.sol#162\n\t- TestERC20Bridge.sol#167\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in TestERC20Bridge.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- TestERC20Bridge.sol#21 declares pragma solidity^0.5.9\n\t- TestERC20Bridge.sol#83 declares pragma solidity^0.5.9\n\t- TestERC20Bridge.sol#84 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in TestERC20Bridge.sol:\n\t- pragma solidity^0.5.9 (TestERC20Bridge.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (TestERC20Bridge.sol#83): it allows old versions\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal BRIDGE_SUCCESS = 0xdc1600f3;\n",
                    "message": "IERC20Bridge.BRIDGE_SUCCESS (TestERC20Bridge.sol#27) is never used in TestERC20Bridge\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal BRIDGE_SUCCESS = 0xdc1600f3;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function bridgeTransferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 88,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) private _balances;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { revert(add(revertData, 0x20), mload(revertData)) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { return(add(returnData, 0x20), mload(returnData)) }\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/ERC721Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function ()\n\n        external\n\n    {\n\n        assembly {\n\n            // The first 4 bytes of calldata holds the function selector\n\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n\n\n            // `transferFrom` will be called with the following parameters:\n\n            // assetData Encoded byte array.\n\n            // from Address to transfer asset from.\n\n            // to Address to transfer asset to.\n\n            // amount Amount of asset to transfer.\n\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\n\n\n\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\n\n                // where k is the key left padded to 32 bytes and p is the storage slot\n\n                let start := mload(64)\n\n                mstore(start, and(caller, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(start, 32), authorized_slot)\n\n\n\n                // Revert if authorized[msg.sender] == false\n\n                if iszero(sload(keccak256(start, 64))) {\n\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                // `transferFrom`.\n\n                // The function is marked `external`, so no abi decodeding is done for\n\n                // us. Instead, we expect the `calldata` memory to contain the\n\n                // following:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 4 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. offset to assetData (*)        |\n\n                // |          | 36     |         |   2. from                           |\n\n                // |          | 68     |         |   3. to                             |\n\n                // |          | 100    |         |   4. amount                         |\n\n                // | Data     |        |         | assetData:                          |\n\n                // |          | 132    | 32      | assetData Length                    |\n\n                // |          | 164    | **      | assetData Contents                  |\n\n                //\n\n                // (*): offset is computed from start of function parameters, so offset\n\n                //      by an additional 4 bytes in the calldata.\n\n                //\n\n                // (**): see table below to compute length of assetData Contents\n\n                //\n\n                // WARNING: The ABIv2 specification allows additional padding between\n\n                //          the Params and Data section. This will result in a larger\n\n                //          offset to assetData.\n\n\n\n                // Asset data itself is encoded as follows:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 2 * 32  | function parameters:                |\n\n                // |          | 4      | 12 + 20 |   1. token address                  |\n\n                // |          | 36     |         |   2. tokenId                        |\n\n\n\n                // We construct calldata for the `token.transferFrom` ABI.\n\n                // The layout of this calldata is in the table below.\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 3 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. from                           |\n\n                // |          | 36     |         |   2. to                             |\n\n                // |          | 68     |         |   3. tokenId                        |\n\n\n\n                // There exists only 1 of each token.\n\n                // require(amount == 1, \"INVALID_AMOUNT\")\n\n                if sub(calldataload(100), 1) {\n\n                    // Revert with `Error(\"INVALID_AMOUNT\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000000e494e56414c49445f414d4f554e540000000000000000000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFrom` selector.\n\n                // Any trailing data in transferFromSelector will be\n\n                // overwritten in the next `mstore` call.\n\n                mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // We copy the fields `from` and `to` in bulk\n\n                // from our own calldata to the new calldata.\n\n                calldatacopy(4, 36, 64)\n\n\n\n                // Copy `tokenId` field from our own calldata to the new calldata.\n\n                let assetDataOffset := calldataload(4)\n\n                calldatacopy(68, add(assetDataOffset, 72), 32)\n\n\n\n                /////// Call `token.transferFrom` using the calldata ///////\n\n                let token := calldataload(add(assetDataOffset, 40))\n\n                let success := call(\n\n                    gas,            // forward all gas\n\n                    token,          // call address of token contract\n\n                    0,              // don't send any ETH\n\n                    0,              // pointer to start of input\n\n                    100,            // length of input\n\n                    0,              // write output to null\n\n                    0               // output size is 0 bytes\n\n                )\n\n                if success {\n\n                    return(0, 0)\n\n                }\n\n\n\n                // Revert with `Error(\"TRANSFER_FAILED\")`\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                mstore(64, 0x0000000f5452414e534645525f4641494c454400000000000000000000000000)\n\n                mstore(96, 0)\n\n                revert(0, 100)\n\n            }\n\n\n\n            // Revert if undefined function is called\n\n            revert(0, 0)\n\n        }\n",
                    "message": "ERC721Proxy.fallback uses assembly (ERC721Proxy.sol#277-406)\n\t- ERC721Proxy.sol#280-405\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (ERC721Proxy.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (ERC721Proxy.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC721Proxy.sol:\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#151): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Proxy.sol#268): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/ERC20Proxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor ()\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (authorities[i] == target) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities[i] = authorities[authorities.length - 1];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ONLY_CONTRACT_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[msg.sender],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 162,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SENDER_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            !authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 178,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_ALREADY_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 195,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 219,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorized[target],\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"TARGET_NOT_AUTHORIZED\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            index < authorities.length,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"INDEX_OUT_OF_BOUNDS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 227,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            authorities[index] == target,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"AUTHORIZED_ADDRESS_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "assembly",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": 419,
                    "vulnerability_code": "    function ()\n\n        external\n\n    {\n\n        assembly {\n\n            // The first 4 bytes of calldata holds the function selector\n\n            let selector := and(calldataload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n\n\n            // `transferFrom` will be called with the following parameters:\n\n            // assetData Encoded byte array.\n\n            // from Address to transfer asset from.\n\n            // to Address to transfer asset to.\n\n            // amount Amount of asset to transfer.\n\n            // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n\n            if eq(selector, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {\n\n\n\n                // To lookup a value in a mapping, we load from the storage location keccak256(k, p),\n\n                // where k is the key left padded to 32 bytes and p is the storage slot\n\n                let start := mload(64)\n\n                mstore(start, and(caller, 0xffffffffffffffffffffffffffffffffffffffff))\n\n                mstore(add(start, 32), authorized_slot)\n\n\n\n                // Revert if authorized[msg.sender] == false\n\n                if iszero(sload(keccak256(start, 64))) {\n\n                    // Revert with `Error(\"SENDER_NOT_AUTHORIZED\")`\n\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                    mstore(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)\n\n                    mstore(96, 0)\n\n                    revert(0, 100)\n\n                }\n\n\n\n                // `transferFrom`.\n\n                // The function is marked `external`, so no abi decodeding is done for\n\n                // us. Instead, we expect the `calldata` memory to contain the\n\n                // following:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 4 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. offset to assetData (*)        |\n\n                // |          | 36     |         |   2. from                           |\n\n                // |          | 68     |         |   3. to                             |\n\n                // |          | 100    |         |   4. amount                         |\n\n                // | Data     |        |         | assetData:                          |\n\n                // |          | 132    | 32      | assetData Length                    |\n\n                // |          | 164    | **      | assetData Contents                  |\n\n                //\n\n                // (*): offset is computed from start of function parameters, so offset\n\n                //      by an additional 4 bytes in the calldata.\n\n                //\n\n                // (**): see table below to compute length of assetData Contents\n\n                //\n\n                // WARNING: The ABIv2 specification allows additional padding between\n\n                //          the Params and Data section. This will result in a larger\n\n                //          offset to assetData.\n\n\n\n                // Asset data itself is encoded as follows:\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 1 * 32  | function parameters:                |\n\n                // |          | 4      | 12 + 20 |   1. token address                  |\n\n\n\n                // We construct calldata for the `token.transferFrom` ABI.\n\n                // The layout of this calldata is in the table below.\n\n                //\n\n                // | Area     | Offset | Length  | Contents                            |\n\n                // |----------|--------|---------|-------------------------------------|\n\n                // | Header   | 0      | 4       | function selector                   |\n\n                // | Params   |        | 3 * 32  | function parameters:                |\n\n                // |          | 4      |         |   1. from                           |\n\n                // |          | 36     |         |   2. to                             |\n\n                // |          | 68     |         |   3. amount                         |\n\n\n\n                /////// Read token address from calldata ///////\n\n                // * The token address is stored in `assetData`.\n\n                //\n\n                // * The \"offset to assetData\" is stored at offset 4 in the calldata (table 1).\n\n                //   [assetDataOffsetFromParams = calldataload(4)]\n\n                //\n\n                // * Notes that the \"offset to assetData\" is relative to the \"Params\" area of calldata;\n\n                //   add 4 bytes to account for the length of the \"Header\" area (table 1).\n\n                //   [assetDataOffsetFromHeader = assetDataOffsetFromParams + 4]\n\n                //\n\n                // * The \"token address\" is offset 32+4=36 bytes into \"assetData\" (tables 1 & 2).\n\n                //   [tokenOffset = assetDataOffsetFromHeader + 36 = calldataload(4) + 4 + 36]\n\n                let token := calldataload(add(calldataload(4), 40))\n\n\n\n                /////// Setup Header Area ///////\n\n                // This area holds the 4-byte `transferFrom` selector.\n\n                // Any trailing data in transferFromSelector will be\n\n                // overwritten in the next `mstore` call.\n\n                mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n\n\n\n                /////// Setup Params Area ///////\n\n                // We copy the fields `from`, `to` and `amount` in bulk\n\n                // from our own calldata to the new calldata.\n\n                calldatacopy(4, 36, 96)\n\n\n\n                /////// Call `token.transferFrom` using the calldata ///////\n\n                let success := call(\n\n                    gas,            // forward all gas\n\n                    token,          // call address of token contract\n\n                    0,              // don't send any ETH\n\n                    0,              // pointer to start of input\n\n                    100,            // length of input\n\n                    0,              // write output over input\n\n                    32              // output size should be 32 bytes\n\n                )\n\n\n\n                /////// Check return data. ///////\n\n                // If there is no return data, we assume the token incorrectly\n\n                // does not return a bool. In this case we expect it to revert\n\n                // on failure, which was handled above.\n\n                // If the token does return data, we require that it is a single\n\n                // nonzero 32 bytes value.\n\n                // So the transfer succeeded if the call succeeded and either\n\n                // returned nothing, or returned a non-zero 32 byte value.\n\n                success := and(success, or(\n\n                    iszero(returndatasize),\n\n                    and(\n\n                        eq(returndatasize, 32),\n\n                        gt(mload(0), 0)\n\n                    )\n\n                ))\n\n                if success {\n\n                    return(0, 0)\n\n                }\n\n\n\n                // Revert with `Error(\"TRANSFER_FAILED\")`\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\n                mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\n\n                mstore(64, 0x0000000f5452414e534645525f4641494c454400000000000000000000000000)\n\n                mstore(96, 0)\n\n                revert(0, 100)\n\n            }\n\n\n\n            // Revert if undefined function is called\n\n            revert(0, 0)\n\n        }\n",
                    "message": "ERC20Proxy.fallback uses assembly (ERC20Proxy.sol#277-419)\n\t- ERC20Proxy.sol#280-418\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (ERC20Proxy.sol#31) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 64,
                    "vulnerability_code": "    function transferOwnership(address newOwner)\n\n        public\n\n        onlyOwner\n\n    {\n\n        if (newOwner != address(0)) {\n\n            owner = newOwner;\n\n        }\n",
                    "message": "Ownable.transferOwnership (ERC20Proxy.sol#57-64) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC20Proxy.sol:\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#36): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#87): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#151): it allows old versions\n\t- pragma solidity^0.5.9 (ERC20Proxy.sol#268): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        authorities.length -= 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i < authorities.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/StaticCallProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedReturnDataHash == returnDataHash,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"UNEXPECTED_STATIC_CALL_RESULT\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_30"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (StaticCallProxy.sol#84-88) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress (StaticCallProxy.sol#122-127) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress (StaticCallProxy.sol#132-137) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy (StaticCallProxy.sol#143-243) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive (StaticCallProxy.sol#284-312) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte (StaticCallProxy.sol#317-337) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress (StaticCallProxy.sol#354-378) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress (StaticCallProxy.sol#384-422) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 (StaticCallProxy.sol#428-447) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 (StaticCallProxy.sol#453-471) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 (StaticCallProxy.sol#494-516) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength (StaticCallProxy.sol#523-527) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function transferFrom(\n\n        bytes calldata assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        external\n\n        view\n\n    {\n\n        // Decode params from `assetData`\n\n        (\n\n            address staticCallTarget,\n\n            bytes memory staticCallData,\n\n            bytes32 expectedReturnDataHash\n\n        ) = abi.decode(\n\n            assetData.sliceDestructive(4, assetData.length),\n\n            (address, bytes, bytes32)\n\n        );\n\n\n\n        // Execute staticcall\n\n        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n\n\n\n        // Revert with returned data if staticcall is unsuccessful\n\n        if (!success) {\n\n            assembly {\n\n                revert(add(returnData, 32), mload(returnData))\n\n            }\n\n        }\n\n\n\n        // Revert if hash of return data is not as expected\n\n        bytes32 returnDataHash = keccak256(returnData);\n\n        require(\n\n            expectedReturnDataHash == returnDataHash,\n\n            \"UNEXPECTED_STATIC_CALL_RESULT\"\n\n        );\n",
                    "message": "StaticCallProxy.transferFrom (StaticCallProxy.sol#565-600) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 88,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (StaticCallProxy.sol#84-88)\n\t- StaticCallProxy.sol#85-87\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": 127,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := input\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.rawAddress uses assembly (StaticCallProxy.sol#122-127)\n\t- StaticCallProxy.sol#123-125\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": 137,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n\n        assembly {\n\n            memoryAddress := add(input, 32)\n\n        }\n\n        return memoryAddress;\n",
                    "message": "LibBytes.contentAddress uses assembly (StaticCallProxy.sol#132-137)\n\t- StaticCallProxy.sol#133-135\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": 243,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n\n        if (length < 32) {\n\n            // Handle a partial word by reading destination and masking\n\n            // off the bits we are interested in.\n\n            // This correctly handles overlap, zero lengths and source == dest\n\n            assembly {\n\n                let mask := sub(exp(256, sub(32, length)), 1)\n\n                let s := and(mload(source), not(mask))\n\n                let d := and(mload(dest), mask)\n\n                mstore(dest, or(s, d))\n\n            }\n\n        } else {\n\n            // Skip the O(length) loop when source == dest.\n\n            if (source == dest) {\n\n                return;\n\n            }\n\n\n\n            // For large copies we copy whole words at a time. The final\n\n            // word is aligned to the end of the range (instead of after the\n\n            // previous) to handle partial words. So a copy will look like this:\n\n            //\n\n            //  ####\n\n            //      ####\n\n            //          ####\n\n            //            ####\n\n            //\n\n            // We handle overlap in the source and destination range by\n\n            // changing the copying direction. This prevents us from\n\n            // overwriting parts of source that we still need to copy.\n\n            //\n\n            // This correctly handles source == dest\n\n            //\n\n            if (source > dest) {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n\n                    // is easier to compare with in the loop, and these\n\n                    // are also the addresses we need for copying the\n\n                    // last bytes.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the last 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the last bytes in\n\n                    // source already due to overlap.\n\n                    let last := mload(sEnd)\n\n\n\n                    // Copy whole words front to back\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } lt(source, sEnd) {\n\n\n\n                    } {\n\n                        mstore(dest, mload(source))\n\n                        source := add(source, 32)\n\n                        dest := add(dest, 32)\n\n                    }\n\n\n\n                    // Write the last 32 bytes\n\n                    mstore(dEnd, last)\n\n                }\n\n            } else {\n\n                assembly {\n\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n\n                    // are the starting points when copying a word at the end.\n\n                    length := sub(length, 32)\n\n                    let sEnd := add(source, length)\n\n                    let dEnd := add(dest, length)\n\n\n\n                    // Remember the first 32 bytes of source\n\n                    // This needs to be done here and not after the loop\n\n                    // because we may have overwritten the first bytes in\n\n                    // source already due to overlap.\n\n                    let first := mload(source)\n\n\n\n                    // Copy whole words back to front\n\n                    // We use a signed comparisson here to allow dEnd to become\n\n                    // negative (happens when source and dest < 32). Valid\n\n                    // addresses in local memory will never be larger than\n\n                    // 2**255, so they can be safely re-interpreted as signed.\n\n                    // Note: the first check is always true,\n\n                    // this could have been a do-while loop.\n\n                    for {\n\n\n\n                    } slt(dest, dEnd) {\n\n\n\n                    } {\n\n                        mstore(dEnd, mload(sEnd))\n\n                        sEnd := sub(sEnd, 32)\n\n                        dEnd := sub(dEnd, 32)\n\n                    }\n\n\n\n                    // Write the first 32 bytes\n\n                    mstore(dest, first)\n\n                }\n\n            }\n\n        }\n",
                    "message": "LibBytes.memCopy uses assembly (StaticCallProxy.sol#143-243)\n\t- StaticCallProxy.sol#148-153\n\t- StaticCallProxy.sol#176-206\n\t- StaticCallProxy.sol#208-240\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": 312,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n\n        // Ensure that the from and to positions are valid positions for a slice within\n\n        // the byte array that is being used.\n\n        if (from > to) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.FromLessThanOrEqualsToRequired,\n\n                    from,\n\n                    to\n\n                )\n\n            );\n\n        }\n\n        if (to > b.length) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.ToLessThanOrEqualsLengthRequired,\n\n                    to,\n\n                    b.length\n\n                )\n\n            );\n\n        }\n\n\n\n        // Create a new bytes structure around [from, to) in-place.\n\n        assembly {\n\n            result := add(b, from)\n\n            mstore(result, sub(to, from))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.sliceDestructive uses assembly (StaticCallProxy.sol#284-312)\n\t- StaticCallProxy.sol#307-310\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": 337,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n\n        if (b.length == 0) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanZeroRequired,\n\n                    b.length,\n\n                    0\n\n                )\n\n            );\n\n        }\n\n\n\n        // Store last byte.\n\n        result = b[b.length - 1];\n\n\n\n        assembly {\n\n            // Decrement length of byte array.\n\n            let newLen := sub(mload(b), 1)\n\n            mstore(b, newLen)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.popLastByte uses assembly (StaticCallProxy.sol#317-337)\n\t- StaticCallProxy.sol#331-335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 378,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Read address from array memory\n\n        assembly {\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 20-byte mask to obtain address\n\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readAddress uses assembly (StaticCallProxy.sol#354-378)\n\t- StaticCallProxy.sol#371-376\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": 422,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n\n        if (b.length < index + 20) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsTwentyRequired,\n\n                    b.length,\n\n                    index + 20 // 20 is length of address\n\n                )\n\n            );\n\n        }\n\n\n\n        // Add offset to index:\n\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n\n        index += 20;\n\n\n\n        // Store address into array memory\n\n        assembly {\n\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n\n            // First fetch the 32-byte word where we'll be storing the address, then\n\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n\n\n            // 1. Add index to address of bytes array\n\n            // 2. Load 32-byte word from memory\n\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n\n            let neighbors := and(\n\n                mload(add(b, index)),\n\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n\n            )\n\n\n\n            // Make sure input address is clean.\n\n            // (Solidity does not guarantee this)\n\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n\n\n            // Store the neighbors and address into memory\n\n            mstore(add(b, index), xor(input, neighbors))\n\n        }\n",
                    "message": "LibBytes.writeAddress uses assembly (StaticCallProxy.sol#384-422)\n\t- StaticCallProxy.sol#401-421\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 447,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes32 uses assembly (StaticCallProxy.sol#428-447)\n\t- StaticCallProxy.sol#443-445\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": 471,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n\n        if (b.length < index + 32) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsThirtyTwoRequired,\n\n                    b.length,\n\n                    index + 32\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 256 bit length parameter\n\n        index += 32;\n\n\n\n        // Read the bytes32 from array memory\n\n        assembly {\n\n            mstore(add(b, index), input)\n\n        }\n",
                    "message": "LibBytes.writeBytes32 uses assembly (StaticCallProxy.sol#453-471)\n\t- StaticCallProxy.sol#468-470\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": 516,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n\n        if (b.length < index + 4) {\n\n            LibRichErrors.rrevert(\n\n                LibBytesRichErrors.InvalidByteOperationError(\n\n                    LibBytesRichErrors.InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsFourRequired,\n\n                    b.length,\n\n                    index + 4\n\n                )\n\n            );\n\n        }\n\n\n\n        // Arrays are prefixed by a 32 byte length field\n\n        index += 32;\n\n\n\n        // Read the bytes4 from array memory\n\n        assembly {\n\n            result := mload(add(b, index))\n\n            // Solidity does not require us to clean the trailing bytes.\n\n            // We do it anyway\n\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n\n        }\n\n        return result;\n",
                    "message": "LibBytes.readBytes4 uses assembly (StaticCallProxy.sol#494-516)\n\t- StaticCallProxy.sol#509-514\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n\n        assembly {\n\n            mstore(b, length)\n\n        }\n",
                    "message": "LibBytes.writeLength uses assembly (StaticCallProxy.sol#523-527)\n\t- StaticCallProxy.sol#524-526\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function transferFrom(\n\n        bytes calldata assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        external\n\n        view\n\n    {\n\n        // Decode params from `assetData`\n\n        (\n\n            address staticCallTarget,\n\n            bytes memory staticCallData,\n\n            bytes32 expectedReturnDataHash\n\n        ) = abi.decode(\n\n            assetData.sliceDestructive(4, assetData.length),\n\n            (address, bytes, bytes32)\n\n        );\n\n\n\n        // Execute staticcall\n\n        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n\n\n\n        // Revert with returned data if staticcall is unsuccessful\n\n        if (!success) {\n\n            assembly {\n\n                revert(add(returnData, 32), mload(returnData))\n\n            }\n\n        }\n\n\n\n        // Revert if hash of return data is not as expected\n\n        bytes32 returnDataHash = keccak256(returnData);\n\n        require(\n\n            expectedReturnDataHash == returnDataHash,\n\n            \"UNEXPECTED_STATIC_CALL_RESULT\"\n\n        );\n",
                    "message": "StaticCallProxy.transferFrom uses assembly (StaticCallProxy.sol#565-600)\n\t- StaticCallProxy.sol#589-591\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in StaticCallProxy.sol:\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#67): it allows old versions\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#111): it allows old versions\n\t- pragma solidity^0.5.9 (StaticCallProxy.sol#550): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": 600,
                    "vulnerability_code": "    function transferFrom(\n\n        bytes calldata assetData,\n\n        address from,\n\n        address to,\n\n        uint256 amount\n\n    )\n\n        external\n\n        view\n\n    {\n\n        // Decode params from `assetData`\n\n        (\n\n            address staticCallTarget,\n\n            bytes memory staticCallData,\n\n            bytes32 expectedReturnDataHash\n\n        ) = abi.decode(\n\n            assetData.sliceDestructive(4, assetData.length),\n\n            (address, bytes, bytes32)\n\n        );\n\n\n\n        // Execute staticcall\n\n        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n\n\n\n        // Revert with returned data if staticcall is unsuccessful\n\n        if (!success) {\n\n            assembly {\n\n                revert(add(returnData, 32), mload(returnData))\n\n            }\n\n        }\n\n\n\n        // Revert if hash of return data is not as expected\n\n        bytes32 returnDataHash = keccak256(returnData);\n\n        require(\n\n            expectedReturnDataHash == returnDataHash,\n\n            \"UNEXPECTED_STATIC_CALL_RESULT\"\n\n        );\n",
                    "message": "Low level call in StaticCallProxy.transferFrom (StaticCallProxy.sol#565-600):\n\t-(success,returnData) = staticCallTarget.staticcall(staticCallData) StaticCallProxy.sol#585\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 44,
                    "vulnerability_code": "    function InvalidByteOperationError(\n\n        InvalidByteOperationErrorCodes errorCode,\n\n        uint256 offset,\n\n        uint256 required\n\n    ) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "Function 'LibBytesRichErrors.InvalidByteOperationError' (StaticCallProxy.sol#38-44) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 80,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (StaticCallProxy.sol#78-80) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 143,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 317,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 453,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 523,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returnData) = staticCallTarget.staticcall(staticCallData);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 123,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 208,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 331,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 468,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IEth2Dai.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IEth2Dai.sol:\n\t- pragma solidity^0.5.9 (IEth2Dai.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IUniswapV2Router01.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IUniswapV2Router01.sol:\n\t- pragma solidity^0.5.9 (IUniswapV2Router01.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function swapExactTokensForTokens(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address[] calldata path,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address to,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint deadline\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external returns (uint[] memory amounts);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IShell.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IShell.sol:\n\t- pragma solidity^0.5.9 (IShell.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IAuthorizable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public;\n",
                    "message": "IOwnable.transferOwnership (IAuthorizable.sol#31) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAuthorizable.sol:\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IAuthorizable.sol#54): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IKyberNetworkProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IKyberNetworkProxy.sol:\n\t- pragma solidity^0.5.9 (IKyberNetworkProxy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function trade(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function tradeWithHint(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable recipientAddress,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 maxBuyTokenAmount,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 minConversionRate,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address walletId\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256 boughtAmount);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable recipientAddress,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 maxBuyTokenAmount,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 minConversionRate,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address payable walletId,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata hint\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (uint256 boughtAmount);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IAssetProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxy.sol:\n\t- pragma solidity^0.5.9 (IAssetProxy.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IDydx.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IDydx.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IDydx.sol#21 declares pragma solidity^0.5.9\n\t- IDydx.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IDydx.sol:\n\t- pragma solidity^0.5.9 (IDydx.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (Value memory supplyValue, Value memory borrowValue);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IAssetData.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_8"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IAssetData.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IAssetData.sol#22 declares pragma solidity^0.5.9\n\t- IAssetData.sol#23 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetData.sol:\n\t- pragma solidity^0.5.9 (IAssetData.sol#22): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function ERC20Token(address tokenAddress)\n",
                    "message": "Function 'IAssetData.ERC20Token' (IAssetData.sol#33-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": 43,
                    "vulnerability_code": "    function ERC721Token(\n\n        address tokenAddress,\n\n        uint256 tokenId\n\n    )\n",
                    "message": "Function 'IAssetData.ERC721Token' (IAssetData.sol#39-43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function ERC1155Assets(\n\n        address tokenAddress,\n\n        uint256[] calldata tokenIds,\n\n        uint256[] calldata values,\n\n        bytes calldata callbackData\n\n    )\n",
                    "message": "Function 'IAssetData.ERC1155Assets' (IAssetData.sol#51-57) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": 67,
                    "vulnerability_code": "    function MultiAsset(\n\n        uint256[] calldata values,\n\n        bytes[] calldata nestedAssetData\n\n    )\n",
                    "message": "Function 'IAssetData.MultiAsset' (IAssetData.sol#63-67) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 78,
                    "vulnerability_code": "    function StaticCall(\n\n        address staticCallTargetAddress,\n\n        bytes calldata staticCallData,\n\n        bytes32 expectedReturnDataHash\n\n    )\n",
                    "message": "Function 'IAssetData.StaticCall' (IAssetData.sol#73-78) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 84,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "    function ERC20Bridge(\n\n        address tokenAddress,\n\n        address bridgeAddress,\n\n        bytes calldata bridgeData\n\n    )\n",
                    "message": "Function 'IAssetData.ERC20Bridge' (IAssetData.sol#84-89) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ERC1155Assets(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function StaticCall(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 53,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata tokenIds,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata callbackData\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 75,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata staticCallData,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes32 expectedReturnDataHash\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IUniswapExchange.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IUniswapExchange.sol:\n\t- pragma solidity^0.5.9 (IUniswapExchange.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IBancorNetwork.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IBancorNetwork.sol:\n\t- pragma solidity^0.5.9 (IBancorNetwork.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract IBancorNetwork {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IMooniswap.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IMooniswap.sol:\n\t- pragma solidity^0.5.9 (IMooniswap.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IBalancerPool.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IBalancerPool.sol:\n\t- pragma solidity^0.5.9 (IBalancerPool.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IERC20Bridge.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC20Bridge.sol:\n\t- pragma solidity^0.5.9 (IERC20Bridge.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant internal BRIDGE_SUCCESS = 0xdc1600f3;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IAssetProxyDispatcher.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IAssetProxyDispatcher.sol:\n\t- pragma solidity^0.5.9 (IAssetProxyDispatcher.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/ICurve.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ICurve.sol:\n\t- pragma solidity^0.5.9 (ICurve.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": 39,
                    "vulnerability_code": "    function exchange_underlying(\n\n        int128 i,\n\n        int128 j,\n\n        uint256 sellAmount,\n\n        uint256 minBuyAmount\n\n    )\n",
                    "message": "Function 'ICurve.exchange_underlying' (ICurve.sol#33-39) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 51,
                    "vulnerability_code": "    function get_dy_underlying(\n\n        int128 i,\n\n        int128 j,\n\n        uint256 sellAmount\n\n    )\n\n        external\n",
                    "message": "Function 'ICurve.get_dy_underlying' (ICurve.sol#45-51) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function get_dx_underlying(\n\n        int128 i,\n\n        int128 j,\n\n        uint256 buyAmount\n\n    )\n\n        external\n",
                    "message": "Function 'ICurve.get_dx_underlying' (ICurve.sol#57-63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function underlying_coins(\n\n        int128 i\n\n    )\n\n        external\n",
                    "message": "Function 'ICurve.underlying_coins' (ICurve.sol#67-71) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IMStable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IMStable.sol:\n\t- pragma solidity^0.5.9 (IMStable.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IUniswapExchangeFactory.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IUniswapExchangeFactory.sol:\n\t- pragma solidity^0.5.9 (IUniswapExchangeFactory.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (IUniswapExchangeFactory.sol#94): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/asset-proxy/contracts/src/interfaces/IDydxBridge.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IDydxBridge.sol:\n\t- pragma solidity^0.5.9 (IDydxBridge.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/test/InvalidERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in InvalidERC721Receiver.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- InvalidERC721Receiver.sol#21 declares pragma solidity^0.5.9\n\t- InvalidERC721Receiver.sol#68 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in InvalidERC721Receiver.sol:\n\t- pragma solidity^0.5.9 (InvalidERC721Receiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (InvalidERC721Receiver.sol#68): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _operator,\n",
                    "message": "Parameter '_operator' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#96) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of InvalidERC721Receiver.onERC721Received (InvalidERC721Receiver.sol#99) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/test/DummyERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 759,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(ONLY_OWNER_ERROR_SELECTOR, sender, owner);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    Ownable,\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _name,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        string memory _symbol\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    )\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        public\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 860,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = _name;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = _symbol;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 862,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_INVALID_SENDER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _to != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_TO_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _from == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            spender == owner ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isApprovedForAll(owner, spender) ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approvedAddress == spender,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_INVALID_SPENDER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _to != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_TO_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 670,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 698,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner == _owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 753,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR = 0x1de45ad1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approvals[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 749,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/test/DummyERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in DummyERC721Receiver.sol:\n\t- Version used: ['^0.5.5', '^0.5.9']\n\t- DummyERC721Receiver.sol#21 declares pragma solidity^0.5.9\n\t- DummyERC721Receiver.sol#68 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in DummyERC721Receiver.sol:\n\t- pragma solidity^0.5.9 (DummyERC721Receiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (DummyERC721Receiver.sol#68): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _operator,\n",
                    "message": "Parameter '_operator' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#97) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#99) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of DummyERC721Receiver.onERC721Received (DummyERC721Receiver.sol#100) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/src/ERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_INVALID_SENDER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _to != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_TO_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _from == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            spender == owner ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isApprovedForAll(owner, spender) ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approvedAddress == spender,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_INVALID_SPENDER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_29"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 250,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (ERC721Token.sol#246-250) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 160,
                    "vulnerability_code": "contract IERC721Token {\n\n\n\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n\n    ///      This event emits when NFTs are created (`from` == 0) and destroyed\n\n    ///      (`to` == 0). Exception: during contract creation, any number of NFTs\n\n    ///      may be created and assigned without emitting Transfer. At the time of\n\n    ///      any transfer, the approved address for that NFT (if any) is reset to none.\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when the approved address for an NFT is changed or\n\n    ///      reaffirmed. The zero address indicates there is no approved address.\n\n    ///      When a Transfer event emits, this also indicates that the approved\n\n    ///      address for that NFT (if any) is reset to none.\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n\n    ///      The operator can manage all NFTs of the owner.\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      perator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external;\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external;\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external;\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256);\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address);\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n\n        returns (address);\n\n    \n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n",
                    "message": "IERC721Token (ERC721Token.sol#24-160) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#94-95)\n\t-transferFrom (ERC721Token.sol#126-131)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": 627,
                    "vulnerability_code": "contract ERC721Token is\n\n    IERC721Token\n\n{\n\n    using LibSafeMath for uint256;\n\n\n\n    // Function selector for ERC721Receiver.onERC721Received\n\n    // 0x150b7a02\n\n    bytes4 constant internal ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n\n\n\n    // Mapping of tokenId => owner\n\n    mapping (uint256 => address) internal owners;\n\n\n\n    // Mapping of tokenId => approved address\n\n    mapping (uint256 => address) internal approvals;\n\n\n\n    // Mapping of owner => number of tokens owned\n\n    mapping (address => uint256) internal balances;\n\n\n\n    // Mapping of owner => operator => approved\n\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                \"\"\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(\n\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n\n            \"ERC721_INVALID_SENDER\"\n\n        );\n\n\n\n        approvals[_tokenId] = _approved;\n\n        emit Approval(\n\n            owner,\n\n            _approved,\n\n            _tokenId\n\n        );\n\n    }\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external\n\n    {\n\n        operatorApprovals[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(\n\n            msg.sender,\n\n            _operator,\n\n            _approved\n\n        );\n\n    }\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(\n\n            _owner != address(0),\n\n            \"ERC721_ZERO_OWNER\"\n\n        );\n\n        return balances[_owner];\n\n    }\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public\n\n    {\n\n        require(\n\n            _to != address(0),\n\n            \"ERC721_ZERO_TO_ADDRESS\"\n\n        );\n\n\n\n        address owner = ownerOf(_tokenId);\n\n        require(\n\n            _from == owner,\n\n            \"ERC721_OWNER_MISMATCH\"\n\n        );\n\n\n\n        address spender = msg.sender;\n\n        address approvedAddress = getApproved(_tokenId);\n\n        require(\n\n            spender == owner ||\n\n            isApprovedForAll(owner, spender) ||\n\n            approvedAddress == spender,\n\n            \"ERC721_INVALID_SPENDER\"\n\n        );\n\n\n\n        if (approvedAddress != address(0)) {\n\n            approvals[_tokenId] = address(0);\n\n        }\n\n\n\n        owners[_tokenId] = _to;\n\n        balances[_from] = balances[_from].safeSub(1);\n\n        balances[_to] = balances[_to].safeAdd(1);\n\n\n\n        emit Transfer(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n    }\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        address owner = owners[_tokenId];\n\n        require(\n\n            owner != address(0),\n\n            \"ERC721_ZERO_OWNER\"\n\n        );\n\n        return owner;\n\n    }\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return approvals[_tokenId];\n\n    }\n\n\n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return operatorApprovals[_owner][_operator];\n\n    }\n",
                    "message": "ERC721Token (ERC721Token.sol#375-627) has incorrect ERC20 function interface(s):\n\t-approve (ERC721Token.sol#483-498)\n\t-transferFrom (ERC721Token.sol#544-584)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": 250,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (ERC721Token.sol#246-250)\n\t- ERC721Token.sol#247-249\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n",
                    "message": "ERC721Token.safeTransferFrom uses assembly (ERC721Token.sol#408-438)\n\t- ERC721Token.sol#423-425\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                \"\"\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n",
                    "message": "ERC721Token.safeTransferFrom uses assembly (ERC721Token.sol#446-475)\n\t- ERC721Token.sol#460-462\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in ERC721Token.sol:\n\t- pragma solidity^0.5.9 (ERC721Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#182): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#229): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#255): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#288): it allows old versions\n\t- pragma solidity^0.5.9 (ERC721Token.sol#371): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": 242,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (ERC721Token.sol#240-242) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 277,
                    "vulnerability_to_line": 279,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (ERC721Token.sol#277-279) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 281,
                    "vulnerability_to_line": 283,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (ERC721Token.sol#281-283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#409) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of ERC721Token.safeTransferFrom (ERC721Token.sol#412) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (ERC721Token.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (ERC721Token.sol#448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (ERC721Token.sol#449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_approved' of ERC721Token.approve (ERC721Token.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.approve (ERC721Token.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "Parameter '_operator' of ERC721Token.setApprovalForAll (ERC721Token.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "Parameter '_approved' of ERC721Token.setApprovalForAll (ERC721Token.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC721Token.balanceOf (ERC721Token.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.transferFrom (ERC721Token.sol#545) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.transferFrom (ERC721Token.sol#546) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of ERC721Token.transferFrom (ERC721Token.sol#547) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.ownerOf (ERC721Token.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.getApproved (ERC721Token.sol#608) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of ERC721Token.isApprovedForAll (ERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of ERC721Token.isApprovedForAll (ERC721Token.sol#620) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 233,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approvals[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 247,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/src/MintableERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 471,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                selector == ERC721_RECEIVED,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                \"ERC721_INVALID_SELECTOR\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_INVALID_SENDER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 530,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _to != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 553,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_TO_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 557,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _from == owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 560,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 564,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 565,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            spender == owner ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 566,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            isApprovedForAll(owner, spender) ||\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approvedAddress == spender,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_INVALID_SPENDER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 569,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 597,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _to != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_TO_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 670,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner == address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_ALREADY_EXISTS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _owner != address(0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_ZERO_OWNER_ADDRESS\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 698,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            owner == _owner,\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"ERC721_OWNER_MISMATCH\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert (MintableERC721Token.sol#38-42) is declared view but contains assembly code\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 166,
                    "vulnerability_to_line": 302,
                    "vulnerability_code": "contract IERC721Token {\n\n\n\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n\n    ///      This event emits when NFTs are created (`from` == 0) and destroyed\n\n    ///      (`to` == 0). Exception: during contract creation, any number of NFTs\n\n    ///      may be created and assigned without emitting Transfer. At the time of\n\n    ///      any transfer, the approved address for that NFT (if any) is reset to none.\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when the approved address for an NFT is changed or\n\n    ///      reaffirmed. The zero address indicates there is no approved address.\n\n    ///      When a Transfer event emits, this also indicates that the approved\n\n    ///      address for that NFT (if any) is reset to none.\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n\n    ///      The operator can manage all NFTs of the owner.\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      perator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external;\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external;\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external;\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256);\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address);\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n\n        returns (address);\n\n    \n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n",
                    "message": "IERC721Token (MintableERC721Token.sol#166-302) has incorrect ERC20 function interface(s):\n\t-approve (MintableERC721Token.sol#236-237)\n\t-transferFrom (MintableERC721Token.sol#268-273)\n"
                },
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": 627,
                    "vulnerability_code": "contract ERC721Token is\n\n    IERC721Token\n\n{\n\n    using LibSafeMath for uint256;\n\n\n\n    // Function selector for ERC721Receiver.onERC721Received\n\n    // 0x150b7a02\n\n    bytes4 constant internal ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n\n\n\n    // Mapping of tokenId => owner\n\n    mapping (uint256 => address) internal owners;\n\n\n\n    // Mapping of tokenId => approved address\n\n    mapping (uint256 => address) internal approvals;\n\n\n\n    // Mapping of owner => number of tokens owned\n\n    mapping (address => uint256) internal balances;\n\n\n\n    // Mapping of owner => operator => approved\n\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                \"\"\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n\n    }\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external\n\n    {\n\n        address owner = ownerOf(_tokenId);\n\n        require(\n\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n\n            \"ERC721_INVALID_SENDER\"\n\n        );\n\n\n\n        approvals[_tokenId] = _approved;\n\n        emit Approval(\n\n            owner,\n\n            _approved,\n\n            _tokenId\n\n        );\n\n    }\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external\n\n    {\n\n        operatorApprovals[msg.sender][_operator] = _approved;\n\n        emit ApprovalForAll(\n\n            msg.sender,\n\n            _operator,\n\n            _approved\n\n        );\n\n    }\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256)\n\n    {\n\n        require(\n\n            _owner != address(0),\n\n            \"ERC721_ZERO_OWNER\"\n\n        );\n\n        return balances[_owner];\n\n    }\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public\n\n    {\n\n        require(\n\n            _to != address(0),\n\n            \"ERC721_ZERO_TO_ADDRESS\"\n\n        );\n\n\n\n        address owner = ownerOf(_tokenId);\n\n        require(\n\n            _from == owner,\n\n            \"ERC721_OWNER_MISMATCH\"\n\n        );\n\n\n\n        address spender = msg.sender;\n\n        address approvedAddress = getApproved(_tokenId);\n\n        require(\n\n            spender == owner ||\n\n            isApprovedForAll(owner, spender) ||\n\n            approvedAddress == spender,\n\n            \"ERC721_INVALID_SPENDER\"\n\n        );\n\n\n\n        if (approvedAddress != address(0)) {\n\n            approvals[_tokenId] = address(0);\n\n        }\n\n\n\n        owners[_tokenId] = _to;\n\n        balances[_from] = balances[_from].safeSub(1);\n\n        balances[_to] = balances[_to].safeAdd(1);\n\n\n\n        emit Transfer(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n    }\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        address owner = owners[_tokenId];\n\n        require(\n\n            owner != address(0),\n\n            \"ERC721_ZERO_OWNER\"\n\n        );\n\n        return owner;\n\n    }\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address)\n\n    {\n\n        return approvals[_tokenId];\n\n    }\n\n\n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return operatorApprovals[_owner][_operator];\n\n    }\n",
                    "message": "ERC721Token (MintableERC721Token.sol#375-627) has incorrect ERC20 function interface(s):\n\t-approve (MintableERC721Token.sol#483-498)\n\t-transferFrom (MintableERC721Token.sol#544-584)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n\n        assembly {\n\n            revert(add(errorData, 0x20), mload(errorData))\n\n        }\n",
                    "message": "LibRichErrors.rrevert uses assembly (MintableERC721Token.sol#38-42)\n\t- MintableERC721Token.sol#39-41\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                _data\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n",
                    "message": "ERC721Token.safeTransferFrom uses assembly (MintableERC721Token.sol#408-438)\n\t- MintableERC721Token.sol#423-425\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": 475,
                    "vulnerability_code": "    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n    {\n\n        transferFrom(\n\n            _from,\n\n            _to,\n\n            _tokenId\n\n        );\n\n\n\n        uint256 receiverCodeSize;\n\n        assembly {\n\n            receiverCodeSize := extcodesize(_to)\n\n        }\n\n        if (receiverCodeSize > 0) {\n\n            bytes4 selector = IERC721Receiver(_to).onERC721Received(\n\n                msg.sender,\n\n                _from,\n\n                _tokenId,\n\n                \"\"\n\n            );\n\n            require(\n\n                selector == ERC721_RECEIVED,\n\n                \"ERC721_INVALID_SELECTOR\"\n\n            );\n\n        }\n",
                    "message": "ERC721Token.safeTransferFrom uses assembly (MintableERC721Token.sol#446-475)\n\t- MintableERC721Token.sol#460-462\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MintableERC721Token.sol:\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#21): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#47): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#80): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#163): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#324): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#371): it allows old versions\n\t- pragma solidity^0.5.9 (MintableERC721Token.sol#649): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": 34,
                    "vulnerability_code": "    function StandardError(string memory message) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "Function 'LibRichErrors.StandardError' (MintableERC721Token.sol#32-34) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": 71,
                    "vulnerability_code": "    function Uint256BinOpError(BinOpErrorCodes errorCode, uint256 a, uint256 b) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_BINOP_ERROR_SELECTOR, errorCode, a, b);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256BinOpError' (MintableERC721Token.sol#69-71) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": 75,
                    "vulnerability_code": "    function Uint256DowncastError(DowncastErrorCodes errorCode, uint256 a) internal pure returns (bytes memory) {\n\n        return abi.encodeWithSelector(UINT256_DOWNCAST_ERROR_SELECTOR, errorCode, a);\n",
                    "message": "Function 'LibSafeMathRichErrors.Uint256DowncastError' (MintableERC721Token.sol#73-75) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#409) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#410) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId,\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata _data\n",
                    "message": "Parameter '_data' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#412) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of ERC721Token.safeTransferFrom (MintableERC721Token.sol#449) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_approved' of ERC721Token.approve (MintableERC721Token.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.approve (MintableERC721Token.sol#483) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "Parameter '_operator' of ERC721Token.setApprovalForAll (MintableERC721Token.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setApprovalForAll(address _operator, bool _approved)\n",
                    "message": "Parameter '_approved' of ERC721Token.setApprovalForAll (MintableERC721Token.sol#506) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address _owner)\n",
                    "message": "Parameter '_owner' of ERC721Token.balanceOf (MintableERC721Token.sol#522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _from,\n",
                    "message": "Parameter '_from' of ERC721Token.transferFrom (MintableERC721Token.sol#545) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _to,\n",
                    "message": "Parameter '_to' of ERC721Token.transferFrom (MintableERC721Token.sol#546) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 _tokenId\n",
                    "message": "Parameter '_tokenId' of ERC721Token.transferFrom (MintableERC721Token.sol#547) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 591,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.ownerOf (MintableERC721Token.sol#591) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of ERC721Token.getApproved (MintableERC721Token.sol#608) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_owner' of ERC721Token.isApprovedForAll (MintableERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n",
                    "message": "Parameter '_operator' of ERC721Token.isApprovedForAll (MintableERC721Token.sol#620) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": 683,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(\n\n            _to != address(0),\n\n            \"ERC721_ZERO_TO_ADDRESS\"\n\n        );\n\n\n\n        address owner = owners[_tokenId];\n\n        require(\n\n            owner == address(0),\n\n            \"ERC721_OWNER_ALREADY_EXISTS\"\n\n        );\n\n\n\n        owners[_tokenId] = _to;\n\n        balances[_to] = balances[_to].safeAdd(1);\n\n\n\n        emit Transfer(\n\n            address(0),\n\n            _to,\n\n            _tokenId\n\n        );\n",
                    "message": "Function 'MintableERC721Token._mint' (MintableERC721Token.sol#661-683) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_to' of MintableERC721Token._mint (MintableERC721Token.sol#661) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 661,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _mint(address _to, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of MintableERC721Token._mint (MintableERC721Token.sol#661) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": 711,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n\n        internal\n\n    {\n\n        require(\n\n            _owner != address(0),\n\n            \"ERC721_ZERO_OWNER_ADDRESS\"\n\n        );\n\n\n\n        address owner = owners[_tokenId];\n\n        require(\n\n            owner == _owner,\n\n            \"ERC721_OWNER_MISMATCH\"\n\n        );\n\n\n\n        owners[_tokenId] = address(0);\n\n        balances[_owner] = balances[_owner].safeSub(1);\n\n\n\n        emit Transfer(\n\n            _owner,\n\n            address(0),\n\n            _tokenId\n\n        );\n",
                    "message": "Function 'MintableERC721Token._burn' (MintableERC721Token.sol#689-711) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_owner' of MintableERC721Token._burn (MintableERC721Token.sol#689) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _burn(address _owner, uint256 _tokenId)\n",
                    "message": "Parameter '_tokenId' of MintableERC721Token._burn (MintableERC721Token.sol#689) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR = 0xe946c1bb;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR = 0xc996af7b;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            approvals[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owners[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address _approved, uint256 _tokenId)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 371,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/src/interfaces/IERC721Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC721Receiver.sol:\n\t- pragma solidity^0.5.9 (IERC721Receiver.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc721/contracts/src/interfaces/IERC721Token.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "erc20-interface",
                    "vulnerability_from_line": 24,
                    "vulnerability_to_line": 160,
                    "vulnerability_code": "contract IERC721Token {\n\n\n\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n\n    ///      This event emits when NFTs are created (`from` == 0) and destroyed\n\n    ///      (`to` == 0). Exception: during contract creation, any number of NFTs\n\n    ///      may be created and assigned without emitting Transfer. At the time of\n\n    ///      any transfer, the approved address for that NFT (if any) is reset to none.\n\n    event Transfer(\n\n        address indexed _from,\n\n        address indexed _to,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when the approved address for an NFT is changed or\n\n    ///      reaffirmed. The zero address indicates there is no approved address.\n\n    ///      When a Transfer event emits, this also indicates that the approved\n\n    ///      address for that NFT (if any) is reset to none.\n\n    event Approval(\n\n        address indexed _owner,\n\n        address indexed _approved,\n\n        uint256 indexed _tokenId\n\n    );\n\n\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n\n    ///      The operator can manage all NFTs of the owner.\n\n    event ApprovalForAll(\n\n        address indexed _owner,\n\n        address indexed _operator,\n\n        bool _approved\n\n    );\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      perator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT. When transfer is complete, this function\n\n    ///      checks if `_to` is a smart contract (code size > 0). If so, it calls\n\n    ///      `onERC721Received` on `_to` and throws if the return value is not\n\n    ///      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    /// @param _data Additional data with no specified format, sent in call to `_to`\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId,\n\n        bytes calldata _data\n\n    )\n\n        external;\n\n\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n\n    /// @dev This works identically to the other function with an extra data parameter,\n\n    ///      except this function just sets data to \"\".\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function safeTransferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external;\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n\n    /// @dev The zero address indicates there is no approved address.\n\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized\n\n    ///      operator of the current owner.\n\n    /// @param _approved The new approved NFT controller\n\n    /// @param _tokenId The NFT to approve\n\n    function approve(address _approved, uint256 _tokenId)\n\n        external;\n\n\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n\n    ///         all of `msg.sender`'s assets\n\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n\n    ///      multiple operators per owner.\n\n    /// @param _operator Address to add to the set of authorized operators\n\n    /// @param _approved True if the operator is approved, false to revoke approval\n\n    function setApprovalForAll(address _operator, bool _approved)\n\n        external;\n\n\n\n    /// @notice Count all NFTs assigned to an owner\n\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n\n    ///      function throws for queries about the zero address.\n\n    /// @param _owner An address for whom to query the balance\n\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n\n    function balanceOf(address _owner)\n\n        external\n\n        view\n\n        returns (uint256);\n\n\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\n    ///         TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\n    ///         THEY MAY BE PERMANENTLY LOST\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n\n    ///      operator, or the approved address for this NFT. Throws if `_from` is\n\n    ///      not the current owner. Throws if `_to` is the zero address. Throws if\n\n    ///      `_tokenId` is not a valid NFT.\n\n    /// @param _from The current owner of the NFT\n\n    /// @param _to The new owner\n\n    /// @param _tokenId The NFT to transfer\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        public;\n\n\n\n    /// @notice Find the owner of an NFT\n\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n\n    ///      about them do throw.\n\n    /// @param _tokenId The identifier for an NFT\n\n    /// @return The address of the owner of the NFT\n\n    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n\n        returns (address);\n\n\n\n    /// @notice Get the approved address for a single NFT\n\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n\n    /// @param _tokenId The NFT to find the approved address for\n\n    /// @return The approved address for this NFT, or the zero address if there is none\n\n    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n\n        returns (address);\n\n    \n\n    /// @notice Query if an address is an authorized operator for another address\n\n    /// @param _owner The address that owns the NFTs\n\n    /// @param _operator The address that acts on behalf of the owner\n\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\n    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n\n        returns (bool);\n",
                    "message": "IERC721Token (IERC721Token.sol#24-160) has incorrect ERC20 function interface(s):\n\t-approve (IERC721Token.sol#94-95)\n\t-transferFrom (IERC721Token.sol#126-131)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": 131,
                    "vulnerability_code": "    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n",
                    "message": "IERC721Token.transferFrom (IERC721Token.sol#126-131) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 138,
                    "vulnerability_to_line": 141,
                    "vulnerability_code": "    function ownerOf(uint256 _tokenId)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.ownerOf (IERC721Token.sol#138-141) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 150,
                    "vulnerability_code": "    function getApproved(uint256 _tokenId) \n\n        public\n\n        view\n",
                    "message": "IERC721Token.getApproved (IERC721Token.sol#147-150) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 156,
                    "vulnerability_to_line": 159,
                    "vulnerability_code": "    function isApprovedForAll(address _owner, address _operator)\n\n        public\n\n        view\n",
                    "message": "IERC721Token.isApprovedForAll (IERC721Token.sol#156-159) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC721Token.sol:\n\t- pragma solidity^0.5.9 (IERC721Token.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-forwarder/contracts/src/MixinReceiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinReceiver.sol:\n\t- pragma solidity^0.5.9 (MixinReceiver.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public ERC1155_RECEIVED       = 0xf23a6e61;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public ERC1155_BATCH_RECEIVED = 0xbc197c81;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes4)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 76,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return ERC1155_BATCH_RECEIVED;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-forwarder/contracts/src/libs/LibForwarderRichErrors.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(UNREGISTERED_ASSET_PROXY_ERROR_SELECTOR);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 63,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            COMPLETE_BUY_FAILED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedAssetBuyAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actualAssetBuyAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 79,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            COMPLETE_SELL_FAILED_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 80,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            expectedAssetSellAmount,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            actualAssetSellAmount\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            UNSUPPORTED_FEE_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            takerFeeAssetData\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 106,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 107,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OVERSPENT_WETH_ERROR_SELECTOR,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 108,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            wethSpent,\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            msgValue\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_6"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in LibForwarderRichErrors.sol:\n\t- pragma solidity^0.5.9 (LibForwarderRichErrors.sol#21): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": 53,
                    "vulnerability_code": "    function UnregisteredAssetProxyError()\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(UNREGISTERED_ASSET_PROXY_ERROR_SELECTOR);\n",
                    "message": "Function 'LibForwarderRichErrors.UnregisteredAssetProxyError' (LibForwarderRichErrors.sol#47-53) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 68,
                    "vulnerability_code": "    function CompleteBuyFailedError(\n\n        uint256 expectedAssetBuyAmount,\n\n        uint256 actualAssetBuyAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            COMPLETE_BUY_FAILED_ERROR_SELECTOR,\n\n            expectedAssetBuyAmount,\n\n            actualAssetBuyAmount\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.CompleteBuyFailedError' (LibForwarderRichErrors.sol#55-68) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": 83,
                    "vulnerability_code": "    function CompleteSellFailedError(\n\n        uint256 expectedAssetSellAmount,\n\n        uint256 actualAssetSellAmount\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            COMPLETE_SELL_FAILED_ERROR_SELECTOR,\n\n            expectedAssetSellAmount,\n\n            actualAssetSellAmount\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.CompleteSellFailedError' (LibForwarderRichErrors.sol#70-83) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": 96,
                    "vulnerability_code": "    function UnsupportedFeeError(\n\n        bytes memory takerFeeAssetData\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            UNSUPPORTED_FEE_ERROR_SELECTOR,\n\n            takerFeeAssetData\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.UnsupportedFeeError' (LibForwarderRichErrors.sol#85-96) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 111,
                    "vulnerability_code": "    function OverspentWethError(\n\n        uint256 wethSpent,\n\n        uint256 msgValue\n\n    )\n\n        internal\n\n        pure\n\n        returns (bytes memory)\n\n    {\n\n        return abi.encodeWithSelector(\n\n            OVERSPENT_WETH_ERROR_SELECTOR,\n\n            wethSpent,\n\n            msgValue\n\n        );\n",
                    "message": "Function 'LibForwarderRichErrors.OverspentWethError' (LibForwarderRichErrors.sol#98-111) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xf3b96b8d;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x91353a0c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x450a0219;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0x31360af1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        0xcdcbed5d;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/exchange-forwarder/contracts/src/interfaces/IExchangeV2.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IExchangeV2.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IExchangeV2.sol#21 declares pragma solidity^0.5.9\n\t- IExchangeV2.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 68,
                    "vulnerability_code": "    function fillOrder(\n\n        Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n        public\n",
                    "message": "IExchangeV2.fillOrder (IExchangeV2.sol#62-68) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 76,
                    "vulnerability_code": "    function getOrderInfo(Order memory order)\n\n        public\n",
                    "message": "IExchangeV2.getOrderInfo (IExchangeV2.sol#74-76) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IExchangeV2.sol:\n\t- pragma solidity^0.5.9 (IExchangeV2.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc1155/contracts/test/DummyERC1155Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        shouldRejectTransfer = false;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 145,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TRANSFER_REJECTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TRANSFER_REJECTED\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in DummyERC1155Receiver.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.5', '^0.5.9']\n\t- DummyERC1155Receiver.sol#21 declares pragma solidity^0.5.9\n\t- DummyERC1155Receiver.sol#22 declares pragma experimentalABIEncoderV2\n\t- DummyERC1155Receiver.sol#92 declares pragma solidity^0.5.5\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in DummyERC1155Receiver.sol:\n\t- pragma solidity^0.5.9 (DummyERC1155Receiver.sol#21): it allows old versions\n\t- pragma solidity^0.5.5 (DummyERC1155Receiver.sol#92): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRejectTransferFlag(bool _shouldRejectTransfer) external {\n",
                    "message": "Parameter '_shouldRejectTransfer' of DummyERC1155Receiver.setRejectTransferFlag (DummyERC1155Receiver.sol#193) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public ERC1155_RECEIVED       = 0xf23a6e61;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant public ERC1155_BATCH_RECEIVED = 0xbc197c81;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 144,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (shouldRejectTransfer) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(bytes4);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (bytes4)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (shouldRejectTransfer) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"TRANSFER_REJECTED\");\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc1155/contracts/src/MixinNonFungibleToken.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_10"
            ],
            "vulnerability_findings": [
                {
                    "name": "uninitialized-state",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (uint256 => address) internal nfOwners;\n",
                    "message": "MixinNonFungibleToken.nfOwners (MixinNonFungibleToken.sol#37) is never initialized. It is used in:\n\t- ownerOf (MixinNonFungibleToken.sol#72-74)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in MixinNonFungibleToken.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- MixinNonFungibleToken.sol#21 declares pragma solidity^0.5.9\n\t- MixinNonFungibleToken.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": 42,
                    "vulnerability_code": "    function isNonFungible(uint256 id) public pure returns(bool) {\n\n        return id & TYPE_NF_BIT == TYPE_NF_BIT;\n",
                    "message": "MixinNonFungibleToken.isNonFungible (MixinNonFungibleToken.sol#40-42) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 47,
                    "vulnerability_code": "    function isFungible(uint256 id) public pure returns(bool) {\n\n        return id & TYPE_NF_BIT == 0;\n",
                    "message": "MixinNonFungibleToken.isFungible (MixinNonFungibleToken.sol#45-47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": 52,
                    "vulnerability_code": "    function getNonFungibleIndex(uint256 id) public pure returns(uint256) {\n\n        return id & NF_INDEX_MASK;\n",
                    "message": "MixinNonFungibleToken.getNonFungibleIndex (MixinNonFungibleToken.sol#50-52) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": 57,
                    "vulnerability_code": "    function getNonFungibleBaseType(uint256 id) public pure returns(uint256) {\n\n        return id & TYPE_MASK;\n",
                    "message": "MixinNonFungibleToken.getNonFungibleBaseType (MixinNonFungibleToken.sol#55-57) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 60,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function isNonFungibleBaseType(uint256 id) public pure returns(bool) {\n\n        // A base type has the NF bit but does not have an index.\n\n        return (id & TYPE_NF_BIT == TYPE_NF_BIT) && (id & NF_INDEX_MASK == 0);\n",
                    "message": "MixinNonFungibleToken.isNonFungibleBaseType (MixinNonFungibleToken.sol#60-63) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 69,
                    "vulnerability_code": "    function isNonFungibleItem(uint256 id) public pure returns(bool) {\n\n        // A base type has the NF bit but does has an index.\n\n        return (id & TYPE_NF_BIT == TYPE_NF_BIT) && (id & NF_INDEX_MASK != 0);\n",
                    "message": "MixinNonFungibleToken.isNonFungibleItem (MixinNonFungibleToken.sol#66-69) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 72,
                    "vulnerability_to_line": 74,
                    "vulnerability_code": "    function ownerOf(uint256 id) public view returns (address) {\n\n        return nfOwners[id];\n",
                    "message": "MixinNonFungibleToken.ownerOf (MixinNonFungibleToken.sol#72-74) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in MixinNonFungibleToken.sol:\n\t- pragma solidity^0.5.9 (MixinNonFungibleToken.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc1155/contracts/src/interfaces/IERC1155Receiver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IERC1155Receiver.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IERC1155Receiver.sol#21 declares pragma solidity^0.5.9\n\t- IERC1155Receiver.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC1155Receiver.sol:\n\t- pragma solidity^0.5.9 (IERC1155Receiver.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 61,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function onERC1155BatchReceived(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 64,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 65,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns(bytes4);\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc1155/contracts/src/interfaces/IERC1155.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Different versions of Solidity is used in IERC1155.sol:\n\t- Version used: ['ABIEncoderV2', '^0.5.9']\n\t- IERC1155.sol#21 declares pragma solidity^0.5.9\n\t- IERC1155.sol#22 declares pragma experimentalABIEncoderV2\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": "Detected issues with version pragma in IERC1155.sol:\n\t- pragma solidity^0.5.9 (IERC1155.sol#21): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.9;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 117,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeBatchTransferFrom(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata ids,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256[] calldata values,\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 122,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        bytes calldata data\n",
                    "message": null
                }
            ]
        }
    },
    "protocol-475b608338561a1dce3199bfb9fb59ee9372149b/packages/asset-swapper/contracts/src/TwoHopSampler.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(INVALID_BYTE_OPERATION_ERROR_SELECTOR, errorCode, offset, required);\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 81,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return abi.encodeWithSelector(STANDARD_ERROR_SELECTOR, bytes(message));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            firstHopCalls[i].writeUint256(firstHopCalls[i].length - 32, sellAmount);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            secondHopCalls[j].writeUint256(secondHopCalls[j].length - 32, intermediateAssetAmount);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 624,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            secondHopCalls[j].writeUint256(secondHopCalls[j].length - 32, buyAmount);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            firstHopCalls[i].writeUint256(firstHopCalls[i].length - 32, intermediateAssetAmount);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                uint256 amount = returnData.readUint256(returnData.length - 32);\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 629,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    amount > 0 &&\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 630,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    amount < intermediateAssetAmount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 632,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    intermediateAssetAmount = amount;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    secondHop.sourceIndex = j;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    secondHop.returnData = returnData;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 635,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    amount > 0 &&\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 648,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    amount < sellAmount\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 649,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                ) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    sellAmount = amount;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    firstHop.sourceIndex = i;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    firstHop.returnData = returnData;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant INVALID_BYTE_OPERATION_ERROR_SELECTOR = 0x28006595;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant STANDARD_ERROR_SELECTOR = 0x08c379a0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 j = 0; j != secondHopCalls.length; ++j) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 641,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i = 0; i != firstHopCalls.length; ++i) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 22,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 69,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 114,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6.5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.6;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rrevert(bytes memory errorData) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rawAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contentAddress(bytes memory input) internal pure returns (uint256 memoryAddress) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memCopy(uint256 dest, uint256 source, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sliceDestructive(bytes memory b, uint256 from, uint256 to) internal pure returns (bytes memory result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 321,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function popLastByte(bytes memory b) internal pure returns (bytes1 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readAddress(bytes memory b, uint256 index) internal pure returns (address result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeAddress(bytes memory b, uint256 index, address input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeBytes32(bytes memory b, uint256 index, bytes32 input) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function readBytes4(bytes memory b, uint256 index) internal pure returns (bytes4 result) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function writeLength(bytes memory b, uint256 length) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 615,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        returns (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 581,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(firstHopCalls[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 596,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(secondHopCalls[j]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 625,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(secondHopCalls[j]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (bool didSucceed, bytes memory returnData) = address(this).staticcall(firstHopCalls[i]);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 136,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 375,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 472,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 513,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    }
}