{
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/Migrations.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 14,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        owner = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 15,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": 19,
                    "vulnerability_code": "    function setCompleted(uint completed) public restricted {\n\n        last_completed_migration = completed;\n",
                    "message": "Migrations.setCompleted (Migrations.sol#17-19) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": 24,
                    "vulnerability_code": "    function upgrade(address new_address) public restricted {\n\n        Migrations upgraded = Migrations(new_address);\n\n        upgraded.setCompleted(last_completed_migration);\n",
                    "message": "Migrations.upgrade (Migrations.sol#21-24) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in Migrations.sol:\n\t- pragma solidity^0.5.4 (Migrations.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function upgrade(address new_address) public restricted {\n",
                    "message": "Parameter 'new_address' of Migrations.upgrade (Migrations.sol#21) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint public last_completed_migration;\n",
                    "message": "Variable 'Migrations.last_completed_migration' (Migrations.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/Registry.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        governance = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        registryKeeper = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 51,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        panicButton = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 52,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(governance == msg.sender, \"Not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(registryKeeper == msg.sender, \"Not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(panicButton == msg.sender, \"Not authorized\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_15"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": 58,
                    "vulnerability_code": "    function setGovernance(address _governance) public onlyGovernance {\n\n        governance = _governance;\n\n    }\n\n\n",
                    "message": "Registry.setGovernance (Registry.sol#54-58) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": 62,
                    "vulnerability_code": "    function setRegistryKeeper(address _registryKeeper) public onlyGovernance {\n\n        registryKeeper = _registryKeeper;\n\n    }\n\n\n",
                    "message": "Registry.setRegistryKeeper (Registry.sol#58-62) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": 66,
                    "vulnerability_code": "    function setPanicButton(address _panicButton) public onlyGovernance {\n\n        panicButton = _panicButton;\n\n    }\n\n\n",
                    "message": "Registry.setPanicButton (Registry.sol#62-66) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": 70,
                    "vulnerability_code": "    function setOperatorContractUpgrader(address _serviceContract, address _operatorContractUpgrader) public onlyGovernance {\n\n        operatorContractUpgraders[_serviceContract] = _operatorContractUpgrader;\n\n    }\n\n\n",
                    "message": "Registry.setOperatorContractUpgrader (Registry.sol#66-70) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": 74,
                    "vulnerability_code": "    function approveOperatorContract(address operatorContract) public onlyRegistryKeeper {\n\n        operatorContracts[operatorContract] = 1;\n\n    }\n\n\n",
                    "message": "Registry.approveOperatorContract (Registry.sol#70-74) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 74,
                    "vulnerability_to_line": 78,
                    "vulnerability_code": "    function disableOperatorContract(address operatorContract) public onlyPanicButton {\n\n        operatorContracts[operatorContract] = 2;\n\n    }\n\n\n",
                    "message": "Registry.disableOperatorContract (Registry.sol#74-78) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 78,
                    "vulnerability_to_line": 82,
                    "vulnerability_code": "    function isApprovedOperatorContract(address operatorContract) public view returns (bool) {\n\n        return operatorContracts[operatorContract] == 1;\n\n    }\n\n\n",
                    "message": "Registry.isApprovedOperatorContract (Registry.sol#78-82) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": 85,
                    "vulnerability_code": "    function operatorContractUpgraderFor(address _serviceContract) public view returns (address) {\n\n        return operatorContractUpgraders[_serviceContract];\n\n    }\n",
                    "message": "Registry.operatorContractUpgraderFor (Registry.sol#82-85) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in Registry.sol:\n\t- pragma solidity^0.5.4 (Registry.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setGovernance(address _governance) public onlyGovernance {\n",
                    "message": "Parameter '_governance' of Registry.setGovernance (Registry.sol#54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setRegistryKeeper(address _registryKeeper) public onlyGovernance {\n",
                    "message": "Parameter '_registryKeeper' of Registry.setRegistryKeeper (Registry.sol#58) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 62,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setPanicButton(address _panicButton) public onlyGovernance {\n",
                    "message": "Parameter '_panicButton' of Registry.setPanicButton (Registry.sol#62) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOperatorContractUpgrader(address _serviceContract, address _operatorContractUpgrader) public onlyGovernance {\n",
                    "message": "Parameter '_serviceContract' of Registry.setOperatorContractUpgrader (Registry.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 66,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOperatorContractUpgrader(address _serviceContract, address _operatorContractUpgrader) public onlyGovernance {\n",
                    "message": "Parameter '_operatorContractUpgrader' of Registry.setOperatorContractUpgrader (Registry.sol#66) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 82,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function operatorContractUpgraderFor(address _serviceContract) public view returns (address) {\n",
                    "message": "Parameter '_serviceContract' of Registry.operatorContractUpgraderFor (Registry.sol#82) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/cryptography/AltBn128.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(false, \"Failed to calculate legendre.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isG1PointOnCurve(G1Point(x, y)), \"Malformed bn256.G1 point.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isG2PointOnCurve(G2Point(x, y)), \"Malformed bn256.G2 point.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (m = 0; m < r; m++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_22"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
                    "message": "ModUtils.modExp (AltBn128.sol#12-35) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 357,
                    "vulnerability_code": "    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n\n        bytes32 x;\n\n        bytes32 y;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            x := mload(add(m, 0x20))\n\n            y := mload(add(m, 0x40))\n\n        }\n\n\n\n        return G1Point(uint256(x), uint256(y));\n\n    }\n",
                    "message": "AltBn128.g1Unmarshal (AltBn128.sol#345-357) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 377,
                    "vulnerability_code": "    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n\n        bytes32 xx;\n\n        bytes32 xy;\n\n        bytes32 yx;\n\n        bytes32 yy;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            xx := mload(add(m, 0x20))\n\n            xy := mload(add(m, 0x40))\n\n            yx := mload(add(m, 0x60))\n\n            yy := mload(add(m, 0x80))\n\n        }\n\n\n\n        return G2Point(gfP2(uint256(xx), uint256(xy)), gfP2(uint256(yx),uint256(yy)));\n\n    }\n",
                    "message": "AltBn128.g2Unmarshal (AltBn128.sol#361-377) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 414,
                    "vulnerability_code": "    function g2Decompress(bytes memory m)\n\n        internal\n\n        pure returns(G2Point memory)\n\n    {\n\n        bytes32 x1;\n\n        bytes32 x2;\n\n        uint256 temp;\n\n\n\n        // Extract two bytes32 from bytes array\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            temp := add(m, 32)\n\n            x1 := mload(temp)\n\n            temp := add(m, 64)\n\n            x2 := mload(temp)\n\n        }\n\n\n\n        bytes32 mX = bytes32(0);\n\n        byte leadX = x1[0] & 0x7f;\n\n        uint256 mask = 0xff << 31*8;\n\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\n\n\n\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\n\n        gfP2 memory y = g2YFromX(x);\n\n\n\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n\n            y.x = p - y.x;\n\n            y.y = p - y.y;\n\n        }\n\n\n\n        require(isG2PointOnCurve(G2Point(x, y)), \"Malformed bn256.G2 point.\");\n\n        return G2Point(x, y);\n\n    }\n",
                    "message": "AltBn128.g2Decompress (AltBn128.sol#381-414) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function g1Add(G1Point memory a, G1Point memory b) internal view returns (G1Point memory) {\n\n        uint256[4] memory arg;\n\n        arg[0] = a.x;\n\n        arg[1] = a.y;\n\n        arg[2] = b.x;\n\n        arg[3] = b.y;\n\n        uint256[2] memory c;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x60 is the ECADD precompile address\n\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n\n\n        return G1Point(c[0], c[1]);\n\n    }\n",
                    "message": "AltBn128.g1Add (AltBn128.sol#420-438) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 535,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n\n        uint256[3] memory arg;\n\n        arg[0] = p_1.x;\n\n        arg[1] = p_1.y;\n\n        arg[2] = scalar;\n\n        uint256[2] memory p_2;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x70 is the ECMUL precompile address\n\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return G1Point(p_2[0], p_2[1]);\n\n    }\n",
                    "message": "AltBn128.scalarMultiply (AltBn128.sol#520-535) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": 554,
                    "vulnerability_code": "    function pairing(G1Point memory p1, G2Point memory p2, G1Point memory p3, G2Point memory p4) internal view returns (bool) {\n\n        uint256[12] memory arg = [\n\n            p1.x, p1.y, p2.x.x, p2.x.y, p2.y.x, p2.y.y, p3.x, p3.y, p4.x.x, p4.x.y, p4.y.x, p4.y.y\n\n        ];\n\n        uint[1] memory c;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\n\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return c[0] != 0;\n\n    }\n",
                    "message": "AltBn128.pairing (AltBn128.sol#540-554) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        gfP2 memory a;\n",
                    "message": "a in AltBn128.gfP2Pow (AltBn128.sol#464) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
                    "message": "ModUtils.modExp uses assembly (AltBn128.sol#12-35)\n\t- AltBn128.sol#18-33\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 357,
                    "vulnerability_code": "    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n\n        bytes32 x;\n\n        bytes32 y;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            x := mload(add(m, 0x20))\n\n            y := mload(add(m, 0x40))\n\n        }\n\n\n\n        return G1Point(uint256(x), uint256(y));\n\n    }\n",
                    "message": "AltBn128.g1Unmarshal uses assembly (AltBn128.sol#345-357)\n\t- AltBn128.sol#350-354\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 377,
                    "vulnerability_code": "    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n\n        bytes32 xx;\n\n        bytes32 xy;\n\n        bytes32 yx;\n\n        bytes32 yy;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            xx := mload(add(m, 0x20))\n\n            xy := mload(add(m, 0x40))\n\n            yx := mload(add(m, 0x60))\n\n            yy := mload(add(m, 0x80))\n\n        }\n\n\n\n        return G2Point(gfP2(uint256(xx), uint256(xy)), gfP2(uint256(yx),uint256(yy)));\n\n    }\n",
                    "message": "AltBn128.g2Unmarshal uses assembly (AltBn128.sol#361-377)\n\t- AltBn128.sol#368-374\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 414,
                    "vulnerability_code": "    function g2Decompress(bytes memory m)\n\n        internal\n\n        pure returns(G2Point memory)\n\n    {\n\n        bytes32 x1;\n\n        bytes32 x2;\n\n        uint256 temp;\n\n\n\n        // Extract two bytes32 from bytes array\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            temp := add(m, 32)\n\n            x1 := mload(temp)\n\n            temp := add(m, 64)\n\n            x2 := mload(temp)\n\n        }\n\n\n\n        bytes32 mX = bytes32(0);\n\n        byte leadX = x1[0] & 0x7f;\n\n        uint256 mask = 0xff << 31*8;\n\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\n\n\n\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\n\n        gfP2 memory y = g2YFromX(x);\n\n\n\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n\n            y.x = p - y.x;\n\n            y.y = p - y.y;\n\n        }\n\n\n\n        require(isG2PointOnCurve(G2Point(x, y)), \"Malformed bn256.G2 point.\");\n\n        return G2Point(x, y);\n\n    }\n",
                    "message": "AltBn128.g2Decompress uses assembly (AltBn128.sol#381-414)\n\t- AltBn128.sol#391-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function g1Add(G1Point memory a, G1Point memory b) internal view returns (G1Point memory) {\n\n        uint256[4] memory arg;\n\n        arg[0] = a.x;\n\n        arg[1] = a.y;\n\n        arg[2] = b.x;\n\n        arg[3] = b.y;\n\n        uint256[2] memory c;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x60 is the ECADD precompile address\n\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n\n\n        return G1Point(c[0], c[1]);\n\n    }\n",
                    "message": "AltBn128.g1Add uses assembly (AltBn128.sol#420-438)\n\t- AltBn128.sol#429-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 535,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n\n        uint256[3] memory arg;\n\n        arg[0] = p_1.x;\n\n        arg[1] = p_1.y;\n\n        arg[2] = scalar;\n\n        uint256[2] memory p_2;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x70 is the ECMUL precompile address\n\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return G1Point(p_2[0], p_2[1]);\n\n    }\n",
                    "message": "AltBn128.scalarMultiply uses assembly (AltBn128.sol#520-535)\n\t- AltBn128.sol#527-533\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": 554,
                    "vulnerability_code": "    function pairing(G1Point memory p1, G2Point memory p2, G1Point memory p3, G2Point memory p4) internal view returns (bool) {\n\n        uint256[12] memory arg = [\n\n            p1.x, p1.y, p2.x.x, p2.x.y, p2.y.x, p2.y.y, p3.x, p3.y, p4.x.x, p4.x.y, p4.y.x, p4.y.y\n\n        ];\n\n        uint[1] memory c;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\n\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return c[0] != 0;\n\n    }\n",
                    "message": "AltBn128.pairing uses assembly (AltBn128.sol#540-554)\n\t- AltBn128.sol#546-552\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in AltBn128.sol:\n\t- pragma solidity^0.5.4 (AltBn128.sol#3): it allows old versions\n\t- pragma solidity^0.5.4 (AltBn128.sol#131): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    struct gfP2 {\n\n        uint256 x;\n\n        uint256 y;\n\n    }\n",
                    "message": "Struct 'AltBn128.gfP2' (AltBn128.sol#151-155) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g2YFromX(gfP2 memory _x)\n",
                    "message": "Parameter '_x' of AltBn128.g2YFromX (AltBn128.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function gfP2Pow(gfP2 memory _a, uint256 _exp) internal pure returns(gfP2 memory result) {\n",
                    "message": "Parameter '_a' of AltBn128.gfP2Pow (AltBn128.sol#462) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function gfP2Pow(gfP2 memory _a, uint256 _exp) internal pure returns(gfP2 memory result) {\n",
                    "message": "Parameter '_exp' of AltBn128.gfP2Pow (AltBn128.sol#462) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n",
                    "message": "Parameter 'p_1' of AltBn128.scalarMultiply (AltBn128.sol#520) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n",
                    "message": "Constant 'AltBn128.p' (AltBn128.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return bytes32(value)[31] & 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        byte leadX = m[0] & 0x7f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (parity(y) != (m[0] & 0x80) >> 7) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        byte leadX = x1[0] & 0x7f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (parity(exp) == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (true) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (true) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (legendre(n, p) != -1) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (!g2X2y(x, y)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g2Decompress(bytes memory m)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g1Add(G1Point memory a, G1Point memory b) internal view returns (G1Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pairing(G1Point memory p1, G2Point memory p2, G1Point memory p3, G2Point memory p4) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/cryptography/BLS.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(false, \"Failed to calculate legendre.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isG1PointOnCurve(G1Point(x, y)), \"Malformed bn256.G1 point.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isG2PointOnCurve(G2Point(x, y)), \"Malformed bn256.G2 point.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (m = 0; m < r; m++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_23"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
                    "message": "ModUtils.modExp (BLS.sol#12-35) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 357,
                    "vulnerability_code": "    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n\n        bytes32 x;\n\n        bytes32 y;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            x := mload(add(m, 0x20))\n\n            y := mload(add(m, 0x40))\n\n        }\n\n\n\n        return G1Point(uint256(x), uint256(y));\n\n    }\n",
                    "message": "AltBn128.g1Unmarshal (BLS.sol#345-357) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 377,
                    "vulnerability_code": "    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n\n        bytes32 xx;\n\n        bytes32 xy;\n\n        bytes32 yx;\n\n        bytes32 yy;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            xx := mload(add(m, 0x20))\n\n            xy := mload(add(m, 0x40))\n\n            yx := mload(add(m, 0x60))\n\n            yy := mload(add(m, 0x80))\n\n        }\n\n\n\n        return G2Point(gfP2(uint256(xx), uint256(xy)), gfP2(uint256(yx),uint256(yy)));\n\n    }\n",
                    "message": "AltBn128.g2Unmarshal (BLS.sol#361-377) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 414,
                    "vulnerability_code": "    function g2Decompress(bytes memory m)\n\n        internal\n\n        pure returns(G2Point memory)\n\n    {\n\n        bytes32 x1;\n\n        bytes32 x2;\n\n        uint256 temp;\n\n\n\n        // Extract two bytes32 from bytes array\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            temp := add(m, 32)\n\n            x1 := mload(temp)\n\n            temp := add(m, 64)\n\n            x2 := mload(temp)\n\n        }\n\n\n\n        bytes32 mX = bytes32(0);\n\n        byte leadX = x1[0] & 0x7f;\n\n        uint256 mask = 0xff << 31*8;\n\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\n\n\n\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\n\n        gfP2 memory y = g2YFromX(x);\n\n\n\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n\n            y.x = p - y.x;\n\n            y.y = p - y.y;\n\n        }\n\n\n\n        require(isG2PointOnCurve(G2Point(x, y)), \"Malformed bn256.G2 point.\");\n\n        return G2Point(x, y);\n\n    }\n",
                    "message": "AltBn128.g2Decompress (BLS.sol#381-414) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function g1Add(G1Point memory a, G1Point memory b) internal view returns (G1Point memory) {\n\n        uint256[4] memory arg;\n\n        arg[0] = a.x;\n\n        arg[1] = a.y;\n\n        arg[2] = b.x;\n\n        arg[3] = b.y;\n\n        uint256[2] memory c;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x60 is the ECADD precompile address\n\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n\n\n        return G1Point(c[0], c[1]);\n\n    }\n",
                    "message": "AltBn128.g1Add (BLS.sol#420-438) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 535,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n\n        uint256[3] memory arg;\n\n        arg[0] = p_1.x;\n\n        arg[1] = p_1.y;\n\n        arg[2] = scalar;\n\n        uint256[2] memory p_2;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x70 is the ECMUL precompile address\n\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return G1Point(p_2[0], p_2[1]);\n\n    }\n",
                    "message": "AltBn128.scalarMultiply (BLS.sol#520-535) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": 554,
                    "vulnerability_code": "    function pairing(G1Point memory p1, G2Point memory p2, G1Point memory p3, G2Point memory p4) internal view returns (bool) {\n\n        uint256[12] memory arg = [\n\n            p1.x, p1.y, p2.x.x, p2.x.y, p2.y.x, p2.y.y, p3.x, p3.y, p4.x.x, p4.x.y, p4.y.x, p4.y.y\n\n        ];\n\n        uint[1] memory c;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\n\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return c[0] != 0;\n\n    }\n",
                    "message": "AltBn128.pairing (BLS.sol#540-554) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        gfP2 memory a;\n",
                    "message": "a in AltBn128.gfP2Pow (BLS.sol#464) is a local variable never initialiazed\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
                    "message": "ModUtils.modExp uses assembly (BLS.sol#12-35)\n\t- BLS.sol#18-33\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": 357,
                    "vulnerability_code": "    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n\n        bytes32 x;\n\n        bytes32 y;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            x := mload(add(m, 0x20))\n\n            y := mload(add(m, 0x40))\n\n        }\n\n\n\n        return G1Point(uint256(x), uint256(y));\n\n    }\n",
                    "message": "AltBn128.g1Unmarshal uses assembly (BLS.sol#345-357)\n\t- BLS.sol#350-354\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": 377,
                    "vulnerability_code": "    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n\n        bytes32 xx;\n\n        bytes32 xy;\n\n        bytes32 yx;\n\n        bytes32 yy;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            xx := mload(add(m, 0x20))\n\n            xy := mload(add(m, 0x40))\n\n            yx := mload(add(m, 0x60))\n\n            yy := mload(add(m, 0x80))\n\n        }\n\n\n\n        return G2Point(gfP2(uint256(xx), uint256(xy)), gfP2(uint256(yx),uint256(yy)));\n\n    }\n",
                    "message": "AltBn128.g2Unmarshal uses assembly (BLS.sol#361-377)\n\t- BLS.sol#368-374\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": 414,
                    "vulnerability_code": "    function g2Decompress(bytes memory m)\n\n        internal\n\n        pure returns(G2Point memory)\n\n    {\n\n        bytes32 x1;\n\n        bytes32 x2;\n\n        uint256 temp;\n\n\n\n        // Extract two bytes32 from bytes array\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            temp := add(m, 32)\n\n            x1 := mload(temp)\n\n            temp := add(m, 64)\n\n            x2 := mload(temp)\n\n        }\n\n\n\n        bytes32 mX = bytes32(0);\n\n        byte leadX = x1[0] & 0x7f;\n\n        uint256 mask = 0xff << 31*8;\n\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\n\n\n\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\n\n        gfP2 memory y = g2YFromX(x);\n\n\n\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n\n            y.x = p - y.x;\n\n            y.y = p - y.y;\n\n        }\n\n\n\n        require(isG2PointOnCurve(G2Point(x, y)), \"Malformed bn256.G2 point.\");\n\n        return G2Point(x, y);\n\n    }\n",
                    "message": "AltBn128.g2Decompress uses assembly (BLS.sol#381-414)\n\t- BLS.sol#391-397\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": 438,
                    "vulnerability_code": "    function g1Add(G1Point memory a, G1Point memory b) internal view returns (G1Point memory) {\n\n        uint256[4] memory arg;\n\n        arg[0] = a.x;\n\n        arg[1] = a.y;\n\n        arg[2] = b.x;\n\n        arg[3] = b.y;\n\n        uint256[2] memory c;\n\n\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x60 is the ECADD precompile address\n\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n\n\n        return G1Point(c[0], c[1]);\n\n    }\n",
                    "message": "AltBn128.g1Add uses assembly (BLS.sol#420-438)\n\t- BLS.sol#429-435\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 535,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n\n        uint256[3] memory arg;\n\n        arg[0] = p_1.x;\n\n        arg[1] = p_1.y;\n\n        arg[2] = scalar;\n\n        uint256[2] memory p_2;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // 0x70 is the ECMUL precompile address\n\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return G1Point(p_2[0], p_2[1]);\n\n    }\n",
                    "message": "AltBn128.scalarMultiply uses assembly (BLS.sol#520-535)\n\t- BLS.sol#527-533\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": 554,
                    "vulnerability_code": "    function pairing(G1Point memory p1, G2Point memory p2, G1Point memory p3, G2Point memory p4) internal view returns (bool) {\n\n        uint256[12] memory arg = [\n\n            p1.x, p1.y, p2.x.x, p2.x.y, p2.y.x, p2.y.y, p3.x, p3.y, p4.x.x, p4.x.y, p4.y.x, p4.y.y\n\n        ];\n\n        uint[1] memory c;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\n\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return c[0] != 0;\n\n    }\n",
                    "message": "AltBn128.pairing uses assembly (BLS.sol#540-554)\n\t- BLS.sol#546-552\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": 591,
                    "vulnerability_code": "    function verify(\n\n        bytes memory publicKey,\n\n        bytes memory message,\n\n        bytes memory signature\n\n    ) public view returns (bool) {\n\n\n\n        AltBn128.G1Point memory _signature = AltBn128.g1Unmarshal(signature);\n\n\n\n        return AltBn128.pairing(\n\n            AltBn128.G1Point(_signature.x, AltBn128.getP() - _signature.y),\n\n            AltBn128.g2(),\n\n            AltBn128.g1Unmarshal(message),\n\n            AltBn128.g2Unmarshal(publicKey)\n\n        );\n\n    }\n",
                    "message": "BLS.verify (BLS.sol#576-591) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in BLS.sol:\n\t- pragma solidity^0.5.4 (BLS.sol#3): it allows old versions\n\t- pragma solidity^0.5.4 (BLS.sol#131): it allows old versions\n\t- pragma solidity^0.5.4 (BLS.sol#559-560): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 151,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    struct gfP2 {\n\n        uint256 x;\n\n        uint256 y;\n\n    }\n",
                    "message": "Struct 'AltBn128.gfP2' (BLS.sol#151-155) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g2YFromX(gfP2 memory _x)\n",
                    "message": "Parameter '_x' of AltBn128.g2YFromX (BLS.sol#235) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function gfP2Pow(gfP2 memory _a, uint256 _exp) internal pure returns(gfP2 memory result) {\n",
                    "message": "Parameter '_a' of AltBn128.gfP2Pow (BLS.sol#462) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function gfP2Pow(gfP2 memory _a, uint256 _exp) internal pure returns(gfP2 memory result) {\n",
                    "message": "Parameter '_exp' of AltBn128.gfP2Pow (BLS.sol#462) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n",
                    "message": "Parameter 'p_1' of AltBn128.scalarMultiply (BLS.sol#520) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n",
                    "message": "Constant 'AltBn128.p' (BLS.sol#164) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        return bytes32(value)[31] & 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        byte leadX = m[0] & 0x7f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (parity(y) != (m[0] & 0x80) >> 7) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 399,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        byte leadX = x1[0] & 0x7f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint256 mask = 0xff << 31*8;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (parity(exp) == 0x01) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (true) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (true) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (legendre(n, p) != -1) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (!g2X2y(x, y)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g2Decompress(bytes memory m)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function g1Add(G1Point memory a, G1Point memory b) internal view returns (G1Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function scalarMultiply(G1Point memory p_1, uint256 scalar) internal view returns (G1Point memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 540,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pairing(G1Point memory p1, G2Point memory p2, G1Point memory p3, G2Point memory p4) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 391,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 527,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/utils/ThrowProxy.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _target) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        target = _target;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "locked-ether",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 18,
                    "vulnerability_code": "    function() external payable {\n\n        data = msg.data;\n",
                    "message": "Contract locking ether found in ThrowProxy.sol:\n\tContract ThrowProxy has payable functions:\n\t - fallback (ThrowProxy.sol#16-18)\n\tBut does not have a function to withdraw the ether\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 25,
                    "vulnerability_code": "    function execute() public returns (bool) {\n\n        // The contract is used only for tests, disabling ethlint warning.\n\n        // solium-disable-next-line\n\n        (bool result, ) = target.call(data);\n\n        return result;\n",
                    "message": "ThrowProxy.execute (ThrowProxy.sol#20-25) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in ThrowProxy.sol:\n\t- pragma solidity^0.5.4 (ThrowProxy.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": 25,
                    "vulnerability_code": "    function execute() public returns (bool) {\n\n        // The contract is used only for tests, disabling ethlint warning.\n\n        // solium-disable-next-line\n\n        (bool result, ) = target.call(data);\n\n        return result;\n",
                    "message": "Low level call in ThrowProxy.execute (ThrowProxy.sol#20-25):\n\t-(result) = target.call(data) ThrowProxy.sol#23\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 11,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _target) public {\n",
                    "message": "Parameter '_target' of ThrowProxy. (ThrowProxy.sol#11) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract ThrowProxy {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 23,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool result, ) = target.call(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes data;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/utils/AddressArrayUtils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                i--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in AddressArrayUtils.sol:\n\t- pragma solidity^0.5.4 (AddressArrayUtils.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function contains(address[] memory self, address _address)\n",
                    "message": "Parameter '_address' of AddressArrayUtils.contains (AddressArrayUtils.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAddress(address[] storage self, address _addressToRemove)\n",
                    "message": "Parameter '_addressToRemove' of AddressArrayUtils.removeAddress (AddressArrayUtils.sol#21) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 13,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/utils/ModUtils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(false, \"Failed to calculate legendre.\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 89,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (m = 0; m < r; m++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_3"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
                    "message": "ModUtils.modExp (ModUtils.sol#12-35) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": 35,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n\n        internal\n\n        view returns(uint256)\n\n    {\n\n        uint256[1] memory output;\n\n        /* solium-disable-next-line */\n\n        assembly {\n\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n\n            let args := mload(0x40)\n\n            mstore(args, 0x20)\n\n            mstore(add(args, 0x20), 0x20)\n\n            mstore(add(args, 0x40), 0x20)\n\n            mstore(add(args, 0x60), base)\n\n            mstore(add(args, 0x80), exponent)\n\n            mstore(add(args, 0xa0), p)\n\n\n\n            // 0x05 is the modular exponent contract address\n\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n\n                revert(0, 0)\n\n            }\n\n        }\n\n        return output[0];\n",
                    "message": "ModUtils.modExp uses assembly (ModUtils.sol#12-35)\n\t- ModUtils.sol#18-33\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in ModUtils.sol:\n\t- pragma solidity^0.5.4 (ModUtils.sol#3): it allows old versions\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (true) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (legendre(n, p) != -1) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function modExp(uint256 base, uint256 exponent, uint256 p)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/utils/UintArrayUtils.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 20,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                i--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in UintArrayUtils.sol:\n\t- pragma solidity^0.5.4 (UintArrayUtils.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeValue(uint256[] storage self, uint256 _value) \n",
                    "message": "Parameter '_value' of UintArrayUtils.removeValue (UintArrayUtils.sol#8) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 19,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                self.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (uint j = i; j < self.length-1; j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < self.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                }
            ]
        }
    },
    "keep-core-b76b418f04bc94030d10aff18220d8e560a2ab09/contracts/solidity/contracts/examples/CallbackContract.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 18,
                    "vulnerability_to_line": 22,
                    "vulnerability_code": "    function callback(uint256 requestResponse)\n\n        public\n\n    {\n\n        _lastEntry = requestResponse;\n",
                    "message": "CallbackContract.callback (CallbackContract.sol#18-22) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 27,
                    "vulnerability_to_line": 30,
                    "vulnerability_code": "    function lastEntry() public view returns (uint256)\n\n    {\n\n        return _lastEntry;\n",
                    "message": "CallbackContract.lastEntry (CallbackContract.sol#27-30) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": "Detected issues with version pragma in CallbackContract.sol:\n\t- pragma solidity^0.5.4 (CallbackContract.sol#3): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _lastEntry;\n",
                    "message": "Variable 'CallbackContract._lastEntry' (CallbackContract.sol#12) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.5.4;\n",
                    "message": null
                }
            ]
        }
    }
}