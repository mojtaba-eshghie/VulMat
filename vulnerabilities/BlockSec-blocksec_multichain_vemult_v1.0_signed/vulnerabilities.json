{
    "veMULTI-bac804399d1ea280e5bd8cdc9488b6fa6a0a7fcc/contracts/VEReward.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rewards.length; i++) {\n",
                    "message": "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Caching the array length outside a loop saves reading it on each \u2502 Scan Summary \u2502 iteration, as long as the \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 93,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address _ve_,\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 94,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address rewardToken_\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        admin = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ve = _ve_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        rewardToken = rewardToken_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // add init point\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        addCheckpoint();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (point_history[_mid].ts <= _time) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            epoch = epochInfo[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (uint reward_i, bool finished) = _pendingRewardSingle(tokenId, userLastClaimTime[tokenId][i], epochInfo[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            (uint reward_i, bool finished) = _pendingRewardSingle(tokenId, userLastClaimTime[tokenId][i], epochInfo[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 306,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                userLastClaimTime[tokenId][i] = block.timestamp;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (epochInfo[_mid].startTime <= _time) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 448,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (block.timestamp < epochInfo[i].startTime) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 125,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 128; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numberOfEpoch; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < tokenIds.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < intervals.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = startEpoch; i <= endEpoch; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 128; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = start; i <= end; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rewards.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < intv+1; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeERC20: low-level call failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(endEpoch < epochInfo.length, \"claim out of range\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < numberOfEpoch; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < tokenIds.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < intervals.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = startEpoch; i <= endEpoch; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = start; i <= end; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rewards.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    intv++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < intv+1; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < tokenIds.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < intervals.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rewards.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < tokenIds.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 280,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < intervals.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < rewards.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addEpoch(uint startTime, uint endTime, uint totalReward) external onlyAdmin returns(uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addEpochBatch(uint startTime, uint endTime, uint epochLength, uint totalReward) external onlyAdmin returns(uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 203,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addEpoch(uint startTime, uint endTime, uint totalReward) internal returns(uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _pendingRewardSingle(uint tokenId, uint lastClaimTime, EpochInfo memory epoch) internal view returns (uint, bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getEpochInfo(uint epochId) public view returns (uint, uint, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function pendingRewardSingle(uint tokenId, uint epochId) public view returns (uint reward, bool finished) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 25,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimRewardMany(uint[] calldata tokenIds, Interval[][] calldata intervals) public returns (uint[] memory rewards) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimRewardMany(uint[] calldata tokenIds, Interval[][] calldata intervals) public returns (uint[] memory rewards) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 279,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claimReward(uint tokenId, Interval[] calldata intervals) public returns (uint reward) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor (\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint immutable RewardMultiplier = 10000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint immutable BlockMultiplier = 1000000000000000000;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 349,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant MaxQueryLength = 50;\n",
                    "message": null
                }
            ]
        }
    },
    "veMULTI-bac804399d1ea280e5bd8cdc9488b6fa6a0a7fcc/contracts/ve.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 430,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        address token_addr\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 431,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 432,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        token = token_addr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        voter = msg.sender;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        point_history[0].blk = block.number;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        point_history[0].ts = block.timestamp;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 436,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 437,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 836,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    d_slope = slope_changes[t_i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 856,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    point_history[_epoch] = last_point;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (point_history[_mid].blk <= _block) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (user_point_history[_tokenId][_mid].blk <= _block) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                d_slope = slope_changes[t_i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < 255; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1120,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 128; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 128; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < 255; ++i) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 691,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    revert('ERC721: transfer to non ERC721Receiver implementer');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.amount > 0, 'No existing lock found');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1025,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.amount > 0, 'No existing lock found');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.end > block.timestamp, 'Lock expired');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.amount > 0, 'Nothing is locked');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unlock_time > _locked.end, 'Can only increase lock duration');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1084,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1157,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(idToOwner[_tokenId] != address(0), \"Query for nonexistent token\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1335,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1084,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                u_old.slope = old_locked.amount / iMAXTIME;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 790,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 791,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                u_new.slope = new_locked.amount / iMAXTIME;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 793,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 794,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 943,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_value != 0 && deposit_type != DepositType.MERGE_TYPE) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assert(IERC20(token).transferFrom(from, address(this), _value));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            digits++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 691,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    revert('ERC721: transfer to non ERC721Receiver implementer');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1012,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1024,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": false,
            "errors": [
                "EXIT_CODE_255",
                "error parsing results: file could not be opened successfully:\n- method gz: ReadError('empty file')\n- method bz2: ReadError('not a bzip2 file')\n- method xz: ReadError('not an lzma file')\n- method tar: ReadError('empty file')",
                "exception (AssertionError)"
            ],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        idToOwner[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 604,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            idToApprovals[_tokenId] = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1340,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        approve(address(0), _tokenId);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DIV_MUL",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint encodedLen = 4 * ((len + 2) / 3);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DIV_MUL",
                    "vulnerability_from_line": 827,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            uint t_i = (last_checkpoint / WEEK) * WEEK;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DIV_MUL",
                    "vulnerability_from_line": 1021,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DIV_MUL",
                    "vulnerability_from_line": 1070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK; // Locktime is rounded down to weeks\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DIV_MUL",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint t_i = (last_point.ts / WEEK) * WEEK;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXACT_TIME",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (t_i == block.timestamp) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 951,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setVoter(address _voter) external {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 690,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (reason.length == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encode(bytes memory data) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 653,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 693,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address immutable public token;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address immutable public token;\n",
                    "message": null
                }
            ]
        }
    }
}