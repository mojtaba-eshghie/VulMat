{
    "wHakka.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-abi-encodecall-instead-of-encodewithselector",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": "To guarantee arguments type safety it is recommended to use `abi.encodeCall` instead of `abi.encodeWithSelector`."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract wHakka is Ownable, ERC20Mintable{\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor () internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _msgSender();\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit OwnershipTransferred(address(0), _owner);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 497,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        stakingRateStored = 1e18;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        lastUpdateTimestamp = block.timestamp;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor() public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        symbol = \"wHAKKA\";\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        name = \"Wrapped Hakka\";\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        decimals = 18;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 546,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _balances[address(this)] = uint256(-1);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _balances[address(0)] = uint256(-1);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 17,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 187,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isOwner(), \"Ownable: caller is not the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"SafeERC20: low-level call failed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(wAmount > 0, \"invalid lockup\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 582,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(block.timestamp >= v.unlockTime, \"locked\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(wAmount <= v.wAmount, \"exceed locked amount\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        vaultCount[to]++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 71,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 380,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((value == 0) || (token.allowance(address(this), spender) == 0),\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            \"SafeERC20: approve from non-zero to non-zero allowance\"\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        );\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_43"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": 324,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Address.isContract (wHakka.sol#311-324) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 576,
                    "vulnerability_code": "    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n\n        vault storage v = vaults[to][vaultCount[to]];\n\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n\n        require(wAmount > 0, \"invalid lockup\");\n\n\n\n        v.hakkaAmount = amount;\n\n        v.wAmount = wAmount;\n\n        v.unlockTime = block.timestamp.add(time);\n\n        \n\n        stakedHakka[to] = stakedHakka[to].add(amount);\n\n        votingPower[to] = votingPower[to].add(wAmount);\n\n        vaultCount[to]++;\n\n\n\n        _mint(to, wAmount);\n\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n",
                    "message": "Reentrancy in wHakka.stake (wHakka.sol#559-576):\n\tExternal calls:\n\t- wAmount = getStakingRate(time).mul(amount).div(1e18) (wHakka.sol#561)\n\tState variables written after the call(s):\n\t- vaultCount (wHakka.sol#570)\n\t- vaults (wHakka.sol#564)\n\t- vaults (wHakka.sol#565)\n\t- vaults (wHakka.sol#566)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 576,
                    "vulnerability_code": "    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n\n        vault storage v = vaults[to][vaultCount[to]];\n\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n\n        require(wAmount > 0, \"invalid lockup\");\n\n\n\n        v.hakkaAmount = amount;\n\n        v.wAmount = wAmount;\n\n        v.unlockTime = block.timestamp.add(time);\n\n        \n\n        stakedHakka[to] = stakedHakka[to].add(amount);\n\n        votingPower[to] = votingPower[to].add(wAmount);\n\n        vaultCount[to]++;\n\n\n\n        _mint(to, wAmount);\n\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n",
                    "message": "Reentrancy in wHakka.stake (wHakka.sol#559-576):\n\tExternal calls:\n\t- wAmount = getStakingRate(time).mul(amount).div(1e18) (wHakka.sol#561)\n\tState variables written after the call(s):\n\t- _balances (wHakka.sol#572)\n\t- _totalSupply (wHakka.sol#572)\n\t- stakedHakka (wHakka.sol#568)\n\t- votingPower (wHakka.sol#569)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 508,
                    "vulnerability_to_line": 517,
                    "vulnerability_code": "    function stakingRateMax() public returns (uint256 rate) {\n\n        uint256 timeElapsed = block.timestamp.sub(lastUpdateTimestamp);\n\n        // SWC-Block values as a proxy for time: L509\n\n        if(timeElapsed > 0) {\n\n            lastUpdateTimestamp = block.timestamp;\n\n            rate = timeElapsed.mul(ratePerSecond).add(1e18).mul(stakingRateStored).div(1e18);\n\n            stakingRateStored = rate;\n\n        }\n\n        else rate = stakingRateStored;\n",
                    "message": "stakingRateModel.stakingRateMax (wHakka.sol#508-517) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- timeElapsed > 0 (wHakka.sol#511-516)\n"
                },
                {
                    "name": "timestamp",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": 596,
                    "vulnerability_code": "    function unstake(address to, uint256 index, uint256 wAmount) public returns (uint256 amount) {\n\n        vault storage v = vaults[msg.sender][index];\n\n        // SWC-Block values as a proxy for time: L580\n\n        require(block.timestamp >= v.unlockTime, \"locked\");\n\n        require(wAmount <= v.wAmount, \"exceed locked amount\");\n\n        amount = wAmount.mul(v.hakkaAmount).div(v.wAmount);\n\n\n\n        v.hakkaAmount = v.hakkaAmount.sub(amount);\n\n        v.wAmount = v.wAmount.sub(wAmount);\n\n\n\n        stakedHakka[msg.sender] = stakedHakka[msg.sender].sub(amount);\n\n        votingPower[msg.sender] = votingPower[msg.sender].sub(wAmount);\n\n\n\n        _burn(msg.sender, wAmount);\n\n        Hakka.safeTransfer(to, amount);\n\n        \n\n        emit Unstake(msg.sender, to, amount, wAmount);\n",
                    "message": "wHakka.unstake (wHakka.sol#579-596) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- require(bool,string)(block.timestamp >= v.unlockTime,locked) (wHakka.sol#582)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": 324,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
                    "message": "Address.isContract uses assembly (wHakka.sol#311-324)\n\t- wHakka.sol#322\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": 181,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (wHakka.sol#179-181) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": 208,
                    "vulnerability_code": "    function renounceOwnership() public onlyOwner {\n\n        emit OwnershipTransferred(_owner, address(0));\n\n        _owner = address(0);\n",
                    "message": "Ownable.renounceOwnership (wHakka.sol#205-208) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": 216,
                    "vulnerability_code": "    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n",
                    "message": "Ownable.transferOwnership (wHakka.sol#214-216) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
                    "message": "IERC20.totalSupply (wHakka.sol#232) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 435,
                    "vulnerability_to_line": 437,
                    "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
                    "message": "ERC20.totalSupply (wHakka.sol#435-437) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 439,
                    "vulnerability_to_line": 441,
                    "vulnerability_code": "    function balanceOf(address owner) public view returns (uint256) {\n\n        return _balances[owner];\n",
                    "message": "ERC20.balanceOf (wHakka.sol#439-441) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
                    "message": "IERC20.balanceOf (wHakka.sol#237) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transfer (wHakka.sol#246) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 447,
                    "vulnerability_to_line": 450,
                    "vulnerability_code": "    function transfer(address to, uint256 value) public returns (bool) {\n\n        _transfer(msg.sender, to, value);\n\n        return true;\n",
                    "message": "ERC20.transfer (wHakka.sol#447-450) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
                    "message": "IERC20.allowance (wHakka.sol#255) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowed[owner][spender];\n",
                    "message": "ERC20.allowance (wHakka.sol#443-445) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 271,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.approve (wHakka.sol#271) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": 456,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool) {\n\n        _allowed[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n",
                    "message": "ERC20.approve (wHakka.sol#452-456) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n",
                    "message": "IERC20.transferFrom (wHakka.sol#282) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 458,
                    "vulnerability_to_line": 462,
                    "vulnerability_code": "    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        _transfer(from, to, value);\n\n        return true;\n",
                    "message": "ERC20.transferFrom (wHakka.sol#458-462) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 576,
                    "vulnerability_code": "    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n\n        vault storage v = vaults[to][vaultCount[to]];\n\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n\n        require(wAmount > 0, \"invalid lockup\");\n\n\n\n        v.hakkaAmount = amount;\n\n        v.wAmount = wAmount;\n\n        v.unlockTime = block.timestamp.add(time);\n\n        \n\n        stakedHakka[to] = stakedHakka[to].add(amount);\n\n        votingPower[to] = votingPower[to].add(wAmount);\n\n        vaultCount[to]++;\n\n\n\n        _mint(to, wAmount);\n\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n",
                    "message": "wHakka.stake (wHakka.sol#559-576) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": 596,
                    "vulnerability_code": "    function unstake(address to, uint256 index, uint256 wAmount) public returns (uint256 amount) {\n\n        vault storage v = vaults[msg.sender][index];\n\n        // SWC-Block values as a proxy for time: L580\n\n        require(block.timestamp >= v.unlockTime, \"locked\");\n\n        require(wAmount <= v.wAmount, \"exceed locked amount\");\n\n        amount = wAmount.mul(v.hakkaAmount).div(v.wAmount);\n\n\n\n        v.hakkaAmount = v.hakkaAmount.sub(amount);\n\n        v.wAmount = v.wAmount.sub(wAmount);\n\n\n\n        stakedHakka[msg.sender] = stakedHakka[msg.sender].sub(amount);\n\n        votingPower[msg.sender] = votingPower[msg.sender].sub(wAmount);\n\n\n\n        _burn(msg.sender, wAmount);\n\n        Hakka.safeTransfer(to, amount);\n\n        \n\n        emit Unstake(msg.sender, to, amount, wAmount);\n",
                    "message": "wHakka.unstake (wHakka.sol#579-596) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n\n        require(_TokenAddress != Hakka);\n\n        _TokenAddress.safeTransfer(msg.sender, _amount);\n",
                    "message": "wHakka.inCaseTokenGetsStuckPartial (wHakka.sol#598-601) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity 0.5.17;\n",
                    "message": "Detected issues with version pragma in wHakka.sol:\n\t- pragma solidity0.5.17 (wHakka.sol#3): it allows old versions\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": 360,
                    "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\n\n        // solhint-disable-next-line avoid-call-value\n\n        (bool success, ) = recipient.call.value(amount)(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
                    "message": "Low level call in Address.sendValue (wHakka.sol#354-360):\n\t-(success) = recipient.call.value(amount)() wHakka.sol#358\n"
                },
                {
                    "name": "low-level-calls",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": 421,
                    "vulnerability_code": "    function callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\n        // we're implementing it ourselves.\n\n\n\n        // A Solidity high level call has three parts:\n\n        //  1. The target address is checked to verify it contains contract code\n\n        //  2. The call itself is made, and success asserted\n\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line max-line-length\n\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            // solhint-disable-next-line max-line-length\n\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\n        }\n",
                    "message": "Low level call in SafeERC20.callOptionalReturn (wHakka.sol#402-421):\n\t-(success,returndata) = address(token).call(data) wHakka.sol#414\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 153,
                    "vulnerability_to_line": 155,
                    "vulnerability_code": "    function _msgSender() internal view returns (address payable) {\n\n        return msg.sender;\n",
                    "message": "Function 'Context._msgSender' (wHakka.sol#153-155) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 157,
                    "vulnerability_to_line": 160,
                    "vulnerability_code": "    function _msgData() internal view returns (bytes memory) {\n\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\n        return msg.data;\n",
                    "message": "Function 'Context._msgData' (wHakka.sol#157-160) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": 225,
                    "vulnerability_code": "    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n",
                    "message": "Function 'Ownable._transferOwnership' (wHakka.sol#221-225) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 469,
                    "vulnerability_code": "    function _transfer(address from, address to, uint256 value) internal {\n\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        emit Transfer(from, to, value);\n",
                    "message": "Function 'ERC20._transfer' (wHakka.sol#464-469) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => uint256) internal _balances;\n",
                    "message": "Variable 'ERC20._balances' (wHakka.sol#427) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => mapping (address => uint256)) internal _allowed;\n",
                    "message": "Variable 'ERC20._allowed' (wHakka.sol#428) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 433,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 internal _totalSupply;\n",
                    "message": "Variable 'ERC20._totalSupply' (wHakka.sol#433) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 481,
                    "vulnerability_code": "    function _mint(address to, uint256 amount) internal {\n\n        _balances[to] = _balances[to].add(amount);\n\n        _totalSupply = _totalSupply.add(amount);\n\n        emit Transfer(address(0), to, amount);\n",
                    "message": "Function 'ERC20Mintable._mint' (wHakka.sol#477-481) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 483,
                    "vulnerability_to_line": 487,
                    "vulnerability_code": "    function _burn(address from, uint256 amount) internal {\n\n        _balances[from] = _balances[from].sub(amount);\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Transfer(from, address(0), amount);\n",
                    "message": "Function 'ERC20Mintable._burn' (wHakka.sol#483-487) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 490,
                    "vulnerability_to_line": 519,
                    "vulnerability_code": "contract stakingRateModel {\n\n    using SafeMath for *;\n\n\n\n    uint256 lastUpdateTimestamp;\n\n    uint256 stakingRateStored;\n\n    uint256 constant ratePerSecond = 21979553177; //(1+ratePerSecond)^(86400*365) = 2\n\n    constructor() public {\n\n        stakingRateStored = 1e18;\n\n        lastUpdateTimestamp = block.timestamp;\n\n    }\n\n\n\n    function stakingRate(uint256 time) external returns (uint256 rate) {\n\n        if(time == 30 days) return stakingRateMax().div(12);\n\n        else if(time == 90 days) return stakingRateMax().div(4);\n\n        else if(time == 180 days) return stakingRateMax().div(2);\n\n        else if(time == 360 days) return stakingRateMax();\n\n    }\n\n\n\n    function stakingRateMax() public returns (uint256 rate) {\n\n        uint256 timeElapsed = block.timestamp.sub(lastUpdateTimestamp);\n\n        // SWC-Block values as a proxy for time: L509\n\n        if(timeElapsed > 0) {\n\n            lastUpdateTimestamp = block.timestamp;\n\n            rate = timeElapsed.mul(ratePerSecond).add(1e18).mul(stakingRateStored).div(1e18);\n\n            stakingRateStored = rate;\n\n        }\n\n        else rate = stakingRateStored;\n\n    }\n\n\n",
                    "message": "Contract 'stakingRateModel' (wHakka.sol#490-519) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant ratePerSecond = 21979553177; //(1+ratePerSecond)^(86400*365) = 2\n",
                    "message": "Constant 'stakingRateModel.ratePerSecond' (wHakka.sol#495) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 521,
                    "vulnerability_to_line": 603,
                    "vulnerability_code": "contract wHakka is Ownable, ERC20Mintable{\n\n    using SafeMath for *;\n\n    using SafeERC20 for IERC20;\n\n\n\n    struct vault {\n\n        uint256 hakkaAmount;\n\n        uint256 wAmount;\n\n        uint256 unlockTime;\n\n    }\n\n\n\n    event Stake(address indexed holder, address indexed depositor, uint256 amount, uint256 wAmount, uint256 time);\n\n    event Unstake(address indexed holder, address indexed receiver, uint256 amount, uint256 wAmount);\n\n\n\n    IERC20 public constant Hakka = IERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\n\n    stakingRateModel public currentModel;\n\n\n\n    mapping(address => mapping(uint256 => vault)) public vaults;\n\n    mapping(address => uint256) public vaultCount;\n\n    mapping(address => uint256) public stakedHakka;\n\n    mapping(address => uint256) public votingPower;\n\n\n\n    constructor() public {\n\n        symbol = \"wHAKKA\";\n\n        name = \"Wrapped Hakka\";\n\n        decimals = 18;\n\n        _balances[address(this)] = uint256(-1);\n\n        _balances[address(0)] = uint256(-1);\n\n    }\n\n\n\n    function getStakingRate(uint256 time) public returns (uint256 rate) {\n\n        return currentModel.stakingRate(time);\n\n    }\n\n\n\n    function setStakingRateModel(address newModel) external onlyOwner {\n\n        currentModel = stakingRateModel(newModel);\n\n    }\n\n\n\n// SWC-Reentrancy: L556 - L573\n\n    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n\n        vault storage v = vaults[to][vaultCount[to]];\n\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n\n        require(wAmount > 0, \"invalid lockup\");\n\n\n\n        v.hakkaAmount = amount;\n\n        v.wAmount = wAmount;\n\n        v.unlockTime = block.timestamp.add(time);\n\n        \n\n        stakedHakka[to] = stakedHakka[to].add(amount);\n\n        votingPower[to] = votingPower[to].add(wAmount);\n\n        vaultCount[to]++;\n\n\n\n        _mint(to, wAmount);\n\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n\n    }\n\n\n\n    // SWC-Reentrancy: L576 - L592\n\n    function unstake(address to, uint256 index, uint256 wAmount) public returns (uint256 amount) {\n\n        vault storage v = vaults[msg.sender][index];\n\n        // SWC-Block values as a proxy for time: L580\n\n        require(block.timestamp >= v.unlockTime, \"locked\");\n\n        require(wAmount <= v.wAmount, \"exceed locked amount\");\n\n        amount = wAmount.mul(v.hakkaAmount).div(v.wAmount);\n\n\n\n        v.hakkaAmount = v.hakkaAmount.sub(amount);\n\n        v.wAmount = v.wAmount.sub(wAmount);\n\n\n\n        stakedHakka[msg.sender] = stakedHakka[msg.sender].sub(amount);\n\n        votingPower[msg.sender] = votingPower[msg.sender].sub(wAmount);\n\n\n\n        _burn(msg.sender, wAmount);\n\n        Hakka.safeTransfer(to, amount);\n\n        \n\n        emit Unstake(msg.sender, to, amount, wAmount);\n\n    }\n\n\n\n    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n\n        require(_TokenAddress != Hakka);\n\n        _TokenAddress.safeTransfer(msg.sender, _amount);\n\n    }\n\n\n",
                    "message": "Contract 'wHakka' (wHakka.sol#521-603) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 525,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    struct vault {\n\n        uint256 hakkaAmount;\n\n        uint256 wAmount;\n\n        uint256 unlockTime;\n",
                    "message": "Struct 'wHakka.vault' (wHakka.sol#525-529) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n",
                    "message": "Parameter '_TokenAddress' of wHakka.inCaseTokenGetsStuckPartial (wHakka.sol#598) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n",
                    "message": "Parameter '_amount' of wHakka.inCaseTokenGetsStuckPartial (wHakka.sol#598) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    IERC20 public constant Hakka = IERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\n",
                    "message": "Constant 'wHakka.Hakka' (wHakka.sol#534) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    IERC20 public constant Hakka = IERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 547,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _balances[address(0)] = uint256(-1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ERC20_APPROVE",
                    "vulnerability_from_line": 452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address spender, uint256 value) public returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_OVERPOWERED_ROLE",
                    "vulnerability_from_line": 554,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setStakingRateModel(address newModel) external onlyOwner {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for *;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for *;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 368,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 383,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 388,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 393,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, bytes memory returndata) = address(token).call(data);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 354,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function sendValue(address payable recipient, uint256 amount) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(address(this).balance >= amount, \"Address: insufficient balance\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 358,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        (bool success, ) = recipient.call.value(amount)(\"\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(success, \"Address: unable to send value, recipient may have reverted\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 493,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 lastUpdateTimestamp;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 494,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 stakingRateStored;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 495,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint256 constant ratePerSecond = 21979553177; //(1+ratePerSecond)^(86400*365) = 2\n",
                    "message": null
                }
            ]
        }
    }
}