{
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/oracle.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TokenWhitelist is ENSResolvable, Controllable, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < inBytes.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1802,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (i < parts.length - 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 2954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if(subindex == n.length)\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 3643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < _tokenList.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ens = ensAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ensRegistry = _ensReg_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ens = ENS(_ensRegistry);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerNode = _controllerNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _oracleNode = _oracleNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1888,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _stablecoin = _stabelcoinAddress_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1889,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _tokenWhitelistNode = _tokenWhitelistNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 2047,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _resolver_, address _ens_, bytes32 _controllerNameHash_, bytes32 _tokenWhitelistNameHash_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) TokenWhitelistable(_tokenWhitelistNameHash_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        cryptoCompareAPIPublicKey = hex\"a0f4f688350018ad1b9785991c0bde5f704b005dc79972b114dbed4a615a983710bfc647ebe5a320daa28771dce6a2d104f5efa2e4a85ba3760b76d46f8571ca\";\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3501,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        OAR = OraclizeAddrResolverI(_resolver_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3502,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        oraclize_setCustomGasPrice(10000000000);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3503,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        oraclize_setProof(proofType_Native);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 3504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenInfoMap[_tokens[i]] = Token({\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1918,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.push(_tokens[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1930,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delete _tokenInfoMap[token];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1937,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (_tokenAddressArray[j] == token) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3618,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _queryToToken[queryID] = tokenAddresses[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 3652,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                _queryToToken[queryID] = _tokenList[i];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < inBytes.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 2945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i=0; i< n_random_bytes; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3395,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3396,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3398,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 3643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < _tokenList.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 811,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"not a valid month\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(integral, \"missing integral part\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 995,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!decimals, \"duplicate decimal point\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!exp, \"decimal after exponent\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!minus, \"duplicate -\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!plus, \"extra sign\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1003,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(expIndex + 1 == i, \"- sign not immediately after e\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!plus, \"duplicate +\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!minus, \"extra sign\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(expIndex + 1 == i, \"+ sign not immediately after e\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(integral, \"missing integral part\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!exp, \"duplicate exponent symbol\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1019,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                revert(\"invalid digit\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1036,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(mintExp - _magnitudeMult < 78, \"exponent > 77\"); //\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1059,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_magnitudeMult - decMinted < 78, \"exponent > 77\"); //\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1068,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_magnitudeMult < 78, \"more than 77 decimal digits parsed\"); //\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1873,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require (_isController(msg.sender) || msg.sender == oracleAddress, \"either oracle or controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1900,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1904,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1930,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1954,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokenInfoMap[_token].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3545,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(msg.sender == oraclize_cbAddress(), \"sender is not oraclize\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3548,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(token != address(0), \"queryID matches to address 0\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3551,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(available, \"token must be available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(jsonLen > 8 && jsonLen <= 28, \"misformatted input\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3580,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(keccak256(jsonPrefix) == _PREFIX_HASH, \"prefix mismatch\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(body._len == jsonLen - 1, \"not json format\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(available, \"token must be available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"invalid proof length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"invalid signature length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3682,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"invalid headers length\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3690,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"invalid signature\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3704,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"invalid date\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"result hash not matching\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(day > 0 && day < 32, \"day error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3749,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(month > 0 && month < 13, \"month error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(year > 2017 && year < 3000, \"year error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(hour < 25, \"hour error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3758,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(minute < 60, \"minute error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 3761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(second < 60, \"second error\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1900,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((_nbytes > 0) && (_nbytes <= 32));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3386,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(jsonLen > 8 && jsonLen <= 28, \"misformatted input\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3746,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(day > 0 && day < 32, \"day error\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3749,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(month > 0 && month < 13, \"month error\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 3752,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(year > 2017 && year < 3000, \"year error\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                data = record.abis[contentType];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((inBytes[i] >= _ZERO_ASCII) && (inBytes[i] <= _NINE_ASCII) && (!exp)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 973,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // 'e' not encountered yet, minting integer part or decimals\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (decimals) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    // '.' encountered\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 976,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    // use safeMath in case there is an overflow\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    mintDec = mintDec.mul(10);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 978,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    mintDec = mintDec.add(uint(inBytes[i]) - uint(_ZERO_ASCII));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    decMinted++; //keep track of the #decimals\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 980,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                } else {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 981,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    // integral part (before '.')\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 987,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if ((inBytes[i] >= _ZERO_ASCII) && (inBytes[i] <= _NINE_ASCII) && (exp)) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 988,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                //exponential notation (e-/+) has been detected, mint the exponent\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 989,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mintExp = mintExp.mul(10);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 990,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mintExp = mintExp.add(uint(inBytes[i]) - uint(_ZERO_ASCII));\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 991,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (inBytes[i] == _DOT_ASCII) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                //an integral part before should always exist before '.'\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 993,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(integral, \"missing integral part\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 994,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                // an extra decimal point makes the format invalid\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 995,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                require(!decimals, \"duplicate decimal point\");\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                //the decimal point should always be before the exponent\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2906,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2907,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2908,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2909,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2911,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2911,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 2911,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3002,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3003,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (decimals){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                   if (_b == 0) break;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    else _b--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3006,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mint *= 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3008,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mint += uint(bresult[i]) - 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3009,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (bresult[i] == 46) decimals = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v != 27 && v != 28)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 3346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return (false, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1616,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 3005,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    else _b--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < inBytes.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    decMinted++; //keep track of the #decimals\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1255,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (l = 0; ptr < end; l++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1585,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (idx = 0; idx <= selflen - needlelen; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            cnt++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < minLength; i ++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        subindex++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2973,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 2975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            len++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i=0; i< n_random_bytes; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 3643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < _tokenList.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 1068,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_magnitudeMult < 78, \"more than 77 decimal digits parsed\"); //\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_101"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Claimable._claim (oracle.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (oracle.sol#150)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1139,
                    "vulnerability_to_line": 1156,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy (oracle.sol#1139-1156) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": 1169,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice (oracle.sol#1163-1169) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": 1218,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 (oracle.sol#1209-1218) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": 1241,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString (oracle.sol#1234-1241) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1251,
                    "vulnerability_to_line": 1272,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len (oracle.sol#1251-1272) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": 1320,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare (oracle.sol#1292-1320) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1339,
                    "vulnerability_to_line": 1373,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune (oracle.sol#1339-1373) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1390,
                    "vulnerability_to_line": 1432,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord (oracle.sol#1390-1432) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1439,
                    "vulnerability_to_line": 1443,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak (oracle.sol#1439-1443) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": 1468,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith (oracle.sol#1451-1468) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1477,
                    "vulnerability_to_line": 1498,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond (oracle.sol#1477-1498) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1506,
                    "vulnerability_to_line": 1525,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith (oracle.sol#1506-1525) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": 1554,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until (oracle.sol#1534-1554) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1558,
                    "vulnerability_to_line": 1595,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr (oracle.sol#1558-1595) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1599,
                    "vulnerability_to_line": 1635,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr (oracle.sol#1599-1635) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1770,
                    "vulnerability_to_line": 1777,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat (oracle.sol#1770-1777) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1787,
                    "vulnerability_to_line": 1809,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join (oracle.sol#1787-1809) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 2213,
                    "vulnerability_to_line": 2224,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n\n        uint capacity = _capacity;\n\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n\n        // Allocate space for the buffer data\n\n        buf.capacity = capacity;\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(buf, ptr)\n\n            mstore(ptr, 0)\n\n            mstore(0x40, add(ptr, capacity))\n\n        }\n",
                    "message": "Buffer.init (oracle.sol#2213-2224) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2284,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n\n        if(data.length + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, data.length) * 2);\n\n        }\n\n\n\n        uint dest;\n\n        uint src;\n\n        uint len = data.length;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Start address = buffer address + buffer length + sizeof(buffer length)\n\n            dest := add(add(bufptr, buflen), 32)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, mload(data)))\n\n            src := add(data, 32)\n\n        }\n\n\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n\n\n        return buf;\n",
                    "message": "Buffer.append (oracle.sol#2246-2284) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": 2309,
                    "vulnerability_code": "    function append(buffer memory buf, uint8 data) internal pure {\n\n        if(buf.buf.length + 1 > buf.capacity) {\n\n            resize(buf, buf.capacity * 2);\n\n        }\n\n\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length)\n\n            let dest := add(add(bufptr, buflen), 32)\n\n            mstore8(dest, data)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, 1))\n\n        }\n",
                    "message": "Buffer.append (oracle.sol#2293-2309) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2336,
                    "vulnerability_code": "    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n\n        if(len + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, len) * 2);\n\n        }\n\n\n\n        uint mask = 256 ** len - 1;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\n\n            let dest := add(add(bufptr, buflen), len)\n\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, len))\n\n        }\n\n        return buf;\n",
                    "message": "Buffer.appendInt (oracle.sol#2318-2336) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 2891,
                    "vulnerability_to_line": 2895,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n",
                    "message": "usingOraclize.getCodeSize (oracle.sol#2891-2895) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 3259,
                    "vulnerability_to_line": 3279,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n",
                    "message": "usingOraclize.copyBytes (oracle.sol#3259-3279) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 3351,
                    "vulnerability_to_line": 3356,
                    "vulnerability_code": "    function safeMemoryCleaner() internal pure {\n\n        assembly {\n\n            let fmem := mload(0x40)\n\n            codecopy(fmem, codesize, sub(msize, fmem))\n\n        }\n",
                    "message": "usingOraclize.safeMemoryCleaner (oracle.sol#3351-3356) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": 3423,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Base64._base64decode (oracle.sol#3376-3423) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": 3568,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n\n        // Require that the caller is the Oraclize contract.\n\n        require(msg.sender == oraclize_cbAddress(), \"sender is not oraclize\");\n\n        // Use the query ID to find the matching token address.\n\n        address token = _queryToToken[_queryID];\n\n        require(token != address(0), \"queryID matches to address 0\");\n\n        // Get the corresponding token object.\n\n        ( , , , bool available, , , uint256 lastUpdate) = _getTokenInfo(token);\n\n        require(available, \"token must be available\");\n\n\n\n        bool valid;\n\n        uint timestamp;\n\n        (valid, timestamp) = _verifyProof(_result, _proof, cryptoCompareAPIPublicKey, lastUpdate);\n\n\n\n        // Require that the proof is valid.\n\n        if (valid) {\n\n            // Parse the JSON result to get the rate in wei.\n\n            uint256 parsedRate = _parseIntScientificWei(parseRate(_result));\n\n            // Set the update time of the token rate.\n\n            uint256 parsedLastUpdate = timestamp;\n\n            // Remove query from the list.\n\n            delete _queryToToken[_queryID];\n\n\n\n            _updateTokenRate(token, parsedRate, parsedLastUpdate);\n\n        }\n",
                    "message": "Reentrancy in Oracle.__callback (oracle.sol#3543-3568):\n\tExternal calls:\n\t- require(bool,string)(msg.sender == oraclize_cbAddress(),sender is not oraclize) (oracle.sol#3545)\n\t- (available,lastUpdate) = _getTokenInfo(token) (oracle.sol#3550)\n\tState variables written after the call(s):\n\t- _queryToToken (oracle.sol#3564)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 3499,
                    "vulnerability_to_line": 3504,
                    "vulnerability_code": "    constructor(address _resolver_, address _ens_, bytes32 _controllerNameHash_, bytes32 _tokenWhitelistNameHash_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) TokenWhitelistable(_tokenWhitelistNameHash_) public {\n\n        cryptoCompareAPIPublicKey = hex\"a0f4f688350018ad1b9785991c0bde5f704b005dc79972b114dbed4a615a983710bfc647ebe5a320daa28771dce6a2d104f5efa2e4a85ba3760b76d46f8571ca\";\n\n        OAR = OraclizeAddrResolverI(_resolver_);\n\n        oraclize_setCustomGasPrice(10000000000);\n\n        oraclize_setProof(proofType_Native);\n",
                    "message": "Reentrancy in Oracle.constructor (oracle.sol#3499-3504):\n\tExternal calls:\n\t- oraclize_setCustomGasPrice(10000000000) (oracle.sol#3502)\n\t- oraclize_setProof(proofType_Native) (oracle.sol#3503)\n\tState variables written after the call(s):\n\t- OAR (oracle.sol#3503)\n\t- oraclize (oracle.sol#3503)\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 2430,
                    "vulnerability_to_line": 2438,
                    "vulnerability_code": "    modifier oraclizeAPI {\n\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\n            oraclize_setNetwork(networkID_auto);\n\n\n\n        if(address(oraclize) != OAR.getAddress())\n\n            oraclize = OraclizeI(OAR.getAddress());\n\n\n\n        _;\n",
                    "message": "Reentrancy in usingOraclize.oraclizeAPI (oracle.sol#2430-2438):\n\tExternal calls:\n\t- address(oraclize) != OAR.getAddress() (oracle.sol#2434-2435)\n\t- oraclize = OraclizeI(OAR.getAddress()) (oracle.sol#2435)\n\tState variables written after the call(s):\n\t- oraclize (oracle.sol#2435)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 1177,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint ret;\n",
                    "message": "ret in strings.len (oracle.sol#1177) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 3047,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Buffer.buffer memory buf;\n",
                    "message": "buf in usingOraclize.ba2cbor (oracle.sol#3047) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 3035,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Buffer.buffer memory buf;\n",
                    "message": "buf in usingOraclize.stra2cbor (oracle.sol#3035) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2350,
                    "vulnerability_to_line": 2366,
                    "vulnerability_code": "    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n\n        if(value <= 23) {\n\n            buf.append(uint8((major << 5) | value));\n\n        } else if(value <= 0xFF) {\n\n            buf.append(uint8((major << 5) | 24));\n\n            buf.appendInt(value, 1);\n\n        } else if(value <= 0xFFFF) {\n\n            buf.append(uint8((major << 5) | 25));\n\n            buf.appendInt(value, 2);\n\n        } else if(value <= 0xFFFFFFFF) {\n\n            buf.append(uint8((major << 5) | 26));\n\n            buf.appendInt(value, 4);\n\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n\n            buf.append(uint8((major << 5) | 27));\n\n            buf.appendInt(value, 8);\n\n        }\n",
                    "message": "CBOR.encodeType (oracle.sol#2350-2366) does not use the value returned by external calls:\n\t-buf.appendInt(value,1) (oracle.sol#2355)\n\t-buf.appendInt(value,2) (oracle.sol#2358)\n\t-buf.appendInt(value,4) (oracle.sol#2361)\n\t-buf.appendInt(value,8) (oracle.sol#2364)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2384,
                    "vulnerability_to_line": 2387,
                    "vulnerability_code": "    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n\n        buf.append(value);\n",
                    "message": "CBOR.encodeBytes (oracle.sol#2384-2387) does not use the value returned by external calls:\n\t-buf.append(value) (oracle.sol#2386)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 2389,
                    "vulnerability_to_line": 2392,
                    "vulnerability_code": "    function encodeString(Buffer.buffer memory buf, string value) internal pure {\n\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n\n        buf.append(bytes(value));\n",
                    "message": "CBOR.encodeString (oracle.sol#2389-2392) does not use the value returned by external calls:\n\t-buf.append(bytes(value)) (oracle.sol#2391)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 3572,
                    "vulnerability_to_line": 3590,
                    "vulnerability_code": "    function parseRate(string _json) internal pure returns (string) {\n\n\n\n        uint jsonLen = abi.encodePacked(_json).length;\n\n        //{\"ETH\":}.length = 8, assuming a (maximum of) 18 digit prevision\n\n        require(jsonLen > 8 && jsonLen <= 28, \"misformatted input\");\n\n\n\n        bytes memory jsonPrefix = new bytes(7);\n\n        copyBytes(abi.encodePacked(_json), 0, 7, jsonPrefix, 0);\n\n        require(keccak256(jsonPrefix) == _PREFIX_HASH, \"prefix mismatch\");\n\n\n\n        strings.slice memory body = _json.toSlice();\n\n        body.split(\":\".toSlice());\n\n        //we are sure that ':' is included in the string, body now contains the rate+'}'\n\n        jsonLen = body._len;\n\n        body.until(\"}\".toSlice());\n\n        require(body._len == jsonLen - 1, \"not json format\");\n\n        //ensure that the json is properly terminated with a '}'\n\n        return body.toString();\n",
                    "message": "Oracle.parseRate (oracle.sol#3572-3590) does not use the value returned by external calls:\n\t-body.split(:.toSlice()) (oracle.sol#3583)\n\t-body.until(}.toSlice()) (oracle.sol#3586)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ oracle.sol#361) shadows:\n\t- ENS.owner (function @ oracle.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ oracle.sol#362) shadows:\n\t- ENS.resolver (function @ oracle.sol#366)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ oracle.sol#363) shadows:\n\t- ENS.owner (function @ oracle.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ oracle.sol#364) shadows:\n\t- ENS.ttl (function @ oracle.sol#367)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
                    "message": "PublicResolver.setAddr.addr (local variable @ oracle.sol#464) shadows:\n\t- PublicResolver.addr (function @ oracle.sol#617-619)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": "PublicResolver.setName.name (local variable @ oracle.sol#499) shadows:\n\t- PublicResolver.name (function @ oracle.sol#588-590)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 1139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": "strings.memcpy.len (local variable @ oracle.sol#1139) shadows:\n\t- strings.len (function @ oracle.sol#1176-1200)\n\t- strings.len (function @ oracle.sol#1251-1272)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 3745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint day = _parseIntScientific(date.split(dateDelimiter).toString());\n",
                    "message": "Oracle._verifyDate.day (local variable @ oracle.sol#3745) shadows:\n\t- usingOraclize.day (state variable @ oracle.sol#2412)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 3748,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint month = _monthToNumber(date.split(dateDelimiter).toString());\n",
                    "message": "Oracle._verifyDate.month (local variable @ oracle.sol#3748) shadows:\n\t- usingOraclize.month (state variable @ oracle.sol#2414)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 3594,
                    "vulnerability_to_line": 3623,
                    "vulnerability_code": "    function _updateTokenRates(uint _gasLimit) private {\n\n        address[] memory tokenAddresses = _tokenAddressArray();\n\n        // Check if there are any existing tokens.\n\n        if (tokenAddresses.length == 0) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"no tokens\");\n\n            // Check if the contract has enough Ether to pay for the query.\n\n        } else if (oraclize_getPrice(\"URL\") * tokenAddresses.length > address(this).balance) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"insufficient balance\");\n\n        } else {\n\n            // Set up the cryptocompare API query strings.\n\n            strings.slice memory apiPrefix = \"https://min-api.cryptocompare.com/data/price?fsym=\".toSlice();\n\n            strings.slice memory apiSuffix = \"&tsyms=ETH&sign=true\".toSlice();\n\n\n\n            // Create a new oraclize query for each supported token.\n\n            for (uint i = 0; i < tokenAddresses.length; i++) {\n\n                // Store the token symbol used in the query.\n\n                (string memory symbol, , , , , , ) = _getTokenInfo(tokenAddresses[i]);\n\n\n\n                strings.slice memory sym = symbol.toSlice();\n\n                // Create a new oraclize query from the component strings.\n\n                bytes32 queryID = oraclize_query(\"URL\", apiPrefix.concat(sym).toSlice().concat(apiSuffix), _gasLimit);\n\n                // Store the query ID together with the associated token address.\n\n                _queryToToken[queryID] = tokenAddresses[i];\n\n                // Emit the query success event.\n\n                emit RequestedUpdate(sym.toString());\n\n            }\n\n        }\n",
                    "message": "Reentrancy in Oracle._updateTokenRates (oracle.sol#3594-3623):\n\tExternal calls:\n\t- tokenAddresses = _tokenAddressArray() (oracle.sol#3595)\n\t- oraclize_getPrice(URL) * tokenAddresses.length > address(this).balance (oracle.sol#3601-3622)\n\tState variables written after the call(s):\n\t- oraclize_network_name (oracle.sol#3601-3622)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 3594,
                    "vulnerability_to_line": 3623,
                    "vulnerability_code": "    function _updateTokenRates(uint _gasLimit) private {\n\n        address[] memory tokenAddresses = _tokenAddressArray();\n\n        // Check if there are any existing tokens.\n\n        if (tokenAddresses.length == 0) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"no tokens\");\n\n            // Check if the contract has enough Ether to pay for the query.\n\n        } else if (oraclize_getPrice(\"URL\") * tokenAddresses.length > address(this).balance) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"insufficient balance\");\n\n        } else {\n\n            // Set up the cryptocompare API query strings.\n\n            strings.slice memory apiPrefix = \"https://min-api.cryptocompare.com/data/price?fsym=\".toSlice();\n\n            strings.slice memory apiSuffix = \"&tsyms=ETH&sign=true\".toSlice();\n\n\n\n            // Create a new oraclize query for each supported token.\n\n            for (uint i = 0; i < tokenAddresses.length; i++) {\n\n                // Store the token symbol used in the query.\n\n                (string memory symbol, , , , , , ) = _getTokenInfo(tokenAddresses[i]);\n\n\n\n                strings.slice memory sym = symbol.toSlice();\n\n                // Create a new oraclize query from the component strings.\n\n                bytes32 queryID = oraclize_query(\"URL\", apiPrefix.concat(sym).toSlice().concat(apiSuffix), _gasLimit);\n\n                // Store the query ID together with the associated token address.\n\n                _queryToToken[queryID] = tokenAddresses[i];\n\n                // Emit the query success event.\n\n                emit RequestedUpdate(sym.toString());\n\n            }\n\n        }\n",
                    "message": "Reentrancy in Oracle._updateTokenRates (oracle.sol#3594-3623):\n\tExternal calls:\n\t- tokenAddresses = _tokenAddressArray() (oracle.sol#3595)\n\t- (symbol) = _getTokenInfo(tokenAddresses[i]) (oracle.sol#3612)\n\t- queryID = oraclize_query(URL,apiPrefix.concat(sym).toSlice().concat(apiSuffix),_gasLimit) (oracle.sol#3616)\n\tExternal calls sending eth:\n\t- queryID = oraclize_query(URL,apiPrefix.concat(sym).toSlice().concat(apiSuffix),_gasLimit) (oracle.sol#3616)\n\tState variables written after the call(s):\n\t- _queryToToken (oracle.sol#3618)\n\t- oraclize_network_name (oracle.sol#3616)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 3628,
                    "vulnerability_to_line": 3657,
                    "vulnerability_code": "    function _updateTokenRatesList(uint _gasLimit, address[] _tokenList) private {\n\n        // Check if there are any existing tokens.\n\n        if (_tokenList.length == 0) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"empty token list\");\n\n        // Check if the contract has enough Ether to pay for the query.\n\n        } else if (oraclize_getPrice(\"URL\") * _tokenList.length > address(this).balance) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"insufficient balance\");\n\n        } else {\n\n            // Set up the cryptocompare API query strings.\n\n            strings.slice memory apiPrefix = \"https://min-api.cryptocompare.com/data/price?fsym=\".toSlice();\n\n            strings.slice memory apiSuffix = \"&tsyms=ETH&sign=true\".toSlice();\n\n\n\n            // Create a new oraclize query for each supported token.\n\n            for (uint i = 0; i < _tokenList.length; i++) {\n\n                //token must exist, revert if it doesn't\n\n                (string memory tokenSymbol, , , bool available , , , ) = _getTokenInfo(_tokenList[i]);\n\n                require(available, \"token must be available\");\n\n                // Store the token symbol used in the query.\n\n                strings.slice memory symbol = tokenSymbol.toSlice();\n\n                // Create a new oraclize query from the component strings.\n\n                bytes32 queryID = oraclize_query(\"URL\", apiPrefix.concat(symbol).toSlice().concat(apiSuffix), _gasLimit);\n\n                // Store the query ID together with the associated token address.\n\n                _queryToToken[queryID] = _tokenList[i];\n\n                // Emit the query success event.\n\n                emit RequestedUpdate(symbol.toString());\n\n            }\n\n        }\n",
                    "message": "Reentrancy in Oracle._updateTokenRatesList (oracle.sol#3628-3657):\n\tExternal calls:\n\t- (tokenSymbol,available) = _getTokenInfo(_tokenList[i]) (oracle.sol#3645)\n\t- queryID = oraclize_query(URL,apiPrefix.concat(symbol).toSlice().concat(apiSuffix),_gasLimit) (oracle.sol#3650)\n\tExternal calls sending eth:\n\t- queryID = oraclize_query(URL,apiPrefix.concat(symbol).toSlice().concat(apiSuffix),_gasLimit) (oracle.sol#3650)\n\tState variables written after the call(s):\n\t- _queryToToken (oracle.sol#3652)\n\t- oraclize_network_name (oracle.sol#3650)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 3499,
                    "vulnerability_to_line": 3504,
                    "vulnerability_code": "    constructor(address _resolver_, address _ens_, bytes32 _controllerNameHash_, bytes32 _tokenWhitelistNameHash_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) TokenWhitelistable(_tokenWhitelistNameHash_) public {\n\n        cryptoCompareAPIPublicKey = hex\"a0f4f688350018ad1b9785991c0bde5f704b005dc79972b114dbed4a615a983710bfc647ebe5a320daa28771dce6a2d104f5efa2e4a85ba3760b76d46f8571ca\";\n\n        OAR = OraclizeAddrResolverI(_resolver_);\n\n        oraclize_setCustomGasPrice(10000000000);\n\n        oraclize_setProof(proofType_Native);\n",
                    "message": "Reentrancy in Oracle.constructor (oracle.sol#3499-3504):\n\tExternal calls:\n\t- oraclize_setCustomGasPrice(10000000000) (oracle.sol#3502)\n\t- oraclize_setProof(proofType_Native) (oracle.sol#3503)\n\tState variables written after the call(s):\n\t- oraclize_network_name (oracle.sol#3503)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 3066,
                    "vulnerability_to_line": 3112,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n",
                    "message": "Reentrancy in usingOraclize.oraclize_newRandomDSQuery (oracle.sol#3066-3112):\n\tExternal calls:\n\t- sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash() (oracle.sol#3074)\n\t- queryId = oraclize_query(random,args,_customGasLimit) (oracle.sol#3093)\n\tExternal calls sending eth:\n\t- queryId = oraclize_query(random,args,_customGasLimit) (oracle.sol#3093)\n\tState variables written after the call(s):\n\t- oraclize_network_name (oracle.sol#3093)\n\t- oraclize_randomDS_args (oracle.sol#3110)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1139,
                    "vulnerability_to_line": 1156,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy uses assembly (oracle.sol#1139-1156)\n\t- oracle.sol#1142-1145\n\t- oracle.sol#1151-1156\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": 1169,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice uses assembly (oracle.sol#1163-1169)\n\t- oracle.sol#1165-1168\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": 1218,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 uses assembly (oracle.sol#1209-1218)\n\t- oracle.sol#1211-1217\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": 1241,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString uses assembly (oracle.sol#1234-1241)\n\t- oracle.sol#1237-1239\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1251,
                    "vulnerability_to_line": 1272,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len uses assembly (oracle.sol#1251-1272)\n\t- oracle.sol#1257-1258\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": 1320,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare uses assembly (oracle.sol#1292-1320)\n\t- oracle.sol#1302-1306\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1339,
                    "vulnerability_to_line": 1373,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune uses assembly (oracle.sol#1339-1373)\n\t- oracle.sol#1350-1351\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1390,
                    "vulnerability_to_line": 1432,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord uses assembly (oracle.sol#1390-1432)\n\t- oracle.sol#1400-1401\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1439,
                    "vulnerability_to_line": 1443,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak uses assembly (oracle.sol#1439-1443)\n\t- oracle.sol#1440-1443\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": 1468,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith uses assembly (oracle.sol#1451-1468)\n\t- oracle.sol#1461-1467\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1477,
                    "vulnerability_to_line": 1498,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond uses assembly (oracle.sol#1477-1498)\n\t- oracle.sol#1484-1490\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1506,
                    "vulnerability_to_line": 1525,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith uses assembly (oracle.sol#1506-1525)\n\t- oracle.sol#1518-1524\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": 1554,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until uses assembly (oracle.sol#1534-1554)\n\t- oracle.sol#1542-1547\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1558,
                    "vulnerability_to_line": 1595,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr uses assembly (oracle.sol#1558-1595)\n\t- oracle.sol#1567-1569\n\t- oracle.sol#1571-1573\n\t- oracle.sol#1577-1578\n\t- oracle.sol#1583-1585\n\t- oracle.sol#1587-1588\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1599,
                    "vulnerability_to_line": 1635,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr uses assembly (oracle.sol#1599-1635)\n\t- oracle.sol#1607-1609\n\t- oracle.sol#1611-1613\n\t- oracle.sol#1617-1618\n\t- oracle.sol#1623-1624\n\t- oracle.sol#1627-1628\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1770,
                    "vulnerability_to_line": 1777,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat uses assembly (oracle.sol#1770-1777)\n\t- oracle.sol#1773-1774\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1787,
                    "vulnerability_to_line": 1809,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join uses assembly (oracle.sol#1787-1809)\n\t- oracle.sol#1797-1799\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2213,
                    "vulnerability_to_line": 2224,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n\n        uint capacity = _capacity;\n\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n\n        // Allocate space for the buffer data\n\n        buf.capacity = capacity;\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(buf, ptr)\n\n            mstore(ptr, 0)\n\n            mstore(0x40, add(ptr, capacity))\n\n        }\n",
                    "message": "Buffer.init uses assembly (oracle.sol#2213-2224)\n\t- oracle.sol#2218-2224\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": 2284,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n\n        if(data.length + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, data.length) * 2);\n\n        }\n\n\n\n        uint dest;\n\n        uint src;\n\n        uint len = data.length;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Start address = buffer address + buffer length + sizeof(buffer length)\n\n            dest := add(add(bufptr, buflen), 32)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, mload(data)))\n\n            src := add(data, 32)\n\n        }\n\n\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n\n\n        return buf;\n",
                    "message": "Buffer.append uses assembly (oracle.sol#2246-2284)\n\t- oracle.sol#2254-2267\n\t- oracle.sol#2268-2271\n\t- oracle.sol#2277-2283\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": 2309,
                    "vulnerability_code": "    function append(buffer memory buf, uint8 data) internal pure {\n\n        if(buf.buf.length + 1 > buf.capacity) {\n\n            resize(buf, buf.capacity * 2);\n\n        }\n\n\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length)\n\n            let dest := add(add(bufptr, buflen), 32)\n\n            mstore8(dest, data)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, 1))\n\n        }\n",
                    "message": "Buffer.append uses assembly (oracle.sol#2293-2309)\n\t- oracle.sol#2298-2309\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": 2336,
                    "vulnerability_code": "    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n\n        if(len + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, len) * 2);\n\n        }\n\n\n\n        uint mask = 256 ** len - 1;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\n\n            let dest := add(add(bufptr, buflen), len)\n\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, len))\n\n        }\n\n        return buf;\n",
                    "message": "Buffer.appendInt uses assembly (oracle.sol#2318-2336)\n\t- oracle.sol#2324-2335\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 2891,
                    "vulnerability_to_line": 2895,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n",
                    "message": "usingOraclize.getCodeSize uses assembly (oracle.sol#2891-2895)\n\t- oracle.sol#2892-2895\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3066,
                    "vulnerability_to_line": 3112,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n",
                    "message": "usingOraclize.oraclize_newRandomDSQuery uses assembly (oracle.sol#3066-3112)\n\t- oracle.sol#3075-3084\n\t- oracle.sol#3085-3089\n\t- oracle.sol#3097-3110\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3121,
                    "vulnerability_to_line": 3147,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\n        bool sigok;\n\n        address signer;\n\n\n\n        bytes32 sigr;\n\n        bytes32 sigs;\n\n\n\n        bytes memory sigr_ = new bytes(32);\n\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\n        bytes memory sigs_ = new bytes(32);\n\n        offset += 32 + 2;\n\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\n\n        assembly {\n\n            sigr := mload(add(sigr_, 32))\n\n            sigs := mload(add(sigs_, 32))\n\n        }\n\n\n\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\n        if (address(keccak256(pubkey)) == signer) return true;\n\n        else {\n\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\n            return (address(keccak256(pubkey)) == signer);\n\n        }\n",
                    "message": "usingOraclize.verifySig uses assembly (oracle.sol#3121-3147)\n\t- oracle.sol#3135-3141\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3259,
                    "vulnerability_to_line": 3279,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n",
                    "message": "usingOraclize.copyBytes uses assembly (oracle.sol#3259-3279)\n\t- oracle.sol#3270-3274\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3283,
                    "vulnerability_to_line": 3308,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n",
                    "message": "usingOraclize.safer_ecrecover uses assembly (oracle.sol#3283-3308)\n\t- oracle.sol#3294-3307\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3311,
                    "vulnerability_to_line": 3349,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        if (sig.length != 65)\n\n          return (false, 0);\n\n\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n\n            // 'mload' will pad with zeroes if we overread.\n\n            // There is no 'mload8' to do this, but that would be nicer.\n\n            v := byte(0, mload(add(sig, 96)))\n\n\n\n            // Alternative solution:\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            // v := and(mload(add(sig, 65)), 255)\n\n        }\n\n\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n\n        // to match the YP range of [27, 28]\n\n        //\n\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n\n        if (v < 27)\n\n          v += 27;\n\n\n\n        if (v != 27 && v != 28)\n\n            return (false, 0);\n\n\n\n        return safer_ecrecover(hash, v, r, s);\n",
                    "message": "usingOraclize.ecrecovery uses assembly (oracle.sol#3311-3349)\n\t- oracle.sol#3322-3342\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3351,
                    "vulnerability_to_line": 3356,
                    "vulnerability_code": "    function safeMemoryCleaner() internal pure {\n\n        assembly {\n\n            let fmem := mload(0x40)\n\n            codecopy(fmem, codesize, sub(msize, fmem))\n\n        }\n",
                    "message": "usingOraclize.safeMemoryCleaner uses assembly (oracle.sol#3351-3356)\n\t- oracle.sol#3352-3356\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": 3423,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Base64._base64decode uses assembly (oracle.sol#3376-3423)\n\t- oracle.sol#3418-3422\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 2161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public cbAddress;\n",
                    "message": "OraclizeI.cbAddress should be constant (oracle.sol#2161)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": "Different versions of Solidity is used in oracle.sol:\n\t- Version used: ['>=0.4.22', '>=0.4.24', '^0.4.14', '^0.4.24', '^0.4.25']\n\t- oracle.sol#21 declares pragma solidity^0.4.25\n\t- oracle.sol#105 declares pragma solidity^0.4.25\n\t- oracle.sol#135 declares pragma solidity^0.4.25\n\t- oracle.sol#179 declares pragma solidity^0.4.25\n\t- oracle.sol#344 declares pragma solidity>=0.4.24\n\t- oracle.sol#401 declares pragma solidity^0.4.24\n\t- oracle.sol#658 declares pragma solidity^0.4.25\n\t- oracle.sol#710 declares pragma solidity^0.4.25\n\t- oracle.sol#762 declares pragma solidity^0.4.25\n\t- oracle.sol#843 declares pragma solidity^0.4.24\n\t- oracle.sol#929 declares pragma solidity^0.4.25\n\t- oracle.sol#1131 declares pragma solidity^0.4.14\n\t- oracle.sol#1832 declares pragma solidity^0.4.25\n\t- oracle.sol#2034 declares pragma solidity^0.4.25\n\t- oracle.sol#2158 declares pragma solidity>=0.4.22\n\t- oracle.sol#3363 declares pragma solidity^0.4.25\n\t- oracle.sol#3446 declares pragma solidity^0.4.25\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (oracle.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
                    "message": "PublicResolver.setAddr (oracle.sol#464-467) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 480,
                    "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
                    "message": "PublicResolver.setContent (oracle.sol#477-480) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
                    "message": "PublicResolver.setMultihash (oracle.sol#488-491) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
                    "message": "PublicResolver.setName (oracle.sol#499-502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
                    "message": "PublicResolver.setABI (oracle.sol#512-518) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
                    "message": "PublicResolver.setPubkey (oracle.sol#526-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
                    "message": "PublicResolver.setText (oracle.sol#538-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
                    "message": "PublicResolver.text (oracle.sol#549-551) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 561,
                    "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
                    "message": "PublicResolver.pubkey (oracle.sol#559-561) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "PublicResolver.ABI (oracle.sol#571-580) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 590,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
                    "message": "PublicResolver.name (oracle.sol#588-590) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
                    "message": "PublicResolver.content (oracle.sol#599-601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
                    "message": "PublicResolver.multihash (oracle.sol#608-610) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": 619,
                    "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
                    "message": "PublicResolver.addr (oracle.sol#617-619) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
                    "message": "PublicResolver.supportsInterface (oracle.sol#626-635) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": "OraclizeI.query2 (oracle.sol#2164) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": "OraclizeI.queryN (oracle.sol#2166) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource) public returns (uint _dsprice);\n",
                    "message": "OraclizeI.getPrice (oracle.sol#2168) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n",
                    "message": "OraclizeI.getPrice (oracle.sol#2169) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAddress() public returns (address _addr);\n",
                    "message": "OraclizeAddrResolverI.getAddress (oracle.sol#2176) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 2484,
                    "vulnerability_to_line": 2486,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n",
                    "message": "usingOraclize.__callback (oracle.sol#2484-2486) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 1131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in oracle.sol:\n\t- pragma solidity^0.4.14 (oracle.sol#1131): it allows old versions\n\t- pragma solidity>=0.4.22 (oracle.sol#2158): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (oracle.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (oracle.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (oracle.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (oracle.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (oracle.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (oracle.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (oracle.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (oracle.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (oracle.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (oracle.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (oracle.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (oracle.sol#147-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (oracle.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (oracle.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (oracle.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address) external view returns (bool);\n",
                    "message": "Parameter '' of IController.isController (oracle.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isController (oracle.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.addAdmin (oracle.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.removeAdmin (oracle.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.addController (oracle.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.removeController (oracle.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isAdmin (oracle.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._addAdmin' (oracle.sol#272-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addAdmin (oracle.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeAdmin' (oracle.sol#283-288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeAdmin (oracle.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": 299,
                    "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._addController' (oracle.sol#291-299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addController (oracle.sol#291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 307,
                    "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeController' (oracle.sol#302-307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeController (oracle.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of Controller.claim (oracle.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of Controller.claim (oracle.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of Controller.claim (oracle.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "Function 'PublicResolver.ABI' (oracle.sol#571-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
                    "message": "Modifier 'PublicResolver.only_owner' (oracle.sol#445-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Parameter '_ensReg_' of ENSResolvable. (oracle.sol#671) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 686,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n\n        return PublicResolver(_ens.resolver(_nodeHash)).addr(_nodeHash);\n",
                    "message": "Function 'ENSResolvable._ensResolve' (oracle.sol#684-686) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n",
                    "message": "Parameter '_nodeHash' of ENSResolvable._ensResolve (oracle.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Parameter '_controllerNameHash_' of Controllable. (oracle.sol#720) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 738,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n",
                    "message": "Function 'Controllable._isController' (oracle.sol#736-738) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n",
                    "message": "Parameter '_account' of Controllable._isController (oracle.sol#736) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": 813,
                    "vulnerability_code": "    function _monthToNumber(string _month) internal pure returns (uint8) {\n\n        bytes32 month = keccak256(abi.encodePacked(_month));\n\n        if (month == _JANUARY) {\n\n            return 1;\n\n        } else if (month == _FEBRUARY) {\n\n            return 2;\n\n        } else if (month == _MARCH) {\n\n            return 3;\n\n        } else if (month == _APRIL) {\n\n            return 4;\n\n        } else if (month == _MAY) {\n\n            return 5;\n\n        } else if (month == _JUNE) {\n\n            return 6;\n\n        } else if (month == _JULY) {\n\n            return 7;\n\n        } else if (month == _AUGUST) {\n\n            return 8;\n\n        } else if (month == _SEPTEMBER) {\n\n            return 9;\n\n        } else if (month == _OCTOBER) {\n\n            return 10;\n\n        } else if (month == _NOVEMBER) {\n\n            return 11;\n\n        } else if (month == _DECEMBER) {\n\n            return 12;\n\n        } else {\n\n            revert(\"not a valid month\");\n\n        }\n",
                    "message": "Function 'Date._monthToNumber' (oracle.sol#784-813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _monthToNumber(string _month) internal pure returns (uint8) {\n",
                    "message": "Parameter '_month' of Date._monthToNumber (oracle.sol#784) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 945,
                    "vulnerability_to_line": 947,
                    "vulnerability_code": "    function _parseIntScientific(string _inString) internal pure returns (uint) {\n\n        return _parseIntScientific(_inString, 0);\n",
                    "message": "Function 'ParseIntScientific._parseIntScientific' (oracle.sol#945-947) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientific(string _inString) internal pure returns (uint) {\n",
                    "message": "Parameter '_inString' of ParseIntScientific._parseIntScientific (oracle.sol#945) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": 952,
                    "vulnerability_code": "    function _parseIntScientificWei(string _inString) internal pure returns (uint) {\n\n        return _parseIntScientific(_inString, 18);\n",
                    "message": "Function 'ParseIntScientific._parseIntScientificWei' (oracle.sol#950-952) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientificWei(string _inString) internal pure returns (uint) {\n",
                    "message": "Parameter '_inString' of ParseIntScientific._parseIntScientificWei (oracle.sol#950) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 1074,
                    "vulnerability_code": "    function _parseIntScientific(string _inString, uint _magnitudeMult) internal pure returns (uint) {\n\n\n\n        bytes memory inBytes = bytes(_inString);\n\n        uint mint = 0; // the final uint returned\n\n        uint mintDec = 0; // the uint following the decimal point\n\n        uint mintExp = 0; // the exponent\n\n        uint decMinted = 0; // how many decimals were 'minted'.\n\n        uint expIndex = 0; // the position in the byte array that 'e' was found (if found)\n\n        bool integral = false; // indicates the existence of the integral part, it should always exist (even if 0) e.g. 'e+1'  or '.1' is not valid\n\n        bool decimals = false; // indicates a decimal number, set to true if '.' is found\n\n        bool exp = false; // indicates if the number being parsed has an exponential representation\n\n        bool minus = false; // indicated if the exponent is negative\n\n        bool plus = false; // indicated if the exponent is positive\n\n\n\n        for (uint i = 0; i < inBytes.length; i++) {\n\n            if ((inBytes[i] >= _ZERO_ASCII) && (inBytes[i] <= _NINE_ASCII) && (!exp)) {\n\n                // 'e' not encountered yet, minting integer part or decimals\n\n                if (decimals) {\n\n                    // '.' encountered\n\n                    // use safeMath in case there is an overflow\n\n                    mintDec = mintDec.mul(10);\n\n                    mintDec = mintDec.add(uint(inBytes[i]) - uint(_ZERO_ASCII));\n\n                    decMinted++; //keep track of the #decimals\n\n                } else {\n\n                    // integral part (before '.')\n\n                    integral = true;\n\n                    // use safeMath in case there is an overflow\n\n                    mint = mint.mul(10);\n\n                    mint = mint.add(uint(inBytes[i]) - uint(_ZERO_ASCII));\n\n                }\n\n            } else if ((inBytes[i] >= _ZERO_ASCII) && (inBytes[i] <= _NINE_ASCII) && (exp)) {\n\n                //exponential notation (e-/+) has been detected, mint the exponent\n\n                mintExp = mintExp.mul(10);\n\n                mintExp = mintExp.add(uint(inBytes[i]) - uint(_ZERO_ASCII));\n\n            } else if (inBytes[i] == _DOT_ASCII) {\n\n                //an integral part before should always exist before '.'\n\n                require(integral, \"missing integral part\");\n\n                // an extra decimal point makes the format invalid\n\n                require(!decimals, \"duplicate decimal point\");\n\n                //the decimal point should always be before the exponent\n\n                require(!exp, \"decimal after exponent\");\n\n                decimals = true;\n\n            } else if (inBytes[i] == _DASH_ASCII) {\n\n                // an extra '-' should be considered an invalid character\n\n                require(!minus, \"duplicate -\");\n\n                require(!plus, \"extra sign\");\n\n                require(expIndex + 1 == i, \"- sign not immediately after e\");\n\n                minus = true;\n\n            } else if (inBytes[i] == _PLUS_ASCII) {\n\n                // an extra '+' should be considered an invalid character\n\n                require(!plus, \"duplicate +\");\n\n                require(!minus, \"extra sign\");\n\n                require(expIndex + 1 == i, \"+ sign not immediately after e\");\n\n                plus = true;\n\n            } else if ((inBytes[i] == _E_ASCII) || (inBytes[i] == _LOWERCASE_E_ASCII)) {\n\n                //an integral part before should always exist before 'e'\n\n                require(integral, \"missing integral part\");\n\n                // an extra 'e' or 'E' should be considered an invalid character\n\n                require(!exp, \"duplicate exponent symbol\");\n\n                exp = true;\n\n                expIndex = i;\n\n            } else {\n\n                revert(\"invalid digit\");\n\n            }\n\n        }\n\n\n\n        if (minus || plus) {\n\n            // end of string e[x|-] without specifying the exponent\n\n            require(i > expIndex + 2);\n\n        } else if (exp) {\n\n            // end of string (e) without specifying the exponent\n\n            require(i > expIndex + 1);\n\n        }\n\n\n\n        if (minus) {\n\n            // e^(-x)\n\n            if (mintExp >= _magnitudeMult) {\n\n                // the (negative) exponent is bigger than the given parameter for \"shifting left\".\n\n                // use integer division to reduce the precision.\n\n                require(mintExp - _magnitudeMult < 78, \"exponent > 77\"); //\n\n                mint /= 10 ** (mintExp - _magnitudeMult);\n\n                return mint;\n\n\n\n            } else {\n\n                // the (negative) exponent is smaller than the given parameter for \"shifting left\".\n\n                //no need for underflow check\n\n                _magnitudeMult = _magnitudeMult - mintExp;\n\n            }\n\n        } else {\n\n            // e^(+x), positive exponent or no exponent\n\n            // just shift left as many times as indicated by the exponent and the shift parameter\n\n            _magnitudeMult = _magnitudeMult.add(mintExp);\n\n        }\n\n\n\n        if (_magnitudeMult >= decMinted) {\n\n            // the decimals are fewer or equal than the shifts: use all of them\n\n            // shift number and add the decimals at the end\n\n            // include decimals if present in the original input\n\n            require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\n\n            mint = mint.mul(10 ** (decMinted));\n\n            mint = mint.add(mintDec);\n\n            //// add zeros at the end if the decimals were fewer than #_magnitudeMult\n\n            require(_magnitudeMult - decMinted < 78, \"exponent > 77\"); //\n\n            mint = mint.mul(10 ** (_magnitudeMult - decMinted));\n\n        } else {\n\n            // the decimals are more than the #_magnitudeMult shifts\n\n            // use only the ones needed, discard the rest\n\n            decMinted -= _magnitudeMult;\n\n            require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\n\n            mintDec /= 10 ** (decMinted);\n\n            // shift number and add the decimals at the end\n\n            require(_magnitudeMult < 78, \"more than 77 decimal digits parsed\"); //\n\n            mint = mint.mul(10 ** (_magnitudeMult));\n\n            mint = mint.add(mintDec);\n\n        }\n\n\n\n        return mint;\n",
                    "message": "Function 'ParseIntScientific._parseIntScientific' (oracle.sol#957-1074) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientific(string _inString, uint _magnitudeMult) internal pure returns (uint) {\n",
                    "message": "Parameter '_inString' of ParseIntScientific._parseIntScientific (oracle.sol#957) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientific(string _inString, uint _magnitudeMult) internal pure returns (uint) {\n",
                    "message": "Parameter '_magnitudeMult' of ParseIntScientific._parseIntScientific (oracle.sol#957) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1133,
                    "vulnerability_to_line": 1810,
                    "vulnerability_code": "library strings {\n\n    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n\n    }\n\n\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire string.\n\n     * @param self The string to make a slice from.\n\n     * @return A newly allocated slice containing the entire string.\n\n     */\n\n    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length of a null-terminated bytes32 string.\n\n     * @param self The value to find the length of.\n\n     * @return The length of the string, from 0 to 32.\n\n     */\n\n    function len(bytes32 self) internal pure returns (uint) {\n\n        uint ret;\n\n        if (self == 0)\n\n            return 0;\n\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n\n            ret += 16;\n\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n\n        }\n\n        if (self & 0xffffffffffffffff == 0) {\n\n            ret += 8;\n\n            self = bytes32(uint(self) / 0x10000000000000000);\n\n        }\n\n        if (self & 0xffffffff == 0) {\n\n            ret += 4;\n\n            self = bytes32(uint(self) / 0x100000000);\n\n        }\n\n        if (self & 0xffff == 0) {\n\n            ret += 2;\n\n            self = bytes32(uint(self) / 0x10000);\n\n        }\n\n        if (self & 0xff == 0) {\n\n            ret += 1;\n\n        }\n\n        return 32 - ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n\n     *      null-terminated utf-8 string.\n\n     * @param self The bytes32 value to convert to a slice.\n\n     * @return A new slice containing the value of the input argument up to the\n\n     *         first null.\n\n     */\n\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a new slice containing the same data as the current slice.\n\n     * @param self The slice to copy.\n\n     * @return A new slice containing the same data as `self`.\n\n     */\n\n    function copy(slice memory self) internal pure returns (slice memory) {\n\n        return slice(self._len, self._ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Copies a slice to a new string.\n\n     * @param self The slice to copy.\n\n     * @return A newly allocated string containing the slice's text.\n\n     */\n\n    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length in runes of the slice. Note that this operation\n\n     *      takes time proportional to the length of the slice; avoid using it\n\n     *      in loops, and call `slice.empty()` if you only need to know whether\n\n     *      the slice is empty or not.\n\n     * @param self The slice to operate on.\n\n     * @return The length of the slice in runes.\n\n     */\n\n    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice is empty (has a length of 0).\n\n     * @param self The slice to operate on.\n\n     * @return True if the slice is empty, False otherwise.\n\n     */\n\n    function empty(slice memory self) internal pure returns (bool) {\n\n        return self._len == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a positive number if `other` comes lexicographically after\n\n     *      `self`, a negative number if it comes before, or zero if the\n\n     *      contents of the two slices are equal. Comparison is done per-rune,\n\n     *      on unicode codepoints.\n\n     * @param self The first slice to compare.\n\n     * @param other The second slice to compare.\n\n     * @return The result of the comparison.\n\n     */\n\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the two slices contain the same text.\n\n     * @param self The first slice to compare.\n\n     * @param self The second slice to compare.\n\n     * @return True if the slices are equal, false otherwise.\n\n     */\n\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n\n        return compare(self, other) == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n\n     *      slice to point to the next rune and returning `self`.\n\n     * @param self The slice to operate on.\n\n     * @param rune The slice that will contain the first rune.\n\n     * @return `rune`.\n\n     */\n\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the first rune in the slice, advancing the slice to point\n\n     *      to the next rune.\n\n     * @param self The slice to operate on.\n\n     * @return A slice containing only the first rune from `self`.\n\n     */\n\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n\n        nextRune(self, ret);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the number of the first codepoint in the slice.\n\n     * @param self The slice to operate on.\n\n     * @return The number of the first codepoint in the slice.\n\n     */\n\n    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the keccak-256 hash of the slice.\n\n     * @param self The slice to hash.\n\n     * @return The hash of the slice.\n\n     */\n\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if `self` starts with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice ends with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n\n     *      end of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    // Returns the memory address of the first byte of the first occurrence of\n\n    // `needle` in `self`, or the first byte after `self` if not found.\n\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n\n    }\n\n\n\n    // Returns the memory address of the first byte after the last occurrence of\n\n    // `needle` in `self`, or the address of `self` if not found.\n\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain everything from the first occurrence of\n\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n\n     *      if `needle` is not found.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len -= ptr - self._ptr;\n\n        self._ptr = ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain the part of the string from the start of\n\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n\n     *      is not found, `self` is set to the empty slice.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len = ptr - self._ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and `token` to everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = self._ptr;\n\n        token._len = ptr - self._ptr;\n\n        if (ptr == self._ptr + self._len) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n            self._ptr = ptr + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and returning everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` up to the first occurrence of `delim`.\n\n     */\n\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        split(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and `token` to everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = ptr;\n\n        token._len = self._len - (ptr - self._ptr);\n\n        if (ptr == self._ptr) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and returning everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` after the last occurrence of `delim`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        rsplit(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The number of occurrences of `needle` found in `self`.\n\n     */\n\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n\n        while (ptr <= self._ptr + self._len) {\n\n            cnt++;\n\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns True if `self` contains `needle`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return True if `needle` is found in `self`, false otherwise.\n\n     */\n\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a newly allocated string containing the concatenation of\n\n     *      `self` and `other`.\n\n     * @param self The first slice to concatenate.\n\n     * @param other The second slice to concatenate.\n\n     * @return The concatenation of the two strings.\n\n     */\n\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n\n     *      newly allocated string.\n\n     * @param self The delimiter to use.\n\n     * @param parts A list of slices to join.\n\n     * @return A newly allocated string containing all the slices in `parts`,\n\n     *         joined with `self`.\n\n     */\n\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n\n    }\n",
                    "message": "Contract 'strings' (oracle.sol#1133-1810) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1134,
                    "vulnerability_to_line": 1137,
                    "vulnerability_code": "    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n",
                    "message": "Struct 'strings.slice' (oracle.sol#1134-1137) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address) external view returns (string, uint256, uint256, bool, bool, bool, uint256);\n",
                    "message": "Parameter '' of ITokenWhitelist.getTokenInfo (oracle.sol#1840) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '' of ITokenWhitelist.updateTokenRate (oracle.sol#1843) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_0' of ITokenWhitelist.updateTokenRate (oracle.sol#1843) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_1' of ITokenWhitelist.updateTokenRate (oracle.sol#1843) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_oracleNameHash_' of TokenWhitelist. (oracle.sol#1886) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_stabelcoinAddress_' of TokenWhitelist. (oracle.sol#1886) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.addTokens (oracle.sol#1898) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_symbols' of TokenWhitelist.addTokens (oracle.sol#1898) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_magnitude' of TokenWhitelist.addTokens (oracle.sol#1898) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_loadable' of TokenWhitelist.addTokens (oracle.sol#1898) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_burnable' of TokenWhitelist.addTokens (oracle.sol#1898) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_lastUpdate' of TokenWhitelist.addTokens (oracle.sol#1898) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1926,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokens(address[] _tokens) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.removeTokens (oracle.sol#1926) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_token' of TokenWhitelist.updateTokenRate (oracle.sol#1952) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_rate' of TokenWhitelist.updateTokenRate (oracle.sol#1952) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1952,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelist.updateTokenRate (oracle.sol#1952) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of TokenWhitelist.claim (oracle.sol#1964) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of TokenWhitelist.claim (oracle.sol#1964) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1964,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of TokenWhitelist.claim (oracle.sol#1964) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1977,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address _a) external view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelist.getTokenInfo (oracle.sol#1977) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
                    "message": "Parameter '_tokenWhitelistNameHash_' of TokenWhitelistable. (oracle.sol#2045) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2064,
                    "vulnerability_to_line": 2066,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\n",
                    "message": "Function 'TokenWhitelistable._getTokenInfo' (oracle.sol#2064-2066) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._getTokenInfo (oracle.sol#2064) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2076,
                    "vulnerability_to_line": 2078,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\n",
                    "message": "Function 'TokenWhitelistable._getStablecoinInfo' (oracle.sol#2076-2078) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": 2084,
                    "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\n",
                    "message": "Function 'TokenWhitelistable._tokenAddressArray' (oracle.sol#2082-2084) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2090,
                    "vulnerability_to_line": 2092,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\n",
                    "message": "Function 'TokenWhitelistable._updateTokenRate' (oracle.sol#2090-2092) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2090,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_token' of TokenWhitelistable._updateTokenRate (oracle.sol#2090) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2090,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_rate' of TokenWhitelistable._updateTokenRate (oracle.sol#2090) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2090,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelistable._updateTokenRate (oracle.sol#2090) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2096,
                    "vulnerability_to_line": 2099,
                    "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\n\n        return available;\n",
                    "message": "Function 'TokenWhitelistable._isTokenAvailable' (oracle.sol#2096-2099) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2096,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenAvailable (oracle.sol#2096) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2103,
                    "vulnerability_to_line": 2106,
                    "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n\n        ( , , , , , bool burnable, ) = _getTokenInfo(_a);\n\n        return burnable;\n",
                    "message": "Function 'TokenWhitelistable._isTokenBurnable' (oracle.sol#2103-2106) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2103,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenBurnable (oracle.sol#2103) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2110,
                    "vulnerability_to_line": 2113,
                    "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\n\n        return loadable;\n",
                    "message": "Function 'TokenWhitelistable._isTokenLoadable' (oracle.sol#2110-2113) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenLoadable (oracle.sol#2110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2117,
                    "vulnerability_to_line": 2119,
                    "vulnerability_code": "    function _stablecoin() internal view returns (address) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\n",
                    "message": "Function 'TokenWhitelistable._stablecoin' (oracle.sol#2117-2119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.query_withGasLimit' (oracle.sol#2163) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.query2_withGasLimit' (oracle.sol#2165) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2167,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.queryN_withGasLimit' (oracle.sol#2167) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n",
                    "message": "Function 'OraclizeI.randomDS_getSessionPubKeyHash' (oracle.sol#2172) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2208,
                    "vulnerability_to_line": 2211,
                    "vulnerability_code": "    struct buffer {\n\n        bytes buf;\n\n        uint capacity;\n",
                    "message": "Struct 'Buffer.buffer' (oracle.sol#2208-2211) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n",
                    "message": "Parameter '_capacity' of Buffer.init (oracle.sol#2213) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2411,
                    "vulnerability_to_line": 3358,
                    "vulnerability_code": "contract usingOraclize {\n\n    uint constant day = 60*60*24;\n\n    uint constant week = 60*60*24*7;\n\n    uint constant month = 60*60*24*30;\n\n    byte constant proofType_NONE = 0x00;\n\n    byte constant proofType_TLSNotary = 0x10;\n\n    byte constant proofType_Ledger = 0x30;\n\n    byte constant proofType_Android = 0x40;\n\n    byte constant proofType_Native = 0xF0;\n\n    byte constant proofStorage_IPFS = 0x01;\n\n    uint8 constant networkID_auto = 0;\n\n    uint8 constant networkID_mainnet = 1;\n\n    uint8 constant networkID_testnet = 2;\n\n    uint8 constant networkID_morden = 2;\n\n    uint8 constant networkID_consensys = 161;\n\n\n\n    OraclizeAddrResolverI OAR;\n\n\n\n    OraclizeI oraclize;\n\n    modifier oraclizeAPI {\n\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\n            oraclize_setNetwork(networkID_auto);\n\n\n\n        if(address(oraclize) != OAR.getAddress())\n\n            oraclize = OraclizeI(OAR.getAddress());\n\n\n\n        _;\n\n    }\n\n    modifier coupon(string code){\n\n        oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n\n    }\n\n\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\n      return oraclize_setNetwork();\n\n      networkID; // silence the warning and remain backwards compatible\n\n    }\n\n    function oraclize_setNetwork() internal returns(bool){\n\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\n            oraclize_setNetworkName(\"eth_mainnet\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\n            oraclize_setNetworkName(\"eth_ropsten3\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\n            oraclize_setNetworkName(\"eth_kovan\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\n            oraclize_setNetworkName(\"eth_rinkeby\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\n            return true;\n\n        }\n\n        return false;\n\n    }\n\n\n\n    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n\n    }\n\n    function __callback(bytes32 myid, string result, bytes proof) public {\n\n      return;\n\n      // Following should never be reached with a preceding return, however\n\n      // this is just a placeholder function, ideally meant to be defined in\n\n      // child contract when proofs are used\n\n      myid; result; proof; // Silence compiler warnings\n\n      oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view. \n\n    }\n\n\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource);\n\n    }\n\n\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(0, datasource, arg);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n\n        return oraclize.cbAddress();\n\n    }\n\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n\n        return oraclize.setProofType(proofP);\n\n    }\n\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\n        return oraclize.setCustomGasPrice(gasPrice);\n\n    }\n\n\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\n        return oraclize.randomDS_getSessionPubKeyHash();\n\n    }\n\n\n\n    function getCodeSize(address _addr) view internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n\n    }\n\n\n\n    function parseAddr(string _a) internal pure returns (address){\n\n        bytes memory tmp = bytes(_a);\n\n        uint160 iaddr = 0;\n\n        uint160 b1;\n\n        uint160 b2;\n\n        for (uint i=2; i<2+2*20; i+=2){\n\n            iaddr *= 256;\n\n            b1 = uint160(tmp[i]);\n\n            b2 = uint160(tmp[i+1]);\n\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n\n            iaddr += (b1*16+b2);\n\n        }\n\n        return address(iaddr);\n\n    }\n\n\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n\n        bytes memory a = bytes(_a);\n\n        bytes memory b = bytes(_b);\n\n        uint minLength = a.length;\n\n        if (b.length < minLength) minLength = b.length;\n\n        for (uint i = 0; i < minLength; i ++)\n\n            if (a[i] < b[i])\n\n                return -1;\n\n            else if (a[i] > b[i])\n\n                return 1;\n\n        if (a.length < b.length)\n\n            return -1;\n\n        else if (a.length > b.length)\n\n            return 1;\n\n        else\n\n            return 0;\n\n    }\n\n\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n\n        bytes memory h = bytes(_haystack);\n\n        bytes memory n = bytes(_needle);\n\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n\n            return -1;\n\n        else if(h.length > (2**128 -1))\n\n            return -1;\n\n        else\n\n        {\n\n            uint subindex = 0;\n\n            for (uint i = 0; i < h.length; i ++)\n\n            {\n\n                if (h[i] == n[0])\n\n                {\n\n                    subindex = 1;\n\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n\n                    {\n\n                        subindex++;\n\n                    }\n\n                    if(subindex == n.length)\n\n                        return int(i);\n\n                }\n\n            }\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n\n        bytes memory _ba = bytes(_a);\n\n        bytes memory _bb = bytes(_b);\n\n        bytes memory _bc = bytes(_c);\n\n        bytes memory _bd = bytes(_d);\n\n        bytes memory _be = bytes(_e);\n\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n\n        bytes memory babcde = bytes(abcde);\n\n        uint k = 0;\n\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n\n        return string(babcde);\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n\n        return strConcat(_a, _b, _c, _d, \"\");\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n\n        return strConcat(_a, _b, _c, \"\", \"\");\n\n    }\n\n\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n\n        return strConcat(_a, _b, \"\", \"\", \"\");\n\n    }\n\n\n\n    // parseInt\n\n    function parseInt(string _a) internal pure returns (uint) {\n\n        return parseInt(_a, 0);\n\n    }\n\n\n\n    // parseInt(parseFloat*10^_b)\n\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n\n        bytes memory bresult = bytes(_a);\n\n        uint mint = 0;\n\n        bool decimals = false;\n\n        for (uint i=0; i<bresult.length; i++){\n\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n\n                if (decimals){\n\n                   if (_b == 0) break;\n\n                    else _b--;\n\n                }\n\n                mint *= 10;\n\n                mint += uint(bresult[i]) - 48;\n\n            } else if (bresult[i] == 46) decimals = true;\n\n        }\n\n        if (_b > 0) mint *= 10**_b;\n\n        return mint;\n\n    }\n\n\n\n    function uint2str(uint i) internal pure returns (string){\n\n        if (i == 0) return \"0\";\n\n        uint j = i;\n\n        uint len;\n\n        while (j != 0){\n\n            len++;\n\n            j /= 10;\n\n        }\n\n        bytes memory bstr = new bytes(len);\n\n        uint k = len - 1;\n\n        while (i != 0){\n\n            bstr[k--] = byte(48 + i % 10);\n\n            i /= 10;\n\n        }\n\n        return string(bstr);\n\n    }\n\n\n\n    using CBOR for Buffer.buffer;\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n\n        safeMemoryCleaner();\n\n        Buffer.buffer memory buf;\n\n        Buffer.init(buf, 1024);\n\n        buf.startArray();\n\n        for (uint i = 0; i < arr.length; i++) {\n\n            buf.encodeString(arr[i]);\n\n        }\n\n        buf.endSequence();\n\n        return buf.buf;\n\n    }\n\n\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n\n        safeMemoryCleaner();\n\n        Buffer.buffer memory buf;\n\n        Buffer.init(buf, 1024);\n\n        buf.startArray();\n\n        for (uint i = 0; i < arr.length; i++) {\n\n            buf.encodeBytes(arr[i]);\n\n        }\n\n        buf.endSequence();\n\n        return buf.buf;\n\n    }\n\n\n\n    string oraclize_network_name;\n\n    function oraclize_setNetworkName(string _network_name) internal {\n\n        oraclize_network_name = _network_name;\n\n    }\n\n\n\n    function oraclize_getNetworkName() internal view returns (string) {\n\n        return oraclize_network_name;\n\n    }\n\n\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n\n    }\n\n\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\n        oraclize_randomDS_args[queryId] = commitment;\n\n    }\n\n\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\n        bool sigok;\n\n        address signer;\n\n\n\n        bytes32 sigr;\n\n        bytes32 sigs;\n\n\n\n        bytes memory sigr_ = new bytes(32);\n\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\n        bytes memory sigs_ = new bytes(32);\n\n        offset += 32 + 2;\n\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\n\n        assembly {\n\n            sigr := mload(add(sigr_, 32))\n\n            sigs := mload(add(sigs_, 32))\n\n        }\n\n\n\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\n        if (address(keccak256(pubkey)) == signer) return true;\n\n        else {\n\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\n            return (address(keccak256(pubkey)) == signer);\n\n        }\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\n        bool sigok;\n\n\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\n\n        bytes memory appkey1_pubkey = new bytes(64);\n\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\n\n        bytes memory tosign2 = new bytes(1+65+32);\n\n        tosign2[0] = byte(1); //role\n\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\n\n        if (sigok == false) return false;\n\n\n\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\n\n        bytes memory tosign3 = new bytes(1+65);\n\n        tosign3[0] = 0xFE;\n\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\n\n        return sigok;\n\n    }\n\n\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        require(proofVerified);\n\n\n\n        _;\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        if (proofVerified == false) return 2;\n\n\n\n        return 0;\n\n    }\n\n\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n\n        bool match_ = true;\n\n\n\n        require(prefix.length == n_random_bytes);\n\n\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n\n            if (content[i] != prefix[i]) match_ = false;\n\n        }\n\n\n\n        return match_;\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\n        bytes memory keyhash = new bytes(32);\n\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\n\n\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\n        // This is to verify that the computed args match with the ones specified in the query.\n\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\n\n        bytes memory sessionPubkey = new bytes(64);\n\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\n\n            delete oraclize_randomDS_args[queryId];\n\n        } else return false;\n\n\n\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\n        bytes memory tosign1 = new bytes(32+8+1+32);\n\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\n        }\n\n\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        if (sig.length != 65)\n\n          return (false, 0);\n\n\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n\n            // 'mload' will pad with zeroes if we overread.\n\n            // There is no 'mload8' to do this, but that would be nicer.\n\n            v := byte(0, mload(add(sig, 96)))\n\n\n\n            // Alternative solution:\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            // v := and(mload(add(sig, 65)), 255)\n\n        }\n\n\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n\n        // to match the YP range of [27, 28]\n\n        //\n\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n\n        if (v < 27)\n\n          v += 27;\n\n\n\n        if (v != 27 && v != 28)\n\n            return (false, 0);\n\n\n\n        return safer_ecrecover(hash, v, r, s);\n\n    }\n\n\n\n    function safeMemoryCleaner() internal pure {\n\n        assembly {\n\n            let fmem := mload(0x40)\n\n            codecopy(fmem, codesize, sub(msize, fmem))\n\n        }\n\n    }\n\n\n",
                    "message": "Contract 'usingOraclize' (oracle.sol#2411-3358) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2444,
                    "vulnerability_to_line": 2447,
                    "vulnerability_code": "    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\n      return oraclize_setNetwork();\n\n      networkID; // silence the warning and remain backwards compatible\n",
                    "message": "Function 'usingOraclize.oraclize_setNetwork' (oracle.sol#2444-2447) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2448,
                    "vulnerability_to_line": 2482,
                    "vulnerability_code": "    function oraclize_setNetwork() internal returns(bool){\n\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\n            oraclize_setNetworkName(\"eth_mainnet\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\n            oraclize_setNetworkName(\"eth_ropsten3\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\n            oraclize_setNetworkName(\"eth_kovan\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\n            oraclize_setNetworkName(\"eth_rinkeby\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\n            return true;\n\n        }\n\n        return false;\n",
                    "message": "Function 'usingOraclize.oraclize_setNetwork' (oracle.sol#2448-2482) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2484,
                    "vulnerability_to_line": 2486,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n",
                    "message": "Function 'usingOraclize.__callback' (oracle.sol#2484-2486) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2487,
                    "vulnerability_to_line": 2494,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n\n      return;\n\n      // Following should never be reached with a preceding return, however\n\n      // this is just a placeholder function, ideally meant to be defined in\n\n      // child contract when proofs are used\n\n      myid; result; proof; // Silence compiler warnings\n\n      oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view. \n",
                    "message": "Function 'usingOraclize.__callback' (oracle.sol#2487-2494) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2496,
                    "vulnerability_to_line": 2498,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource);\n",
                    "message": "Function 'usingOraclize.oraclize_getPrice' (oracle.sol#2496-2498) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2500,
                    "vulnerability_to_line": 2502,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_getPrice' (oracle.sol#2500-2502) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2504,
                    "vulnerability_to_line": 2508,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(0, datasource, arg);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2504-2508) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2509,
                    "vulnerability_to_line": 2513,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2509-2513) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2514,
                    "vulnerability_to_line": 2518,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2514-2518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": 2523,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2519-2523) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2524,
                    "vulnerability_to_line": 2528,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2524-2528) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2529,
                    "vulnerability_to_line": 2533,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2529-2533) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2534,
                    "vulnerability_to_line": 2538,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2534-2538) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2539,
                    "vulnerability_to_line": 2543,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2539-2543) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2544,
                    "vulnerability_to_line": 2549,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2544-2549) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2550,
                    "vulnerability_to_line": 2555,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2550-2555) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2556,
                    "vulnerability_to_line": 2561,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2556-2561) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": 2567,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2562-2567) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2568,
                    "vulnerability_to_line": 2572,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2568-2572) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2573,
                    "vulnerability_to_line": 2577,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2573-2577) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": 2582,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2578-2582) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2583,
                    "vulnerability_to_line": 2587,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2583-2587) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2589,
                    "vulnerability_to_line": 2594,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2589-2594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2595,
                    "vulnerability_to_line": 2600,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2595-2600) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2601,
                    "vulnerability_to_line": 2606,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2601-2606) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2607,
                    "vulnerability_to_line": 2612,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2607-2612) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2613,
                    "vulnerability_to_line": 2619,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2613-2619) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": 2626,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2620-2626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2627,
                    "vulnerability_to_line": 2633,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2627-2633) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2634,
                    "vulnerability_to_line": 2640,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2634-2640) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2642,
                    "vulnerability_to_line": 2649,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2642-2649) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2650,
                    "vulnerability_to_line": 2657,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2650-2657) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2658,
                    "vulnerability_to_line": 2665,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2658-2665) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2666,
                    "vulnerability_to_line": 2673,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2666-2673) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2674,
                    "vulnerability_to_line": 2682,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2674-2682) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2683,
                    "vulnerability_to_line": 2691,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2683-2691) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2692,
                    "vulnerability_to_line": 2700,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2692-2700) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2701,
                    "vulnerability_to_line": 2709,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2701-2709) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2710,
                    "vulnerability_to_line": 2715,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2710-2715) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2716,
                    "vulnerability_to_line": 2721,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2716-2721) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2722,
                    "vulnerability_to_line": 2727,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2722-2727) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2728,
                    "vulnerability_to_line": 2733,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2728-2733) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2734,
                    "vulnerability_to_line": 2738,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2734-2738) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2739,
                    "vulnerability_to_line": 2743,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2739-2743) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2744,
                    "vulnerability_to_line": 2748,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2744-2748) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2749,
                    "vulnerability_to_line": 2753,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2749-2753) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2755,
                    "vulnerability_to_line": 2760,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2755-2760) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2761,
                    "vulnerability_to_line": 2766,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2761-2766) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2767,
                    "vulnerability_to_line": 2772,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2767-2772) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": 2778,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2773-2778) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2779,
                    "vulnerability_to_line": 2785,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2779-2785) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2786,
                    "vulnerability_to_line": 2792,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2786-2792) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2793,
                    "vulnerability_to_line": 2799,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2793-2799) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2800,
                    "vulnerability_to_line": 2806,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2800-2806) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2808,
                    "vulnerability_to_line": 2815,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2808-2815) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2816,
                    "vulnerability_to_line": 2823,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2816-2823) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2824,
                    "vulnerability_to_line": 2831,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2824-2831) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2832,
                    "vulnerability_to_line": 2839,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2832-2839) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2840,
                    "vulnerability_to_line": 2848,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2840-2848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2849,
                    "vulnerability_to_line": 2857,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2849-2857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2858,
                    "vulnerability_to_line": 2866,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2858-2866) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2867,
                    "vulnerability_to_line": 2875,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oracle.sol#2867-2875) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2877,
                    "vulnerability_to_line": 2879,
                    "vulnerability_code": "    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n\n        return oraclize.cbAddress();\n",
                    "message": "Function 'usingOraclize.oraclize_cbAddress' (oracle.sol#2877-2879) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2880,
                    "vulnerability_to_line": 2882,
                    "vulnerability_code": "    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n\n        return oraclize.setProofType(proofP);\n",
                    "message": "Function 'usingOraclize.oraclize_setProof' (oracle.sol#2880-2882) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2883,
                    "vulnerability_to_line": 2885,
                    "vulnerability_code": "    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\n        return oraclize.setCustomGasPrice(gasPrice);\n",
                    "message": "Function 'usingOraclize.oraclize_setCustomGasPrice' (oracle.sol#2883-2885) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2887,
                    "vulnerability_to_line": 2889,
                    "vulnerability_code": "    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\n        return oraclize.randomDS_getSessionPubKeyHash();\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_getSessionPubKeyHash' (oracle.sol#2887-2889) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2897,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseAddr(string _a) internal pure returns (address){\n",
                    "message": "Parameter '_a' of usingOraclize.parseAddr (oracle.sol#2897) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": "Parameter '_a' of usingOraclize.strCompare (oracle.sol#2917) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": "Parameter '_b' of usingOraclize.strCompare (oracle.sol#2917) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": "Parameter '_haystack' of usingOraclize.indexOf (oracle.sol#2935) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": "Parameter '_needle' of usingOraclize.indexOf (oracle.sol#2935) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oracle.sol#2962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oracle.sol#2962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (oracle.sol#2962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_d' of usingOraclize.strConcat (oracle.sol#2962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_e' of usingOraclize.strConcat (oracle.sol#2962) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oracle.sol#2979) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oracle.sol#2979) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (oracle.sol#2979) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_d' of usingOraclize.strConcat (oracle.sol#2979) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oracle.sol#2983) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oracle.sol#2983) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (oracle.sol#2983) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2987,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oracle.sol#2987) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2987,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oracle.sol#2987) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a) internal pure returns (uint) {\n",
                    "message": "Parameter '_a' of usingOraclize.parseInt (oracle.sol#2992) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": "Parameter '_a' of usingOraclize.parseInt (oracle.sol#2997) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": "Parameter '_b' of usingOraclize.parseInt (oracle.sol#2997) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3058,
                    "vulnerability_to_line": 3060,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n\n        oraclize_network_name = _network_name;\n",
                    "message": "Function 'usingOraclize.oraclize_setNetworkName' (oracle.sol#3058-3060) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n",
                    "message": "Parameter '_network_name' of usingOraclize.oraclize_setNetworkName (oracle.sol#3058) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3062,
                    "vulnerability_to_line": 3064,
                    "vulnerability_code": "    function oraclize_getNetworkName() internal view returns (string) {\n\n        return oraclize_network_name;\n",
                    "message": "Function 'usingOraclize.oraclize_getNetworkName' (oracle.sol#3062-3064) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3066,
                    "vulnerability_to_line": 3112,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n",
                    "message": "Function 'usingOraclize.oraclize_newRandomDSQuery' (oracle.sol#3066-3112) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_delay' of usingOraclize.oraclize_newRandomDSQuery (oracle.sol#3066) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_nbytes' of usingOraclize.oraclize_newRandomDSQuery (oracle.sol#3066) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3066,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_customGasLimit' of usingOraclize.oraclize_newRandomDSQuery (oracle.sol#3066) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3114,
                    "vulnerability_to_line": 3116,
                    "vulnerability_code": "    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\n        oraclize_randomDS_args[queryId] = commitment;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_setCommitment' (oracle.sol#3114-3116) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3149,
                    "vulnerability_to_line": 3182,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\n        bool sigok;\n\n\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\n\n        bytes memory appkey1_pubkey = new bytes(64);\n\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\n\n        bytes memory tosign2 = new bytes(1+65+32);\n\n        tosign2[0] = byte(1); //role\n\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\n\n        if (sigok == false) return false;\n\n\n\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\n\n        bytes memory tosign3 = new bytes(1+65);\n\n        tosign3[0] = 0xFE;\n\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\n\n        return sigok;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity' (oracle.sol#3149-3182) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3194,
                    "vulnerability_to_line": 3202,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        if (proofVerified == false) return 2;\n\n\n\n        return 0;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__returnCode' (oracle.sol#3194-3202) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_queryId' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (oracle.sol#3194) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_result' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (oracle.sol#3194) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_proof' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (oracle.sol#3194) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n",
                    "message": "Parameter 'n_random_bytes' of usingOraclize.matchBytes32Prefix (oracle.sol#3204) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3216,
                    "vulnerability_to_line": 3256,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\n        bytes memory keyhash = new bytes(32);\n\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\n\n\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\n        // This is to verify that the computed args match with the ones specified in the query.\n\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\n\n        bytes memory sessionPubkey = new bytes(64);\n\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\n\n            delete oraclize_randomDS_args[queryId];\n\n        } else return false;\n\n\n\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\n        bytes memory tosign1 = new bytes(32+8+1+32);\n\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\n        }\n\n\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__main' (oracle.sol#3216-3256) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": "Parameter 'context_name' of usingOraclize.oraclize_randomDS_proofVerify__main (oracle.sol#3216) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3283,
                    "vulnerability_to_line": 3308,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n",
                    "message": "Function 'usingOraclize.safer_ecrecover' (oracle.sol#3283-3308) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": "Constant 'usingOraclize.day' (oracle.sol#2412) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant week = 60*60*24*7;\n",
                    "message": "Constant 'usingOraclize.week' (oracle.sol#2413) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant month = 60*60*24*30;\n",
                    "message": "Constant 'usingOraclize.month' (oracle.sol#2414) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": "Constant 'usingOraclize.proofType_NONE' (oracle.sol#2415) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": "Constant 'usingOraclize.proofType_TLSNotary' (oracle.sol#2416) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": "Constant 'usingOraclize.proofType_Ledger' (oracle.sol#2417) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x40;\n",
                    "message": "Constant 'usingOraclize.proofType_Android' (oracle.sol#2418) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": "Constant 'usingOraclize.proofType_Native' (oracle.sol#2419) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": "Constant 'usingOraclize.proofStorage_IPFS' (oracle.sol#2420) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_auto = 0;\n",
                    "message": "Constant 'usingOraclize.networkID_auto' (oracle.sol#2421) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_mainnet = 1;\n",
                    "message": "Constant 'usingOraclize.networkID_mainnet' (oracle.sol#2422) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_testnet = 2;\n",
                    "message": "Constant 'usingOraclize.networkID_testnet' (oracle.sol#2423) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_morden = 2;\n",
                    "message": "Constant 'usingOraclize.networkID_morden' (oracle.sol#2424) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_consensys = 161;\n",
                    "message": "Constant 'usingOraclize.networkID_consensys' (oracle.sol#2425) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeAddrResolverI OAR;\n",
                    "message": "Variable 'usingOraclize.OAR' (oracle.sol#2427) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string oraclize_network_name;\n",
                    "message": "Variable 'usingOraclize.oraclize_network_name' (oracle.sol#3057) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n",
                    "message": "Variable 'usingOraclize.oraclize_randomDS_args' (oracle.sol#3118) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n",
                    "message": "Variable 'usingOraclize.oraclize_randomDS_sessionKeysHashVerified' (oracle.sol#3119) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3184,
                    "vulnerability_to_line": 3192,
                    "vulnerability_code": "    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        require(proofVerified);\n\n\n\n        _;\n",
                    "message": "Modifier 'usingOraclize.oraclize_randomDS_proofVerify' (oracle.sol#3184-3192) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": 3423,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Function 'Base64._base64decode' (oracle.sol#3376-3423) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": "Parameter '_encoded' of Base64._base64decode (oracle.sol#3376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": 3568,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n\n        // Require that the caller is the Oraclize contract.\n\n        require(msg.sender == oraclize_cbAddress(), \"sender is not oraclize\");\n\n        // Use the query ID to find the matching token address.\n\n        address token = _queryToToken[_queryID];\n\n        require(token != address(0), \"queryID matches to address 0\");\n\n        // Get the corresponding token object.\n\n        ( , , , bool available, , , uint256 lastUpdate) = _getTokenInfo(token);\n\n        require(available, \"token must be available\");\n\n\n\n        bool valid;\n\n        uint timestamp;\n\n        (valid, timestamp) = _verifyProof(_result, _proof, cryptoCompareAPIPublicKey, lastUpdate);\n\n\n\n        // Require that the proof is valid.\n\n        if (valid) {\n\n            // Parse the JSON result to get the rate in wei.\n\n            uint256 parsedRate = _parseIntScientificWei(parseRate(_result));\n\n            // Set the update time of the token rate.\n\n            uint256 parsedLastUpdate = timestamp;\n\n            // Remove query from the list.\n\n            delete _queryToToken[_queryID];\n\n\n\n            _updateTokenRate(token, parsedRate, parsedLastUpdate);\n\n        }\n",
                    "message": "Function 'Oracle.__callback' (oracle.sol#3543-3568) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n",
                    "message": "Parameter '_queryID' of Oracle.__callback (oracle.sol#3543) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n",
                    "message": "Parameter '_result' of Oracle.__callback (oracle.sol#3543) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n",
                    "message": "Parameter '_proof' of Oracle.__callback (oracle.sol#3543) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _resolver_, address _ens_, bytes32 _controllerNameHash_, bytes32 _tokenWhitelistNameHash_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) TokenWhitelistable(_tokenWhitelistNameHash_) public {\n",
                    "message": "Parameter '_resolver_' of Oracle. (oracle.sol#3499) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3508,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateCryptoCompareAPIPublicKey(bytes _publicKey) external onlyController {\n",
                    "message": "Parameter '_publicKey' of Oracle.updateCryptoCompareAPIPublicKey (oracle.sol#3508) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3515,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setCustomGasPrice(uint _gasPrice) external onlyController {\n",
                    "message": "Parameter '_gasPrice' of Oracle.setCustomGasPrice (oracle.sol#3515) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3522,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRates(uint _gasLimit) external payable onlyController {\n",
                    "message": "Parameter '_gasLimit' of Oracle.updateTokenRates (oracle.sol#3522) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRatesList(uint _gasLimit, address[] _tokenList) external payable onlyController {\n",
                    "message": "Parameter '_gasLimit' of Oracle.updateTokenRatesList (oracle.sol#3529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRatesList(uint _gasLimit, address[] _tokenList) external payable onlyController {\n",
                    "message": "Parameter '_tokenList' of Oracle.updateTokenRatesList (oracle.sol#3529) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyController {\n",
                    "message": "Parameter '_to' of Oracle.claim (oracle.sol#3534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyController {\n",
                    "message": "Parameter '_asset' of Oracle.claim (oracle.sol#3534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyController {\n",
                    "message": "Parameter '_amount' of Oracle.claim (oracle.sol#3534) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseRate(string _json) internal pure returns (string) {\n",
                    "message": "Parameter '_json' of Oracle.parseRate (oracle.sol#3572) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3594,
                    "vulnerability_to_line": 3623,
                    "vulnerability_code": "    function _updateTokenRates(uint _gasLimit) private {\n\n        address[] memory tokenAddresses = _tokenAddressArray();\n\n        // Check if there are any existing tokens.\n\n        if (tokenAddresses.length == 0) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"no tokens\");\n\n            // Check if the contract has enough Ether to pay for the query.\n\n        } else if (oraclize_getPrice(\"URL\") * tokenAddresses.length > address(this).balance) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"insufficient balance\");\n\n        } else {\n\n            // Set up the cryptocompare API query strings.\n\n            strings.slice memory apiPrefix = \"https://min-api.cryptocompare.com/data/price?fsym=\".toSlice();\n\n            strings.slice memory apiSuffix = \"&tsyms=ETH&sign=true\".toSlice();\n\n\n\n            // Create a new oraclize query for each supported token.\n\n            for (uint i = 0; i < tokenAddresses.length; i++) {\n\n                // Store the token symbol used in the query.\n\n                (string memory symbol, , , , , , ) = _getTokenInfo(tokenAddresses[i]);\n\n\n\n                strings.slice memory sym = symbol.toSlice();\n\n                // Create a new oraclize query from the component strings.\n\n                bytes32 queryID = oraclize_query(\"URL\", apiPrefix.concat(sym).toSlice().concat(apiSuffix), _gasLimit);\n\n                // Store the query ID together with the associated token address.\n\n                _queryToToken[queryID] = tokenAddresses[i];\n\n                // Emit the query success event.\n\n                emit RequestedUpdate(sym.toString());\n\n            }\n\n        }\n",
                    "message": "Function 'Oracle._updateTokenRates' (oracle.sol#3594-3623) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRates(uint _gasLimit) private {\n",
                    "message": "Parameter '_gasLimit' of Oracle._updateTokenRates (oracle.sol#3594) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3628,
                    "vulnerability_to_line": 3657,
                    "vulnerability_code": "    function _updateTokenRatesList(uint _gasLimit, address[] _tokenList) private {\n\n        // Check if there are any existing tokens.\n\n        if (_tokenList.length == 0) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"empty token list\");\n\n        // Check if the contract has enough Ether to pay for the query.\n\n        } else if (oraclize_getPrice(\"URL\") * _tokenList.length > address(this).balance) {\n\n            // Emit a query failure event.\n\n            emit FailedUpdateRequest(\"insufficient balance\");\n\n        } else {\n\n            // Set up the cryptocompare API query strings.\n\n            strings.slice memory apiPrefix = \"https://min-api.cryptocompare.com/data/price?fsym=\".toSlice();\n\n            strings.slice memory apiSuffix = \"&tsyms=ETH&sign=true\".toSlice();\n\n\n\n            // Create a new oraclize query for each supported token.\n\n            for (uint i = 0; i < _tokenList.length; i++) {\n\n                //token must exist, revert if it doesn't\n\n                (string memory tokenSymbol, , , bool available , , , ) = _getTokenInfo(_tokenList[i]);\n\n                require(available, \"token must be available\");\n\n                // Store the token symbol used in the query.\n\n                strings.slice memory symbol = tokenSymbol.toSlice();\n\n                // Create a new oraclize query from the component strings.\n\n                bytes32 queryID = oraclize_query(\"URL\", apiPrefix.concat(symbol).toSlice().concat(apiSuffix), _gasLimit);\n\n                // Store the query ID together with the associated token address.\n\n                _queryToToken[queryID] = _tokenList[i];\n\n                // Emit the query success event.\n\n                emit RequestedUpdate(symbol.toString());\n\n            }\n\n        }\n",
                    "message": "Function 'Oracle._updateTokenRatesList' (oracle.sol#3628-3657) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRatesList(uint _gasLimit, address[] _tokenList) private {\n",
                    "message": "Parameter '_gasLimit' of Oracle._updateTokenRatesList (oracle.sol#3628) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRatesList(uint _gasLimit, address[] _tokenList) private {\n",
                    "message": "Parameter '_tokenList' of Oracle._updateTokenRatesList (oracle.sol#3628) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": 3717,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n\n\n\n        // expecting fixed length proofs\n\n        if (_proof.length != _PROOF_LEN) {\n\n            revert(\"invalid proof length\");\n\n        }\n\n\n\n        // proof should be 65 bytes long: R (32 bytes) + S (32 bytes) + v (1 byte)\n\n        if (uint(_proof[1]) != _ECDSA_SIG_LEN) {\n\n            revert(\"invalid signature length\");\n\n        }\n\n\n\n        bytes memory signature = new bytes(_ECDSA_SIG_LEN);\n\n\n\n        signature = copyBytes(_proof, 2, _ECDSA_SIG_LEN, signature, 0);\n\n\n\n        // Extract the headers, big endian encoding of headers length\n\n        if (uint(_proof[_ENCODING_BYTES + _ECDSA_SIG_LEN]) * _MAX_BYTE_SIZE + uint(_proof[_ENCODING_BYTES + _ECDSA_SIG_LEN + 1]) != _HEADERS_LEN) {\n\n            revert(\"invalid headers length\");\n\n        }\n\n\n\n        bytes memory headers = new bytes(_HEADERS_LEN);\n\n        headers = copyBytes(_proof, 2 * _ENCODING_BYTES + _ECDSA_SIG_LEN, _HEADERS_LEN, headers, 0);\n\n\n\n        // Check if the signature is valid and if the signer address is matching.\n\n        if (!_verifySignature(headers, signature, _publicKey)) {\n\n            revert(\"invalid signature\");\n\n        }\n\n\n\n        // Check if the date is valid.\n\n        bytes memory dateHeader = new bytes(20);\n\n        // keep only the relevant string(e.g. \"16 Nov 2018 16:22:18\")\n\n        dateHeader = copyBytes(headers, 11, 20, dateHeader, 0);\n\n\n\n        bool dateValid;\n\n        uint timestamp;\n\n        (dateValid, timestamp) = _verifyDate(string(dateHeader), _lastUpdate);\n\n\n\n        // Check whether the date returned is valid or not\n\n        if (!dateValid) {\n\n            revert(\"invalid date\");\n\n        }\n\n\n\n        // Check if the signed digest hash matches the result hash.\n\n        bytes memory digest = new bytes(_DIGEST_BASE64_LEN);\n\n        digest = copyBytes(headers, _DIGEST_OFFSET, _DIGEST_BASE64_LEN, digest, 0);\n\n\n\n        if (keccak256(abi.encodePacked(sha256(abi.encodePacked(_result)))) != keccak256(_base64decode(digest))) {\n\n            revert(\"result hash not matching\");\n\n        }\n\n\n\n        emit VerifiedProof(_publicKey, _result);\n\n        return (true, timestamp);\n",
                    "message": "Function 'Oracle._verifyProof' (oracle.sol#3664-3717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": "Parameter '_result' of Oracle._verifyProof (oracle.sol#3664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": "Parameter '_proof' of Oracle._verifyProof (oracle.sol#3664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": "Parameter '_publicKey' of Oracle._verifyProof (oracle.sol#3664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": "Parameter '_lastUpdate' of Oracle._verifyProof (oracle.sol#3664) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": 3730,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n\n        address signer;\n\n        bool signatureOK;\n\n\n\n        // Checks if the signature is valid by hashing the headers\n\n        (signatureOK, signer) = ecrecovery(sha256(_headers), _signature);\n\n        return signatureOK && signer == address(keccak256(_publicKey));\n",
                    "message": "Function 'Oracle._verifySignature' (oracle.sol#3723-3730) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n",
                    "message": "Parameter '_headers' of Oracle._verifySignature (oracle.sol#3723) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n",
                    "message": "Parameter '_signature' of Oracle._verifySignature (oracle.sol#3723) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n",
                    "message": "Parameter '_publicKey' of Oracle._verifySignature (oracle.sol#3723) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3735,
                    "vulnerability_to_line": 3766,
                    "vulnerability_code": "    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\n\n\n\n        // called by verifyProof(), _dateHeader is always a string of length = 20\n\n        assert(abi.encodePacked(_dateHeader).length == 20);\n\n\n\n        // Split the date string and get individual date components.\n\n        strings.slice memory date = _dateHeader.toSlice();\n\n        strings.slice memory timeDelimiter = \":\".toSlice();\n\n        strings.slice memory dateDelimiter = \" \".toSlice();\n\n\n\n        uint day = _parseIntScientific(date.split(dateDelimiter).toString());\n\n        require(day > 0 && day < 32, \"day error\");\n\n\n\n        uint month = _monthToNumber(date.split(dateDelimiter).toString());\n\n        require(month > 0 && month < 13, \"month error\");\n\n\n\n        uint year = _parseIntScientific(date.split(dateDelimiter).toString());\n\n        require(year > 2017 && year < 3000, \"year error\");\n\n\n\n        uint hour = _parseIntScientific(date.split(timeDelimiter).toString());\n\n        require(hour < 25, \"hour error\");\n\n\n\n        uint minute = _parseIntScientific(date.split(timeDelimiter).toString());\n\n        require(minute < 60, \"minute error\");\n\n\n\n        uint second = _parseIntScientific(date.split(timeDelimiter).toString());\n\n        require(second < 60, \"second error\");\n\n\n\n        uint timestamp = year * (10 ** 10) + month * (10 ** 8) + day * (10 ** 6) + hour * (10 ** 4) + minute * (10 ** 2) + second;\n\n\n\n        return (timestamp > _lastUpdate, timestamp);\n",
                    "message": "Function 'Oracle._verifyDate' (oracle.sol#3735-3766) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\n",
                    "message": "Parameter '_dateHeader' of Oracle._verifyDate (oracle.sol#3735) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 3735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\n",
                    "message": "Parameter '_lastUpdate' of Oracle._verifyDate (oracle.sol#3735) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": "usingOraclize.day (oracle.sol#2412) is never used in Oracle\nusingOraclize.week (oracle.sol#2413) is never used in Oracle\nusingOraclize.month (oracle.sol#2414) is never used in Oracle\nusingOraclize.proofType_NONE (oracle.sol#2415) is never used in Oracle\nusingOraclize.proofType_TLSNotary (oracle.sol#2416) is never used in Oracle\nusingOraclize.proofType_Ledger (oracle.sol#2417) is never used in Oracle\nusingOraclize.proofType_Android (oracle.sol#2418) is never used in Oracle\nusingOraclize.proofStorage_IPFS (oracle.sol#2420) is never used in Oracle\nusingOraclize.networkID_mainnet (oracle.sol#2422) is never used in Oracle\nusingOraclize.networkID_testnet (oracle.sol#2423) is never used in Oracle\nusingOraclize.networkID_morden (oracle.sol#2424) is never used in Oracle\nusingOraclize.networkID_consensys (oracle.sol#2425) is never used in Oracle\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2449,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2450,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2460,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2465,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2469,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2470,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2474,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2478,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1180,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1182,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1186,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1188,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1190,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1192,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1258,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF8) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1266,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xFC) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1405,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1406,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x1F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1408,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x07;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b = (word / divisor) & 0xFF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = (ret * 64) | (b & 0x3F);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2353,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2359,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x40;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 2420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 3129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint offset = 4+(uint(dersig[3]) - 0x20);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 3133,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 3173,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        tosign3[0] = 0xFE;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 2172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < inBytes.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2973,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 3643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < _tokenList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 2950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1381,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1699,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 2891,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < inBytes.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < minLength; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2971,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2972,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2973,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2974,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3001,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3038,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3050,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3610,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < tokenAddresses.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3643,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < _tokenList.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1625,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptr >= selfptr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1747,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (ptr <= self._ptr + self._len) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 2950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 3269,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (i < (32 + fromOffset + length)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 2160,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract OraclizeI {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 3457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Oracle is ENSResolvable, usingOraclize, Claimable, Base64, Date, Controllable, ParseIntScientific, TokenWhitelistable {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 762,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 843,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1131,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2034,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 2158,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.22;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _adminCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isController;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _controllerCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS private _ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _ensRegistry;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _controllerNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _JANUARY = keccak256(\"Jan\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _FEBRUARY = keccak256(\"Feb\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 771,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _MARCH = keccak256(\"Mar\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 772,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _APRIL = keccak256(\"Apr\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _MAY = keccak256(\"May\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 774,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _JUNE = keccak256(\"Jun\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _JULY = keccak256(\"Jul\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 776,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _AUGUST = keccak256(\"Aug\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 777,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _SEPTEMBER = keccak256(\"Sep\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 778,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _OCTOBER = keccak256(\"Oct\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 779,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _NOVEMBER = keccak256(\"Nov\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 780,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _DECEMBER = keccak256(\"Dec\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _PLUS_ASCII = byte(43); //decimal value of '+'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 937,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _DASH_ASCII = byte(45); //decimal value of '-'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 938,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _DOT_ASCII = byte(46); //decimal value of '.'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 939,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _ZERO_ASCII = byte(48); //decimal value of '0'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _NINE_ASCII = byte(57); //decimal value of '9'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 941,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _E_ASCII = byte(69); //decimal value of 'E'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 942,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant private _LOWERCASE_E_ASCII = byte(101); //decimal value of 'e'\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1868,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => Token) private _tokenInfoMap;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1869,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] private _tokenAddressArray;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1878,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _stablecoin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _oracleNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2041,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _tokenWhitelistNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_INT = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_BYTES = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2345,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_STRING = 3;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2346,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_MAP = 5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 2348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _PROOF_LEN = 165;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3480,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _ECDSA_SIG_LEN = 65;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3481,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _ENCODING_BYTES = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3482,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _HEADERS_LEN = _PROOF_LEN - 2 * _ENCODING_BYTES - _ECDSA_SIG_LEN; // 2 bytes encoding headers length + 2 for signature.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3483,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _DIGEST_BASE64_LEN = 44; //base64 encoding of the SHA256 hash (32-bytes) of the result: fixed length.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _DIGEST_OFFSET = _HEADERS_LEN - _DIGEST_BASE64_LEN; // the starting position of the result hash in the headers string.\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3486,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant private _MAX_BYTE_SIZE = 256; //for calculating length encoding\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3489,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _PREFIX_HASH = keccak256(\"{\\\"ETH\\\":\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 3492,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32 => address) private _queryToToken;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (month == _DECEMBER) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if ((inBytes[i] == _E_ASCII) || (inBytes[i] == _LOWERCASE_E_ASCII)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3667,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (_proof.length != _PROOF_LEN) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (uint(_proof[1]) != _ECDSA_SIG_LEN) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3681,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (uint(_proof[_ENCODING_BYTES + _ECDSA_SIG_LEN]) * _MAX_BYTE_SIZE + uint(_proof[_ENCODING_BYTES + _ECDSA_SIG_LEN + 1]) != _HEADERS_LEN) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3689,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_verifySignature(headers, signature, _publicKey)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3703,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!dateValid) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 3711,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (keccak256(abi.encodePacked(sha256(abi.encodePacked(_result)))) != keccak256(_base64decode(digest))) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 934,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 3459,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1139,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1163,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1209,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1251,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1339,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1390,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1439,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1477,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1506,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1558,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1599,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1770,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 2213,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 2293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(buffer memory buf, uint8 data) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 2318,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 3259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 3351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeMemoryCleaner() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 2891,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 2064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 2076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 3735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 2485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        __callback(myid, result, new bytes(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _monthToNumber(string _month) internal pure returns (uint8) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientific(string _inString) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 950,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientificWei(string _inString) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _parseIntScientific(string _inString, uint _magnitudeMult) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2076,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2082,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2164,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2166,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2168,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource) public returns (uint _dsprice);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2169,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2246,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2384,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2389,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeString(Buffer.buffer memory buf, string value) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2487,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2496,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2500,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2509,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2514,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2519,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2524,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2529,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2534,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2539,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2550,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2556,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2562,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2568,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2573,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2578,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2589,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2595,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2613,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2620,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2634,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2642,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2650,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2683,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2701,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2728,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2734,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2739,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2744,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2749,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2755,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2761,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2767,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2779,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2793,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2808,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2824,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2858,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2867,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2897,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseAddr(string _a) internal pure returns (address){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2917,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2962,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2979,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2983,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2987,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2987,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2987,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2992,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 2997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint2str(uint i) internal pure returns (string){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3033,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stra2cbor(string[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3033,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stra2cbor(string[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3045,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3058,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3062,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getNetworkName() internal view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3121,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3194,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3216,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3259,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3311,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3376,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3543,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseRate(string _json) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3572,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseRate(string _json) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3628,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRatesList(uint _gasLimit, address[] _tokenList) private {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3723,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 3735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1151,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1165,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1211,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { b := and(mload(ptr), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1350,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { word:= mload(mload(add(self, 32))) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1484,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1518,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1542,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1567,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1583,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1587,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1611,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1623,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1773,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1797,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2218,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2254,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2268,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2277,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 2324,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3075,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3085,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3097,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3270,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3322,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 3418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant week = 60*60*24*7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant month = 60*60*24*30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2418,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x40;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2419,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2420,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2421,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_auto = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_mainnet = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2423,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_testnet = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2424,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_morden = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2425,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_consensys = 161;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2427,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeAddrResolverI OAR;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 2429,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeI oraclize;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3057,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string oraclize_network_name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3118,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3119,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 3372,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant BASE64_DECODE_CHAR = hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\";\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/mocks/tokenWhitelistableExporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TokenWhitelist is ENSResolvable, Controllable, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (i < parts.length - 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ens = ensAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ensRegistry = _ensReg_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ens = ENS(_ensRegistry);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerNode = _controllerNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _oracleNode = _oracleNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _stablecoin = _stabelcoinAddress_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _tokenWhitelistNode = _tokenWhitelistNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1888,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  constructor(address _ens_, bytes32 _tokenWhitelistName_) ENSResolvable(_ens_) TokenWhitelistable(_tokenWhitelistName_) public {}\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenInfoMap[_tokens[i]] = Token({\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.push(_tokens[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delete _tokenInfoMap[token];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (_tokenAddressArray[j] == token) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require (_isController(msg.sender) || msg.sender == oracleAddress, \"either oracle or controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokenInfoMap[_token].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                data = record.abis[contentType];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (l = 0; ptr < end; l++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (idx = 0; idx <= selflen - needlelen; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            cnt++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_19"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Claimable._claim (tokenWhitelistableExporter.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (tokenWhitelistableExporter.sol#150)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 821,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy (tokenWhitelistableExporter.sol#804-821) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": 834,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice (tokenWhitelistableExporter.sol#828-834) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": 883,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 (tokenWhitelistableExporter.sol#874-883) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString (tokenWhitelistableExporter.sol#899-906) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len (tokenWhitelistableExporter.sol#916-937) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare (tokenWhitelistableExporter.sol#957-985) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune (tokenWhitelistableExporter.sol#1004-1038) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord (tokenWhitelistableExporter.sol#1055-1097) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak (tokenWhitelistableExporter.sol#1104-1108) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1133,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith (tokenWhitelistableExporter.sol#1116-1133) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1163,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond (tokenWhitelistableExporter.sol#1142-1163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith (tokenWhitelistableExporter.sol#1171-1190) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until (tokenWhitelistableExporter.sol#1199-1219) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr (tokenWhitelistableExporter.sol#1223-1260) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": 1300,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr (tokenWhitelistableExporter.sol#1264-1300) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": 1442,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat (tokenWhitelistableExporter.sol#1435-1442) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": 1474,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join (tokenWhitelistableExporter.sol#1452-1474) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint ret;\n",
                    "message": "ret in strings.len (tokenWhitelistableExporter.sol#842) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ tokenWhitelistableExporter.sol#361) shadows:\n\t- ENS.owner (function @ tokenWhitelistableExporter.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ tokenWhitelistableExporter.sol#362) shadows:\n\t- ENS.resolver (function @ tokenWhitelistableExporter.sol#366)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ tokenWhitelistableExporter.sol#363) shadows:\n\t- ENS.owner (function @ tokenWhitelistableExporter.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ tokenWhitelistableExporter.sol#364) shadows:\n\t- ENS.ttl (function @ tokenWhitelistableExporter.sol#367)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
                    "message": "PublicResolver.setAddr.addr (local variable @ tokenWhitelistableExporter.sol#464) shadows:\n\t- PublicResolver.addr (function @ tokenWhitelistableExporter.sol#617-619)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": "PublicResolver.setName.name (local variable @ tokenWhitelistableExporter.sol#499) shadows:\n\t- PublicResolver.name (function @ tokenWhitelistableExporter.sol#588-590)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": "strings.memcpy.len (local variable @ tokenWhitelistableExporter.sol#804) shadows:\n\t- strings.len (function @ tokenWhitelistableExporter.sol#841-865)\n\t- strings.len (function @ tokenWhitelistableExporter.sol#916-937)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 821,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy uses assembly (tokenWhitelistableExporter.sol#804-821)\n\t- tokenWhitelistableExporter.sol#807-810\n\t- tokenWhitelistableExporter.sol#816-821\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": 834,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice uses assembly (tokenWhitelistableExporter.sol#828-834)\n\t- tokenWhitelistableExporter.sol#830-833\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": 883,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 uses assembly (tokenWhitelistableExporter.sol#874-883)\n\t- tokenWhitelistableExporter.sol#876-882\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString uses assembly (tokenWhitelistableExporter.sol#899-906)\n\t- tokenWhitelistableExporter.sol#902-904\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len uses assembly (tokenWhitelistableExporter.sol#916-937)\n\t- tokenWhitelistableExporter.sol#922-923\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare uses assembly (tokenWhitelistableExporter.sol#957-985)\n\t- tokenWhitelistableExporter.sol#967-971\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune uses assembly (tokenWhitelistableExporter.sol#1004-1038)\n\t- tokenWhitelistableExporter.sol#1015-1016\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord uses assembly (tokenWhitelistableExporter.sol#1055-1097)\n\t- tokenWhitelistableExporter.sol#1065-1066\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak uses assembly (tokenWhitelistableExporter.sol#1104-1108)\n\t- tokenWhitelistableExporter.sol#1105-1108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1133,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith uses assembly (tokenWhitelistableExporter.sol#1116-1133)\n\t- tokenWhitelistableExporter.sol#1126-1132\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1163,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond uses assembly (tokenWhitelistableExporter.sol#1142-1163)\n\t- tokenWhitelistableExporter.sol#1149-1155\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith uses assembly (tokenWhitelistableExporter.sol#1171-1190)\n\t- tokenWhitelistableExporter.sol#1183-1189\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until uses assembly (tokenWhitelistableExporter.sol#1199-1219)\n\t- tokenWhitelistableExporter.sol#1207-1212\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr uses assembly (tokenWhitelistableExporter.sol#1223-1260)\n\t- tokenWhitelistableExporter.sol#1232-1234\n\t- tokenWhitelistableExporter.sol#1236-1238\n\t- tokenWhitelistableExporter.sol#1242-1243\n\t- tokenWhitelistableExporter.sol#1248-1250\n\t- tokenWhitelistableExporter.sol#1252-1253\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": 1300,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr uses assembly (tokenWhitelistableExporter.sol#1264-1300)\n\t- tokenWhitelistableExporter.sol#1272-1274\n\t- tokenWhitelistableExporter.sol#1276-1278\n\t- tokenWhitelistableExporter.sol#1282-1283\n\t- tokenWhitelistableExporter.sol#1288-1289\n\t- tokenWhitelistableExporter.sol#1292-1293\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": 1442,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat uses assembly (tokenWhitelistableExporter.sol#1435-1442)\n\t- tokenWhitelistableExporter.sol#1438-1439\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": 1474,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join uses assembly (tokenWhitelistableExporter.sol#1452-1474)\n\t- tokenWhitelistableExporter.sol#1462-1464\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": "Different versions of Solidity is used in tokenWhitelistableExporter.sol:\n\t- Version used: ['>=0.4.24', '^0.4.14', '^0.4.24', '^0.4.25']\n\t- tokenWhitelistableExporter.sol#21 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#105 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#135 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#179 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#344 declares pragma solidity>=0.4.24\n\t- tokenWhitelistableExporter.sol#401 declares pragma solidity^0.4.24\n\t- tokenWhitelistableExporter.sol#658 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#710 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#796 declares pragma solidity^0.4.14\n\t- tokenWhitelistableExporter.sol#1504 declares pragma solidity^0.4.24\n\t- tokenWhitelistableExporter.sol#1590 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#1792 declares pragma solidity^0.4.25\n\t- tokenWhitelistableExporter.sol#1883 declares pragma solidity^0.4.25\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (tokenWhitelistableExporter.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
                    "message": "PublicResolver.setAddr (tokenWhitelistableExporter.sol#464-467) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 480,
                    "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
                    "message": "PublicResolver.setContent (tokenWhitelistableExporter.sol#477-480) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
                    "message": "PublicResolver.setMultihash (tokenWhitelistableExporter.sol#488-491) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
                    "message": "PublicResolver.setName (tokenWhitelistableExporter.sol#499-502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
                    "message": "PublicResolver.setABI (tokenWhitelistableExporter.sol#512-518) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
                    "message": "PublicResolver.setPubkey (tokenWhitelistableExporter.sol#526-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
                    "message": "PublicResolver.setText (tokenWhitelistableExporter.sol#538-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
                    "message": "PublicResolver.text (tokenWhitelistableExporter.sol#549-551) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 561,
                    "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
                    "message": "PublicResolver.pubkey (tokenWhitelistableExporter.sol#559-561) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "PublicResolver.ABI (tokenWhitelistableExporter.sol#571-580) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 590,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
                    "message": "PublicResolver.name (tokenWhitelistableExporter.sol#588-590) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
                    "message": "PublicResolver.content (tokenWhitelistableExporter.sol#599-601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
                    "message": "PublicResolver.multihash (tokenWhitelistableExporter.sol#608-610) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": 619,
                    "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
                    "message": "PublicResolver.addr (tokenWhitelistableExporter.sol#617-619) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
                    "message": "PublicResolver.supportsInterface (tokenWhitelistableExporter.sol#626-635) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in tokenWhitelistableExporter.sol:\n\t- pragma solidity^0.4.14 (tokenWhitelistableExporter.sol#796): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (tokenWhitelistableExporter.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (tokenWhitelistableExporter.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (tokenWhitelistableExporter.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (tokenWhitelistableExporter.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (tokenWhitelistableExporter.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (tokenWhitelistableExporter.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (tokenWhitelistableExporter.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (tokenWhitelistableExporter.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (tokenWhitelistableExporter.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (tokenWhitelistableExporter.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (tokenWhitelistableExporter.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (tokenWhitelistableExporter.sol#147-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (tokenWhitelistableExporter.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (tokenWhitelistableExporter.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (tokenWhitelistableExporter.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address) external view returns (bool);\n",
                    "message": "Parameter '' of IController.isController (tokenWhitelistableExporter.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isController (tokenWhitelistableExporter.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.addAdmin (tokenWhitelistableExporter.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.removeAdmin (tokenWhitelistableExporter.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.addController (tokenWhitelistableExporter.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.removeController (tokenWhitelistableExporter.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isAdmin (tokenWhitelistableExporter.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._addAdmin' (tokenWhitelistableExporter.sol#272-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addAdmin (tokenWhitelistableExporter.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeAdmin' (tokenWhitelistableExporter.sol#283-288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeAdmin (tokenWhitelistableExporter.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": 299,
                    "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._addController' (tokenWhitelistableExporter.sol#291-299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addController (tokenWhitelistableExporter.sol#291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 307,
                    "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeController' (tokenWhitelistableExporter.sol#302-307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeController (tokenWhitelistableExporter.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of Controller.claim (tokenWhitelistableExporter.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of Controller.claim (tokenWhitelistableExporter.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of Controller.claim (tokenWhitelistableExporter.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "Function 'PublicResolver.ABI' (tokenWhitelistableExporter.sol#571-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
                    "message": "Modifier 'PublicResolver.only_owner' (tokenWhitelistableExporter.sol#445-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Parameter '_ensReg_' of ENSResolvable. (tokenWhitelistableExporter.sol#671) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 686,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n\n        return PublicResolver(_ens.resolver(_nodeHash)).addr(_nodeHash);\n",
                    "message": "Function 'ENSResolvable._ensResolve' (tokenWhitelistableExporter.sol#684-686) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n",
                    "message": "Parameter '_nodeHash' of ENSResolvable._ensResolve (tokenWhitelistableExporter.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Parameter '_controllerNameHash_' of Controllable. (tokenWhitelistableExporter.sol#720) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 738,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n",
                    "message": "Function 'Controllable._isController' (tokenWhitelistableExporter.sol#736-738) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n",
                    "message": "Parameter '_account' of Controllable._isController (tokenWhitelistableExporter.sol#736) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": 1475,
                    "vulnerability_code": "library strings {\n\n    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n\n    }\n\n\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire string.\n\n     * @param self The string to make a slice from.\n\n     * @return A newly allocated slice containing the entire string.\n\n     */\n\n    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length of a null-terminated bytes32 string.\n\n     * @param self The value to find the length of.\n\n     * @return The length of the string, from 0 to 32.\n\n     */\n\n    function len(bytes32 self) internal pure returns (uint) {\n\n        uint ret;\n\n        if (self == 0)\n\n            return 0;\n\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n\n            ret += 16;\n\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n\n        }\n\n        if (self & 0xffffffffffffffff == 0) {\n\n            ret += 8;\n\n            self = bytes32(uint(self) / 0x10000000000000000);\n\n        }\n\n        if (self & 0xffffffff == 0) {\n\n            ret += 4;\n\n            self = bytes32(uint(self) / 0x100000000);\n\n        }\n\n        if (self & 0xffff == 0) {\n\n            ret += 2;\n\n            self = bytes32(uint(self) / 0x10000);\n\n        }\n\n        if (self & 0xff == 0) {\n\n            ret += 1;\n\n        }\n\n        return 32 - ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n\n     *      null-terminated utf-8 string.\n\n     * @param self The bytes32 value to convert to a slice.\n\n     * @return A new slice containing the value of the input argument up to the\n\n     *         first null.\n\n     */\n\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a new slice containing the same data as the current slice.\n\n     * @param self The slice to copy.\n\n     * @return A new slice containing the same data as `self`.\n\n     */\n\n    function copy(slice memory self) internal pure returns (slice memory) {\n\n        return slice(self._len, self._ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Copies a slice to a new string.\n\n     * @param self The slice to copy.\n\n     * @return A newly allocated string containing the slice's text.\n\n     */\n\n    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length in runes of the slice. Note that this operation\n\n     *      takes time proportional to the length of the slice; avoid using it\n\n     *      in loops, and call `slice.empty()` if you only need to know whether\n\n     *      the slice is empty or not.\n\n     * @param self The slice to operate on.\n\n     * @return The length of the slice in runes.\n\n     */\n\n    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice is empty (has a length of 0).\n\n     * @param self The slice to operate on.\n\n     * @return True if the slice is empty, False otherwise.\n\n     */\n\n    function empty(slice memory self) internal pure returns (bool) {\n\n        return self._len == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a positive number if `other` comes lexicographically after\n\n     *      `self`, a negative number if it comes before, or zero if the\n\n     *      contents of the two slices are equal. Comparison is done per-rune,\n\n     *      on unicode codepoints.\n\n     * @param self The first slice to compare.\n\n     * @param other The second slice to compare.\n\n     * @return The result of the comparison.\n\n     */\n\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the two slices contain the same text.\n\n     * @param self The first slice to compare.\n\n     * @param self The second slice to compare.\n\n     * @return True if the slices are equal, false otherwise.\n\n     */\n\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n\n        return compare(self, other) == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n\n     *      slice to point to the next rune and returning `self`.\n\n     * @param self The slice to operate on.\n\n     * @param rune The slice that will contain the first rune.\n\n     * @return `rune`.\n\n     */\n\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the first rune in the slice, advancing the slice to point\n\n     *      to the next rune.\n\n     * @param self The slice to operate on.\n\n     * @return A slice containing only the first rune from `self`.\n\n     */\n\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n\n        nextRune(self, ret);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the number of the first codepoint in the slice.\n\n     * @param self The slice to operate on.\n\n     * @return The number of the first codepoint in the slice.\n\n     */\n\n    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the keccak-256 hash of the slice.\n\n     * @param self The slice to hash.\n\n     * @return The hash of the slice.\n\n     */\n\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if `self` starts with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice ends with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n\n     *      end of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    // Returns the memory address of the first byte of the first occurrence of\n\n    // `needle` in `self`, or the first byte after `self` if not found.\n\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n\n    }\n\n\n\n    // Returns the memory address of the first byte after the last occurrence of\n\n    // `needle` in `self`, or the address of `self` if not found.\n\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain everything from the first occurrence of\n\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n\n     *      if `needle` is not found.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len -= ptr - self._ptr;\n\n        self._ptr = ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain the part of the string from the start of\n\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n\n     *      is not found, `self` is set to the empty slice.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len = ptr - self._ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and `token` to everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = self._ptr;\n\n        token._len = ptr - self._ptr;\n\n        if (ptr == self._ptr + self._len) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n            self._ptr = ptr + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and returning everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` up to the first occurrence of `delim`.\n\n     */\n\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        split(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and `token` to everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = ptr;\n\n        token._len = self._len - (ptr - self._ptr);\n\n        if (ptr == self._ptr) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and returning everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` after the last occurrence of `delim`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        rsplit(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The number of occurrences of `needle` found in `self`.\n\n     */\n\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n\n        while (ptr <= self._ptr + self._len) {\n\n            cnt++;\n\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns True if `self` contains `needle`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return True if `needle` is found in `self`, false otherwise.\n\n     */\n\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a newly allocated string containing the concatenation of\n\n     *      `self` and `other`.\n\n     * @param self The first slice to concatenate.\n\n     * @param other The second slice to concatenate.\n\n     * @return The concatenation of the two strings.\n\n     */\n\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n\n     *      newly allocated string.\n\n     * @param self The delimiter to use.\n\n     * @param parts A list of slices to join.\n\n     * @return A newly allocated string containing all the slices in `parts`,\n\n     *         joined with `self`.\n\n     */\n\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n\n    }\n",
                    "message": "Contract 'strings' (tokenWhitelistableExporter.sol#798-1475) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n",
                    "message": "Struct 'strings.slice' (tokenWhitelistableExporter.sol#799-802) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address) external view returns (string, uint256, uint256, bool, bool, bool, uint256);\n",
                    "message": "Parameter '' of ITokenWhitelist.getTokenInfo (tokenWhitelistableExporter.sol#1598) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '' of ITokenWhitelist.updateTokenRate (tokenWhitelistableExporter.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_0' of ITokenWhitelist.updateTokenRate (tokenWhitelistableExporter.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_1' of ITokenWhitelist.updateTokenRate (tokenWhitelistableExporter.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_oracleNameHash_' of TokenWhitelist. (tokenWhitelistableExporter.sol#1644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_stabelcoinAddress_' of TokenWhitelist. (tokenWhitelistableExporter.sol#1644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.addTokens (tokenWhitelistableExporter.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_symbols' of TokenWhitelist.addTokens (tokenWhitelistableExporter.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_magnitude' of TokenWhitelist.addTokens (tokenWhitelistableExporter.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_loadable' of TokenWhitelist.addTokens (tokenWhitelistableExporter.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_burnable' of TokenWhitelist.addTokens (tokenWhitelistableExporter.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_lastUpdate' of TokenWhitelist.addTokens (tokenWhitelistableExporter.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokens(address[] _tokens) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.removeTokens (tokenWhitelistableExporter.sol#1684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_token' of TokenWhitelist.updateTokenRate (tokenWhitelistableExporter.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_rate' of TokenWhitelist.updateTokenRate (tokenWhitelistableExporter.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelist.updateTokenRate (tokenWhitelistableExporter.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of TokenWhitelist.claim (tokenWhitelistableExporter.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of TokenWhitelist.claim (tokenWhitelistableExporter.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of TokenWhitelist.claim (tokenWhitelistableExporter.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address _a) external view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelist.getTokenInfo (tokenWhitelistableExporter.sol#1735) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
                    "message": "Parameter '_tokenWhitelistNameHash_' of TokenWhitelistable. (tokenWhitelistableExporter.sol#1803) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": 1824,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\n",
                    "message": "Function 'TokenWhitelistable._getTokenInfo' (tokenWhitelistableExporter.sol#1822-1824) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._getTokenInfo (tokenWhitelistableExporter.sol#1822) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": 1836,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\n",
                    "message": "Function 'TokenWhitelistable._getStablecoinInfo' (tokenWhitelistableExporter.sol#1834-1836) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1840,
                    "vulnerability_to_line": 1842,
                    "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\n",
                    "message": "Function 'TokenWhitelistable._tokenAddressArray' (tokenWhitelistableExporter.sol#1840-1842) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": 1850,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\n",
                    "message": "Function 'TokenWhitelistable._updateTokenRate' (tokenWhitelistableExporter.sol#1848-1850) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_token' of TokenWhitelistable._updateTokenRate (tokenWhitelistableExporter.sol#1848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_rate' of TokenWhitelistable._updateTokenRate (tokenWhitelistableExporter.sol#1848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelistable._updateTokenRate (tokenWhitelistableExporter.sol#1848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1854,
                    "vulnerability_to_line": 1857,
                    "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\n\n        return available;\n",
                    "message": "Function 'TokenWhitelistable._isTokenAvailable' (tokenWhitelistableExporter.sol#1854-1857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenAvailable (tokenWhitelistableExporter.sol#1854) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1861,
                    "vulnerability_to_line": 1864,
                    "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n\n        ( , , , , , bool burnable, ) = _getTokenInfo(_a);\n\n        return burnable;\n",
                    "message": "Function 'TokenWhitelistable._isTokenBurnable' (tokenWhitelistableExporter.sol#1861-1864) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenBurnable (tokenWhitelistableExporter.sol#1861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1868,
                    "vulnerability_to_line": 1871,
                    "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\n\n        return loadable;\n",
                    "message": "Function 'TokenWhitelistable._isTokenLoadable' (tokenWhitelistableExporter.sol#1868-1871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1868,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenLoadable (tokenWhitelistableExporter.sol#1868) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1875,
                    "vulnerability_to_line": 1877,
                    "vulnerability_code": "    function _stablecoin() internal view returns (address) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\n",
                    "message": "Function 'TokenWhitelistable._stablecoin' (tokenWhitelistableExporter.sol#1875-1877) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1890,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function getTokenInfo(address _a) external view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelistableExporter.getTokenInfo (tokenWhitelistableExporter.sol#1890) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function updateTokenRate(address _token, uint _rate, uint _updateDate) external {\n",
                    "message": "Parameter '_token' of TokenWhitelistableExporter.updateTokenRate (tokenWhitelistableExporter.sol#1902) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function updateTokenRate(address _token, uint _rate, uint _updateDate) external {\n",
                    "message": "Parameter '_rate' of TokenWhitelistableExporter.updateTokenRate (tokenWhitelistableExporter.sol#1902) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function updateTokenRate(address _token, uint _rate, uint _updateDate) external {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelistableExporter.updateTokenRate (tokenWhitelistableExporter.sol#1902) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1906,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function isTokenLoadable(address _a) external view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistableExporter.isTokenLoadable (tokenWhitelistableExporter.sol#1906) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1910,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function isTokenAvailable(address _a) external view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistableExporter.isTokenAvailable (tokenWhitelistableExporter.sol#1910) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1914,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "  function isTokenBurnable(address _a) external view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistableExporter.isTokenBurnable (tokenWhitelistableExporter.sol#1914) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF8) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xFC) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1018,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1071,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x1F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1077,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x07;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b = (word / divisor) & 0xFF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = (ret * 64) | (b & 0x3F);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptr >= selfptr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (ptr <= self._ptr + self._len) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _adminCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isController;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _controllerCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS private _ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _ensRegistry;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _controllerNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => Token) private _tokenInfoMap;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] private _tokenAddressArray;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _stablecoin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _oracleNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _tokenWhitelistNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 876,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { b := and(mload(ptr), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 967,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { word:= mload(mload(add(self, 32))) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/mocks/base64-exporter.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Base64._base64decode (base64-exporter.sol#16-63) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Base64._base64decode uses assembly (base64-exporter.sol#16-63)\n\t- base64-exporter.sol#58-62\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Function 'Base64._base64decode' (base64-exporter.sol#16-63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": "Parameter '_encoded' of Base64._base64decode (base64-exporter.sol#16) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 73,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function base64decode(bytes _encoded) external pure returns (bytes) {\n",
                    "message": "Parameter '_encoded' of Base64Exporter.base64decode (base64-exporter.sol#73) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 68,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant BASE64_DECODE_CHAR = hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\";\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/ERC20.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_5"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (ERC20.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (ERC20.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (ERC20.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (ERC20.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (ERC20.sol#9) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/SafeMath.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/oraclizeAPI_0.4.25.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 823,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 832,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    if(subindex == n.length)\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 823,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i=0; i< n_random_bytes; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 945,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((_nbytes > 0) && (_nbytes <= 32));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1064,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 784,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 785,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 786,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 787,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 788,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 789,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 880,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 881,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (decimals){\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 882,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                   if (_b == 0) break;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    else _b--;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 884,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 885,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mint *= 10;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 886,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                mint += uint(bresult[i]) - 48;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 887,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if (bresult[i] == 46) decimals = true;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (v != 27 && v != 28)\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 1224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            return (false, 0);\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 883,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    else _b--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < minLength; i ++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 823,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                        subindex++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 898,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            len++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1087,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint256 i=0; i< n_random_bytes; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_37"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n\n        uint capacity = _capacity;\n\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n\n        // Allocate space for the buffer data\n\n        buf.capacity = capacity;\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(buf, ptr)\n\n            mstore(ptr, 0)\n\n            mstore(0x40, add(ptr, capacity))\n\n        }\n",
                    "message": "Buffer.init (oraclizeAPI_0.4.25.sol#91-102) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n\n        if(data.length + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, data.length) * 2);\n\n        }\n\n\n\n        uint dest;\n\n        uint src;\n\n        uint len = data.length;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Start address = buffer address + buffer length + sizeof(buffer length)\n\n            dest := add(add(bufptr, buflen), 32)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, mload(data)))\n\n            src := add(data, 32)\n\n        }\n\n\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n\n\n        return buf;\n",
                    "message": "Buffer.append (oraclizeAPI_0.4.25.sol#124-162) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 187,
                    "vulnerability_code": "    function append(buffer memory buf, uint8 data) internal pure {\n\n        if(buf.buf.length + 1 > buf.capacity) {\n\n            resize(buf, buf.capacity * 2);\n\n        }\n\n\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length)\n\n            let dest := add(add(bufptr, buflen), 32)\n\n            mstore8(dest, data)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, 1))\n\n        }\n",
                    "message": "Buffer.append (oraclizeAPI_0.4.25.sol#171-187) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 214,
                    "vulnerability_code": "    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n\n        if(len + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, len) * 2);\n\n        }\n\n\n\n        uint mask = 256 ** len - 1;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\n\n            let dest := add(add(bufptr, buflen), len)\n\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, len))\n\n        }\n\n        return buf;\n",
                    "message": "Buffer.appendInt (oraclizeAPI_0.4.25.sol#196-214) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": 773,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n",
                    "message": "usingOraclize.getCodeSize (oraclizeAPI_0.4.25.sol#769-773) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": 1157,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n",
                    "message": "usingOraclize.copyBytes (oraclizeAPI_0.4.25.sol#1137-1157) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": 1234,
                    "vulnerability_code": "    function safeMemoryCleaner() internal pure {\n\n        assembly {\n\n            let fmem := mload(0x40)\n\n            codecopy(fmem, codesize, sub(msize, fmem))\n\n        }\n",
                    "message": "usingOraclize.safeMemoryCleaner (oraclizeAPI_0.4.25.sol#1229-1234) is declared view but contains assembly code\n"
                },
                {
                    "name": "reentrancy-no-eth",
                    "vulnerability_from_line": 308,
                    "vulnerability_to_line": 316,
                    "vulnerability_code": "    modifier oraclizeAPI {\n\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\n            oraclize_setNetwork(networkID_auto);\n\n\n\n        if(address(oraclize) != OAR.getAddress())\n\n            oraclize = OraclizeI(OAR.getAddress());\n\n\n\n        _;\n",
                    "message": "Reentrancy in usingOraclize.oraclizeAPI (oraclizeAPI_0.4.25.sol#308-316):\n\tExternal calls:\n\t- address(oraclize) != OAR.getAddress() (oraclizeAPI_0.4.25.sol#312-313)\n\t- oraclize = OraclizeI(OAR.getAddress()) (oraclizeAPI_0.4.25.sol#313)\n\tState variables written after the call(s):\n\t- oraclize (oraclizeAPI_0.4.25.sol#313)\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 913,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Buffer.buffer memory buf;\n",
                    "message": "buf in usingOraclize.stra2cbor (oraclizeAPI_0.4.25.sol#913) is a local variable never initialiazed\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        Buffer.buffer memory buf;\n",
                    "message": "buf in usingOraclize.ba2cbor (oraclizeAPI_0.4.25.sol#925) is a local variable never initialiazed\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 228,
                    "vulnerability_to_line": 244,
                    "vulnerability_code": "    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n\n        if(value <= 23) {\n\n            buf.append(uint8((major << 5) | value));\n\n        } else if(value <= 0xFF) {\n\n            buf.append(uint8((major << 5) | 24));\n\n            buf.appendInt(value, 1);\n\n        } else if(value <= 0xFFFF) {\n\n            buf.append(uint8((major << 5) | 25));\n\n            buf.appendInt(value, 2);\n\n        } else if(value <= 0xFFFFFFFF) {\n\n            buf.append(uint8((major << 5) | 26));\n\n            buf.appendInt(value, 4);\n\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n\n            buf.append(uint8((major << 5) | 27));\n\n            buf.appendInt(value, 8);\n\n        }\n",
                    "message": "CBOR.encodeType (oraclizeAPI_0.4.25.sol#228-244) does not use the value returned by external calls:\n\t-buf.appendInt(value,1) (oraclizeAPI_0.4.25.sol#233)\n\t-buf.appendInt(value,2) (oraclizeAPI_0.4.25.sol#236)\n\t-buf.appendInt(value,4) (oraclizeAPI_0.4.25.sol#239)\n\t-buf.appendInt(value,8) (oraclizeAPI_0.4.25.sol#242)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": 265,
                    "vulnerability_code": "    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n\n        buf.append(value);\n",
                    "message": "CBOR.encodeBytes (oraclizeAPI_0.4.25.sol#262-265) does not use the value returned by external calls:\n\t-buf.append(value) (oraclizeAPI_0.4.25.sol#264)\n"
                },
                {
                    "name": "unused-return",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": 270,
                    "vulnerability_code": "    function encodeString(Buffer.buffer memory buf, string value) internal pure {\n\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n\n        buf.append(bytes(value));\n",
                    "message": "CBOR.encodeString (oraclizeAPI_0.4.25.sol#267-270) does not use the value returned by external calls:\n\t-buf.append(bytes(value)) (oraclizeAPI_0.4.25.sol#269)\n"
                },
                {
                    "name": "reentrancy-benign",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": 990,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n",
                    "message": "Reentrancy in usingOraclize.oraclize_newRandomDSQuery (oraclizeAPI_0.4.25.sol#944-990):\n\tExternal calls:\n\t- sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash() (oraclizeAPI_0.4.25.sol#952)\n\t- queryId = oraclize_query(random,args,_customGasLimit) (oraclizeAPI_0.4.25.sol#971)\n\tExternal calls sending eth:\n\t- queryId = oraclize_query(random,args,_customGasLimit) (oraclizeAPI_0.4.25.sol#971)\n\tState variables written after the call(s):\n\t- oraclize_network_name (oraclizeAPI_0.4.25.sol#971)\n\t- oraclize_randomDS_args (oraclizeAPI_0.4.25.sol#988)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": 102,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n\n        uint capacity = _capacity;\n\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n\n        // Allocate space for the buffer data\n\n        buf.capacity = capacity;\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(buf, ptr)\n\n            mstore(ptr, 0)\n\n            mstore(0x40, add(ptr, capacity))\n\n        }\n",
                    "message": "Buffer.init uses assembly (oraclizeAPI_0.4.25.sol#91-102)\n\t- oraclizeAPI_0.4.25.sol#96-102\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": 162,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n\n        if(data.length + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, data.length) * 2);\n\n        }\n\n\n\n        uint dest;\n\n        uint src;\n\n        uint len = data.length;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Start address = buffer address + buffer length + sizeof(buffer length)\n\n            dest := add(add(bufptr, buflen), 32)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, mload(data)))\n\n            src := add(data, 32)\n\n        }\n\n\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n\n\n        return buf;\n",
                    "message": "Buffer.append uses assembly (oraclizeAPI_0.4.25.sol#124-162)\n\t- oraclizeAPI_0.4.25.sol#132-145\n\t- oraclizeAPI_0.4.25.sol#146-149\n\t- oraclizeAPI_0.4.25.sol#155-161\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": 187,
                    "vulnerability_code": "    function append(buffer memory buf, uint8 data) internal pure {\n\n        if(buf.buf.length + 1 > buf.capacity) {\n\n            resize(buf, buf.capacity * 2);\n\n        }\n\n\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length)\n\n            let dest := add(add(bufptr, buflen), 32)\n\n            mstore8(dest, data)\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, 1))\n\n        }\n",
                    "message": "Buffer.append uses assembly (oraclizeAPI_0.4.25.sol#171-187)\n\t- oraclizeAPI_0.4.25.sol#176-187\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": 214,
                    "vulnerability_code": "    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n\n        if(len + buf.buf.length > buf.capacity) {\n\n            resize(buf, max(buf.capacity, len) * 2);\n\n        }\n\n\n\n        uint mask = 256 ** len - 1;\n\n        assembly {\n\n            // Memory address of the buffer data\n\n            let bufptr := mload(buf)\n\n            // Length of existing buffer data\n\n            let buflen := mload(bufptr)\n\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\n\n            let dest := add(add(bufptr, buflen), len)\n\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n\n            // Update buffer length\n\n            mstore(bufptr, add(buflen, len))\n\n        }\n\n        return buf;\n",
                    "message": "Buffer.appendInt uses assembly (oraclizeAPI_0.4.25.sol#196-214)\n\t- oraclizeAPI_0.4.25.sol#202-213\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": 773,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n",
                    "message": "usingOraclize.getCodeSize uses assembly (oraclizeAPI_0.4.25.sol#769-773)\n\t- oraclizeAPI_0.4.25.sol#770-773\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": 990,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n",
                    "message": "usingOraclize.oraclize_newRandomDSQuery uses assembly (oraclizeAPI_0.4.25.sol#944-990)\n\t- oraclizeAPI_0.4.25.sol#953-962\n\t- oraclizeAPI_0.4.25.sol#963-967\n\t- oraclizeAPI_0.4.25.sol#975-988\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": 1025,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\n        bool sigok;\n\n        address signer;\n\n\n\n        bytes32 sigr;\n\n        bytes32 sigs;\n\n\n\n        bytes memory sigr_ = new bytes(32);\n\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\n        bytes memory sigs_ = new bytes(32);\n\n        offset += 32 + 2;\n\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\n\n        assembly {\n\n            sigr := mload(add(sigr_, 32))\n\n            sigs := mload(add(sigs_, 32))\n\n        }\n\n\n\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\n        if (address(keccak256(pubkey)) == signer) return true;\n\n        else {\n\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\n            return (address(keccak256(pubkey)) == signer);\n\n        }\n",
                    "message": "usingOraclize.verifySig uses assembly (oraclizeAPI_0.4.25.sol#999-1025)\n\t- oraclizeAPI_0.4.25.sol#1013-1019\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": 1157,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n",
                    "message": "usingOraclize.copyBytes uses assembly (oraclizeAPI_0.4.25.sol#1137-1157)\n\t- oraclizeAPI_0.4.25.sol#1148-1152\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1161,
                    "vulnerability_to_line": 1186,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n",
                    "message": "usingOraclize.safer_ecrecover uses assembly (oraclizeAPI_0.4.25.sol#1161-1186)\n\t- oraclizeAPI_0.4.25.sol#1172-1185\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": 1227,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        if (sig.length != 65)\n\n          return (false, 0);\n\n\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n\n            // 'mload' will pad with zeroes if we overread.\n\n            // There is no 'mload8' to do this, but that would be nicer.\n\n            v := byte(0, mload(add(sig, 96)))\n\n\n\n            // Alternative solution:\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            // v := and(mload(add(sig, 65)), 255)\n\n        }\n\n\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n\n        // to match the YP range of [27, 28]\n\n        //\n\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n\n        if (v < 27)\n\n          v += 27;\n\n\n\n        if (v != 27 && v != 28)\n\n            return (false, 0);\n\n\n\n        return safer_ecrecover(hash, v, r, s);\n",
                    "message": "usingOraclize.ecrecovery uses assembly (oraclizeAPI_0.4.25.sol#1189-1227)\n\t- oraclizeAPI_0.4.25.sol#1200-1220\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": 1234,
                    "vulnerability_code": "    function safeMemoryCleaner() internal pure {\n\n        assembly {\n\n            let fmem := mload(0x40)\n\n            codecopy(fmem, codesize, sub(msize, fmem))\n\n        }\n",
                    "message": "usingOraclize.safeMemoryCleaner uses assembly (oraclizeAPI_0.4.25.sol#1229-1234)\n\t- oraclizeAPI_0.4.25.sol#1230-1234\n"
                },
                {
                    "name": "constable-states",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address public cbAddress;\n",
                    "message": "OraclizeI.cbAddress should be constant (oraclizeAPI_0.4.25.sol#39)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": "OraclizeI.query2 (oraclizeAPI_0.4.25.sol#42) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": "OraclizeI.queryN (oraclizeAPI_0.4.25.sol#44) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource) public returns (uint _dsprice);\n",
                    "message": "OraclizeI.getPrice (oraclizeAPI_0.4.25.sol#46) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n",
                    "message": "OraclizeI.getPrice (oraclizeAPI_0.4.25.sol#47) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 54,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getAddress() public returns (address _addr);\n",
                    "message": "OraclizeAddrResolverI.getAddress (oraclizeAPI_0.4.25.sol#54) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n",
                    "message": "usingOraclize.__callback (oraclizeAPI_0.4.25.sol#362-364) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.22;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\n",
                    "message": "Detected issues with version pragma in oraclizeAPI_0.4.25.sol:\n\t- pragma solidity>=0.4.22 (oraclizeAPI_0.4.25.sol#36): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.query_withGasLimit' (oraclizeAPI_0.4.25.sol#41) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.query2_withGasLimit' (oraclizeAPI_0.4.25.sol#43) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n",
                    "message": "Function 'OraclizeI.queryN_withGasLimit' (oraclizeAPI_0.4.25.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n",
                    "message": "Function 'OraclizeI.randomDS_getSessionPubKeyHash' (oraclizeAPI_0.4.25.sol#50) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 86,
                    "vulnerability_to_line": 89,
                    "vulnerability_code": "    struct buffer {\n\n        bytes buf;\n\n        uint capacity;\n",
                    "message": "Struct 'Buffer.buffer' (oraclizeAPI_0.4.25.sol#86-89) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n",
                    "message": "Parameter '_capacity' of Buffer.init (oraclizeAPI_0.4.25.sol#91) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 289,
                    "vulnerability_to_line": 1236,
                    "vulnerability_code": "contract usingOraclize {\n\n    uint constant day = 60*60*24;\n\n    uint constant week = 60*60*24*7;\n\n    uint constant month = 60*60*24*30;\n\n    byte constant proofType_NONE = 0x00;\n\n    byte constant proofType_TLSNotary = 0x10;\n\n    byte constant proofType_Ledger = 0x30;\n\n    byte constant proofType_Android = 0x40;\n\n    byte constant proofType_Native = 0xF0;\n\n    byte constant proofStorage_IPFS = 0x01;\n\n    uint8 constant networkID_auto = 0;\n\n    uint8 constant networkID_mainnet = 1;\n\n    uint8 constant networkID_testnet = 2;\n\n    uint8 constant networkID_morden = 2;\n\n    uint8 constant networkID_consensys = 161;\n\n\n\n    OraclizeAddrResolverI OAR;\n\n\n\n    OraclizeI oraclize;\n\n    modifier oraclizeAPI {\n\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n\n            oraclize_setNetwork(networkID_auto);\n\n\n\n        if(address(oraclize) != OAR.getAddress())\n\n            oraclize = OraclizeI(OAR.getAddress());\n\n\n\n        _;\n\n    }\n\n    modifier coupon(string code){\n\n        oraclize = OraclizeI(OAR.getAddress());\n\n        _;\n\n    }\n\n\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\n      return oraclize_setNetwork();\n\n      networkID; // silence the warning and remain backwards compatible\n\n    }\n\n    function oraclize_setNetwork() internal returns(bool){\n\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\n            oraclize_setNetworkName(\"eth_mainnet\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\n            oraclize_setNetworkName(\"eth_ropsten3\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\n            oraclize_setNetworkName(\"eth_kovan\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\n            oraclize_setNetworkName(\"eth_rinkeby\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\n            return true;\n\n        }\n\n        return false;\n\n    }\n\n\n\n    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n\n    }\n\n    function __callback(bytes32 myid, string result, bytes proof) public {\n\n      return;\n\n      // Following should never be reached with a preceding return, however\n\n      // this is just a placeholder function, ideally meant to be defined in\n\n      // child contract when proofs are used\n\n      myid; result; proof; // Silence compiler warnings\n\n      oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view. \n\n    }\n\n\n\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource);\n\n    }\n\n\n\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(0, datasource, arg);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n\n    }\n\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n\n    }\n\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n\n    }\n\n\n\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n\n        return oraclize.cbAddress();\n\n    }\n\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n\n        return oraclize.setProofType(proofP);\n\n    }\n\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\n        return oraclize.setCustomGasPrice(gasPrice);\n\n    }\n\n\n\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\n        return oraclize.randomDS_getSessionPubKeyHash();\n\n    }\n\n\n\n    function getCodeSize(address _addr) view internal returns(uint _size) {\n\n        assembly {\n\n            _size := extcodesize(_addr)\n\n        }\n\n    }\n\n\n\n    function parseAddr(string _a) internal pure returns (address){\n\n        bytes memory tmp = bytes(_a);\n\n        uint160 iaddr = 0;\n\n        uint160 b1;\n\n        uint160 b2;\n\n        for (uint i=2; i<2+2*20; i+=2){\n\n            iaddr *= 256;\n\n            b1 = uint160(tmp[i]);\n\n            b2 = uint160(tmp[i+1]);\n\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n\n            iaddr += (b1*16+b2);\n\n        }\n\n        return address(iaddr);\n\n    }\n\n\n\n    function strCompare(string _a, string _b) internal pure returns (int) {\n\n        bytes memory a = bytes(_a);\n\n        bytes memory b = bytes(_b);\n\n        uint minLength = a.length;\n\n        if (b.length < minLength) minLength = b.length;\n\n        for (uint i = 0; i < minLength; i ++)\n\n            if (a[i] < b[i])\n\n                return -1;\n\n            else if (a[i] > b[i])\n\n                return 1;\n\n        if (a.length < b.length)\n\n            return -1;\n\n        else if (a.length > b.length)\n\n            return 1;\n\n        else\n\n            return 0;\n\n    }\n\n\n\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n\n        bytes memory h = bytes(_haystack);\n\n        bytes memory n = bytes(_needle);\n\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n\n            return -1;\n\n        else if(h.length > (2**128 -1))\n\n            return -1;\n\n        else\n\n        {\n\n            uint subindex = 0;\n\n            for (uint i = 0; i < h.length; i ++)\n\n            {\n\n                if (h[i] == n[0])\n\n                {\n\n                    subindex = 1;\n\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n\n                    {\n\n                        subindex++;\n\n                    }\n\n                    if(subindex == n.length)\n\n                        return int(i);\n\n                }\n\n            }\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n\n        bytes memory _ba = bytes(_a);\n\n        bytes memory _bb = bytes(_b);\n\n        bytes memory _bc = bytes(_c);\n\n        bytes memory _bd = bytes(_d);\n\n        bytes memory _be = bytes(_e);\n\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n\n        bytes memory babcde = bytes(abcde);\n\n        uint k = 0;\n\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n\n        return string(babcde);\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n\n        return strConcat(_a, _b, _c, _d, \"\");\n\n    }\n\n\n\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n\n        return strConcat(_a, _b, _c, \"\", \"\");\n\n    }\n\n\n\n    function strConcat(string _a, string _b) internal pure returns (string) {\n\n        return strConcat(_a, _b, \"\", \"\", \"\");\n\n    }\n\n\n\n    // parseInt\n\n    function parseInt(string _a) internal pure returns (uint) {\n\n        return parseInt(_a, 0);\n\n    }\n\n\n\n    // parseInt(parseFloat*10^_b)\n\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\n\n        bytes memory bresult = bytes(_a);\n\n        uint mint = 0;\n\n        bool decimals = false;\n\n        for (uint i=0; i<bresult.length; i++){\n\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n\n                if (decimals){\n\n                   if (_b == 0) break;\n\n                    else _b--;\n\n                }\n\n                mint *= 10;\n\n                mint += uint(bresult[i]) - 48;\n\n            } else if (bresult[i] == 46) decimals = true;\n\n        }\n\n        if (_b > 0) mint *= 10**_b;\n\n        return mint;\n\n    }\n\n\n\n    function uint2str(uint i) internal pure returns (string){\n\n        if (i == 0) return \"0\";\n\n        uint j = i;\n\n        uint len;\n\n        while (j != 0){\n\n            len++;\n\n            j /= 10;\n\n        }\n\n        bytes memory bstr = new bytes(len);\n\n        uint k = len - 1;\n\n        while (i != 0){\n\n            bstr[k--] = byte(48 + i % 10);\n\n            i /= 10;\n\n        }\n\n        return string(bstr);\n\n    }\n\n\n\n    using CBOR for Buffer.buffer;\n\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\n\n        safeMemoryCleaner();\n\n        Buffer.buffer memory buf;\n\n        Buffer.init(buf, 1024);\n\n        buf.startArray();\n\n        for (uint i = 0; i < arr.length; i++) {\n\n            buf.encodeString(arr[i]);\n\n        }\n\n        buf.endSequence();\n\n        return buf.buf;\n\n    }\n\n\n\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n\n        safeMemoryCleaner();\n\n        Buffer.buffer memory buf;\n\n        Buffer.init(buf, 1024);\n\n        buf.startArray();\n\n        for (uint i = 0; i < arr.length; i++) {\n\n            buf.encodeBytes(arr[i]);\n\n        }\n\n        buf.endSequence();\n\n        return buf.buf;\n\n    }\n\n\n\n    string oraclize_network_name;\n\n    function oraclize_setNetworkName(string _network_name) internal {\n\n        oraclize_network_name = _network_name;\n\n    }\n\n\n\n    function oraclize_getNetworkName() internal view returns (string) {\n\n        return oraclize_network_name;\n\n    }\n\n\n\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n\n    }\n\n\n\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\n        oraclize_randomDS_args[queryId] = commitment;\n\n    }\n\n\n\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n\n\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n\n        bool sigok;\n\n        address signer;\n\n\n\n        bytes32 sigr;\n\n        bytes32 sigs;\n\n\n\n        bytes memory sigr_ = new bytes(32);\n\n        uint offset = 4+(uint(dersig[3]) - 0x20);\n\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n\n        bytes memory sigs_ = new bytes(32);\n\n        offset += 32 + 2;\n\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n\n\n        assembly {\n\n            sigr := mload(add(sigr_, 32))\n\n            sigs := mload(add(sigs_, 32))\n\n        }\n\n\n\n\n\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n\n        if (address(keccak256(pubkey)) == signer) return true;\n\n        else {\n\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n\n            return (address(keccak256(pubkey)) == signer);\n\n        }\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\n        bool sigok;\n\n\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\n\n        bytes memory appkey1_pubkey = new bytes(64);\n\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\n\n        bytes memory tosign2 = new bytes(1+65+32);\n\n        tosign2[0] = byte(1); //role\n\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\n\n        if (sigok == false) return false;\n\n\n\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\n\n        bytes memory tosign3 = new bytes(1+65);\n\n        tosign3[0] = 0xFE;\n\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\n\n        return sigok;\n\n    }\n\n\n\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        require(proofVerified);\n\n\n\n        _;\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        if (proofVerified == false) return 2;\n\n\n\n        return 0;\n\n    }\n\n\n\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n\n        bool match_ = true;\n\n\n\n        require(prefix.length == n_random_bytes);\n\n\n\n        for (uint256 i=0; i< n_random_bytes; i++) {\n\n            if (content[i] != prefix[i]) match_ = false;\n\n        }\n\n\n\n        return match_;\n\n    }\n\n\n\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\n        bytes memory keyhash = new bytes(32);\n\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\n\n\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\n        // This is to verify that the computed args match with the ones specified in the query.\n\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\n\n        bytes memory sessionPubkey = new bytes(64);\n\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\n\n            delete oraclize_randomDS_args[queryId];\n\n        } else return false;\n\n\n\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\n        bytes memory tosign1 = new bytes(32+8+1+32);\n\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\n        }\n\n\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n\n        uint minLength = length + toOffset;\n\n\n\n        // Buffer too small\n\n        require(to.length >= minLength); // Should be a better way?\n\n\n\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n\n        uint i = 32 + fromOffset;\n\n        uint j = 32 + toOffset;\n\n\n\n        while (i < (32 + fromOffset + length)) {\n\n            assembly {\n\n                let tmp := mload(add(from, i))\n\n                mstore(add(to, j), tmp)\n\n            }\n\n            i += 32;\n\n            j += 32;\n\n        }\n\n\n\n        return to;\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\n\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n\n    }\n\n\n\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        if (sig.length != 65)\n\n          return (false, 0);\n\n\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        assembly {\n\n            r := mload(add(sig, 32))\n\n            s := mload(add(sig, 64))\n\n\n\n            // Here we are loading the last 32 bytes. We exploit the fact that\n\n            // 'mload' will pad with zeroes if we overread.\n\n            // There is no 'mload8' to do this, but that would be nicer.\n\n            v := byte(0, mload(add(sig, 96)))\n\n\n\n            // Alternative solution:\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            // v := and(mload(add(sig, 65)), 255)\n\n        }\n\n\n\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\n\n        // to match the YP range of [27, 28]\n\n        //\n\n        // geth uses [0, 1] and some clients have followed. This might change, see:\n\n        //  https://github.com/ethereum/go-ethereum/issues/2053\n\n        if (v < 27)\n\n          v += 27;\n\n\n\n        if (v != 27 && v != 28)\n\n            return (false, 0);\n\n\n\n        return safer_ecrecover(hash, v, r, s);\n\n    }\n\n\n\n    function safeMemoryCleaner() internal pure {\n\n        assembly {\n\n            let fmem := mload(0x40)\n\n            codecopy(fmem, codesize, sub(msize, fmem))\n\n        }\n\n    }\n\n\n",
                    "message": "Contract 'usingOraclize' (oraclizeAPI_0.4.25.sol#289-1236) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 322,
                    "vulnerability_to_line": 325,
                    "vulnerability_code": "    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n\n      return oraclize_setNetwork();\n\n      networkID; // silence the warning and remain backwards compatible\n",
                    "message": "Function 'usingOraclize.oraclize_setNetwork' (oraclizeAPI_0.4.25.sol#322-325) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 326,
                    "vulnerability_to_line": 360,
                    "vulnerability_code": "    function oraclize_setNetwork() internal returns(bool){\n\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n\n            oraclize_setNetworkName(\"eth_mainnet\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n\n            oraclize_setNetworkName(\"eth_ropsten3\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n\n            oraclize_setNetworkName(\"eth_kovan\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n\n            oraclize_setNetworkName(\"eth_rinkeby\");\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n\n            return true;\n\n        }\n\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n\n            return true;\n\n        }\n\n        return false;\n",
                    "message": "Function 'usingOraclize.oraclize_setNetwork' (oraclizeAPI_0.4.25.sol#326-360) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": 364,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n\n        __callback(myid, result, new bytes(0));\n",
                    "message": "Function 'usingOraclize.__callback' (oraclizeAPI_0.4.25.sol#362-364) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": 372,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n\n      return;\n\n      // Following should never be reached with a preceding return, however\n\n      // this is just a placeholder function, ideally meant to be defined in\n\n      // child contract when proofs are used\n\n      myid; result; proof; // Silence compiler warnings\n\n      oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view. \n",
                    "message": "Function 'usingOraclize.__callback' (oraclizeAPI_0.4.25.sol#365-372) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": 376,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource);\n",
                    "message": "Function 'usingOraclize.oraclize_getPrice' (oraclizeAPI_0.4.25.sol#374-376) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": 380,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n\n        return oraclize.getPrice(datasource, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_getPrice' (oraclizeAPI_0.4.25.sol#378-380) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": 386,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(0, datasource, arg);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#382-386) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": 391,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#387-391) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": 396,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#392-396) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": 401,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#397-401) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": 406,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#402-406) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": 411,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#407-411) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": 416,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#412-416) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": 421,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#417-421) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": 427,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#422-427) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": 433,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#428-433) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": 439,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#434-439) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": 445,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = stra2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#440-445) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": 450,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#446-450) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": 455,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#451-455) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": 460,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#456-460) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": 465,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#461-465) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": 472,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#467-472) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": 478,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#473-478) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": 484,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#479-484) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 485,
                    "vulnerability_to_line": 490,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#485-490) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": 497,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#491-497) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": 504,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#498-504) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": 511,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#505-511) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#512-518) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": 527,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#520-527) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": 535,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#528-535) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": 543,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#536-543) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#544-551) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": 560,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#552-560) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": 569,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#561-569) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": 578,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#570-578) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": 587,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        string[] memory dynargs = new string[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#579-587) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 593,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(0, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#588-593) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": 599,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource);\n\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#594-599) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": 605,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#600-605) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": 611,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n\n        uint price = oraclize.getPrice(datasource, gaslimit);\n\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n\n        bytes memory args = ba2cbor(argN);\n\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#606-611) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 612,
                    "vulnerability_to_line": 616,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#612-616) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": 621,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#617-621) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": 626,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#622-626) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": 631,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](1);\n\n        dynargs[0] = args[0];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#627-631) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": 638,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#633-638) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 639,
                    "vulnerability_to_line": 644,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#639-644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": 650,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#645-650) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": 656,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](2);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#651-656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": 663,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#657-663) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": 670,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#664-670) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": 677,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#671-677) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 678,
                    "vulnerability_to_line": 684,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](3);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#678-684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 686,
                    "vulnerability_to_line": 693,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#686-693) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": 701,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#694-701) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": 709,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#702-709) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": 717,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](4);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#710-717) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 718,
                    "vulnerability_to_line": 726,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#718-726) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": 735,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#727-735) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 744,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#736-744) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": 753,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n\n        bytes[] memory dynargs = new bytes[](5);\n\n        dynargs[0] = args[0];\n\n        dynargs[1] = args[1];\n\n        dynargs[2] = args[2];\n\n        dynargs[3] = args[3];\n\n        dynargs[4] = args[4];\n\n        return oraclize_query(datasource, dynargs, gaslimit);\n",
                    "message": "Function 'usingOraclize.oraclize_query' (oraclizeAPI_0.4.25.sol#745-753) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 755,
                    "vulnerability_to_line": 757,
                    "vulnerability_code": "    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n\n        return oraclize.cbAddress();\n",
                    "message": "Function 'usingOraclize.oraclize_cbAddress' (oraclizeAPI_0.4.25.sol#755-757) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 758,
                    "vulnerability_to_line": 760,
                    "vulnerability_code": "    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n\n        return oraclize.setProofType(proofP);\n",
                    "message": "Function 'usingOraclize.oraclize_setProof' (oraclizeAPI_0.4.25.sol#758-760) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 761,
                    "vulnerability_to_line": 763,
                    "vulnerability_code": "    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n\n        return oraclize.setCustomGasPrice(gasPrice);\n",
                    "message": "Function 'usingOraclize.oraclize_setCustomGasPrice' (oraclizeAPI_0.4.25.sol#761-763) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 765,
                    "vulnerability_to_line": 767,
                    "vulnerability_code": "    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n\n        return oraclize.randomDS_getSessionPubKeyHash();\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_getSessionPubKeyHash' (oraclizeAPI_0.4.25.sol#765-767) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseAddr(string _a) internal pure returns (address){\n",
                    "message": "Parameter '_a' of usingOraclize.parseAddr (oraclizeAPI_0.4.25.sol#775) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": "Parameter '_a' of usingOraclize.strCompare (oraclizeAPI_0.4.25.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": "Parameter '_b' of usingOraclize.strCompare (oraclizeAPI_0.4.25.sol#795) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": "Parameter '_haystack' of usingOraclize.indexOf (oraclizeAPI_0.4.25.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": "Parameter '_needle' of usingOraclize.indexOf (oraclizeAPI_0.4.25.sol#813) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#840) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#840) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#840) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_d' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#840) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": "Parameter '_e' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#840) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": "Parameter '_d' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": "Parameter '_c' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": "Parameter '_a' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#865) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": "Parameter '_b' of usingOraclize.strConcat (oraclizeAPI_0.4.25.sol#865) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a) internal pure returns (uint) {\n",
                    "message": "Parameter '_a' of usingOraclize.parseInt (oraclizeAPI_0.4.25.sol#870) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": "Parameter '_a' of usingOraclize.parseInt (oraclizeAPI_0.4.25.sol#875) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": "Parameter '_b' of usingOraclize.parseInt (oraclizeAPI_0.4.25.sol#875) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": 938,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n\n        oraclize_network_name = _network_name;\n",
                    "message": "Function 'usingOraclize.oraclize_setNetworkName' (oraclizeAPI_0.4.25.sol#936-938) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n",
                    "message": "Parameter '_network_name' of usingOraclize.oraclize_setNetworkName (oraclizeAPI_0.4.25.sol#936) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": 942,
                    "vulnerability_code": "    function oraclize_getNetworkName() internal view returns (string) {\n\n        return oraclize_network_name;\n",
                    "message": "Function 'usingOraclize.oraclize_getNetworkName' (oraclizeAPI_0.4.25.sol#940-942) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": 990,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n\n        require((_nbytes > 0) && (_nbytes <= 32));\n\n        // Convert from seconds to ledger timer ticks\n\n        _delay *= 10;\n\n        bytes memory nbytes = new bytes(1);\n\n        nbytes[0] = byte(_nbytes);\n\n        bytes memory unonce = new bytes(32);\n\n        bytes memory sessionKeyHash = new bytes(32);\n\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n\n        assembly {\n\n            mstore(unonce, 0x20)\n\n            // the following variables can be relaxed\n\n            // check relaxed random contract under ethereum-examples repo\n\n            // for an idea on how to override and replace comit hash vars\n\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n\n            mstore(sessionKeyHash, 0x20)\n\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n\n        }\n\n        bytes memory delay = new bytes(32);\n\n        assembly {\n\n            mstore(add(delay, 0x20), _delay)\n\n        }\n\n\n\n        bytes memory delay_bytes8 = new bytes(8);\n\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n\n\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n\n\n        bytes memory delay_bytes8_left = new bytes(8);\n\n\n\n        assembly {\n\n            let x := mload(add(delay_bytes8, 0x20))\n\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n\n\n        }\n\n\n\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n\n        return queryId;\n",
                    "message": "Function 'usingOraclize.oraclize_newRandomDSQuery' (oraclizeAPI_0.4.25.sol#944-990) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_delay' of usingOraclize.oraclize_newRandomDSQuery (oraclizeAPI_0.4.25.sol#944) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_nbytes' of usingOraclize.oraclize_newRandomDSQuery (oraclizeAPI_0.4.25.sol#944) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 944,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n",
                    "message": "Parameter '_customGasLimit' of usingOraclize.oraclize_newRandomDSQuery (oraclizeAPI_0.4.25.sol#944) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 992,
                    "vulnerability_to_line": 994,
                    "vulnerability_code": "    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n\n        oraclize_randomDS_args[queryId] = commitment;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_setCommitment' (oraclizeAPI_0.4.25.sol#992-994) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": 1060,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n\n        bool sigok;\n\n\n\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n\n\n        bytes memory appkey1_pubkey = new bytes(64);\n\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n\n\n        bytes memory tosign2 = new bytes(1+65+32);\n\n        tosign2[0] = byte(1); //role\n\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n\n\n        if (sigok == false) return false;\n\n\n\n\n\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n\n\n        bytes memory tosign3 = new bytes(1+65);\n\n        tosign3[0] = 0xFE;\n\n        copyBytes(proof, 3, 65, tosign3, 1);\n\n\n\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n\n\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n\n\n        return sigok;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity' (oraclizeAPI_0.4.25.sol#1027-1060) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": 1080,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        if (proofVerified == false) return 2;\n\n\n\n        return 0;\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__returnCode' (oraclizeAPI_0.4.25.sol#1072-1080) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_queryId' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (oraclizeAPI_0.4.25.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_result' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (oraclizeAPI_0.4.25.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": "Parameter '_proof' of usingOraclize.oraclize_randomDS_proofVerify__returnCode (oraclizeAPI_0.4.25.sol#1072) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1082,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n",
                    "message": "Parameter 'n_random_bytes' of usingOraclize.matchBytes32Prefix (oraclizeAPI_0.4.25.sol#1082) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": 1134,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n\n\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n\n        bytes memory keyhash = new bytes(32);\n\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\n\n\n\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n\n\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n\n\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n\n        // This is to verify that the computed args match with the ones specified in the query.\n\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\n\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n\n\n        bytes memory sessionPubkey = new bytes(64);\n\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n\n\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\n\n            delete oraclize_randomDS_args[queryId];\n\n        } else return false;\n\n\n\n\n\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n\n        bytes memory tosign1 = new bytes(32+8+1+32);\n\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n\n\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n\n        }\n\n\n\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n",
                    "message": "Function 'usingOraclize.oraclize_randomDS_proofVerify__main' (oraclizeAPI_0.4.25.sol#1094-1134) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": "Parameter 'context_name' of usingOraclize.oraclize_randomDS_proofVerify__main (oraclizeAPI_0.4.25.sol#1094) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1161,
                    "vulnerability_to_line": 1186,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n\n        // We do our own memory management here. Solidity uses memory offset\n\n        // 0x40 to store the current end of memory. We write past it (as\n\n        // writes are memory extensions), but don't update the offset so\n\n        // Solidity will reuse it. The memory used here is only needed for\n\n        // this context.\n\n\n\n        // FIXME: inline assembly can't access return values\n\n        bool ret;\n\n        address addr;\n\n\n\n        assembly {\n\n            let size := mload(0x40)\n\n            mstore(size, hash)\n\n            mstore(add(size, 32), v)\n\n            mstore(add(size, 64), r)\n\n            mstore(add(size, 96), s)\n\n\n\n            // NOTE: we can reuse the request memory because we deal with\n\n            //       the return code\n\n            ret := call(3000, 1, 0, size, 128, size, 32)\n\n            addr := mload(size)\n\n        }\n\n\n\n        return (ret, addr);\n",
                    "message": "Function 'usingOraclize.safer_ecrecover' (oraclizeAPI_0.4.25.sol#1161-1186) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": "Constant 'usingOraclize.day' (oraclizeAPI_0.4.25.sol#290) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant week = 60*60*24*7;\n",
                    "message": "Constant 'usingOraclize.week' (oraclizeAPI_0.4.25.sol#291) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant month = 60*60*24*30;\n",
                    "message": "Constant 'usingOraclize.month' (oraclizeAPI_0.4.25.sol#292) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": "Constant 'usingOraclize.proofType_NONE' (oraclizeAPI_0.4.25.sol#293) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": "Constant 'usingOraclize.proofType_TLSNotary' (oraclizeAPI_0.4.25.sol#294) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": "Constant 'usingOraclize.proofType_Ledger' (oraclizeAPI_0.4.25.sol#295) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x40;\n",
                    "message": "Constant 'usingOraclize.proofType_Android' (oraclizeAPI_0.4.25.sol#296) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": "Constant 'usingOraclize.proofType_Native' (oraclizeAPI_0.4.25.sol#297) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": "Constant 'usingOraclize.proofStorage_IPFS' (oraclizeAPI_0.4.25.sol#298) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_auto = 0;\n",
                    "message": "Constant 'usingOraclize.networkID_auto' (oraclizeAPI_0.4.25.sol#299) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_mainnet = 1;\n",
                    "message": "Constant 'usingOraclize.networkID_mainnet' (oraclizeAPI_0.4.25.sol#300) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_testnet = 2;\n",
                    "message": "Constant 'usingOraclize.networkID_testnet' (oraclizeAPI_0.4.25.sol#301) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_morden = 2;\n",
                    "message": "Constant 'usingOraclize.networkID_morden' (oraclizeAPI_0.4.25.sol#302) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_consensys = 161;\n",
                    "message": "Constant 'usingOraclize.networkID_consensys' (oraclizeAPI_0.4.25.sol#303) is not in UPPER_CASE_WITH_UNDERSCORES\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeAddrResolverI OAR;\n",
                    "message": "Variable 'usingOraclize.OAR' (oraclizeAPI_0.4.25.sol#305) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string oraclize_network_name;\n",
                    "message": "Variable 'usingOraclize.oraclize_network_name' (oraclizeAPI_0.4.25.sol#935) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n",
                    "message": "Variable 'usingOraclize.oraclize_randomDS_args' (oraclizeAPI_0.4.25.sol#996) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n",
                    "message": "Variable 'usingOraclize.oraclize_randomDS_sessionKeysHashVerified' (oraclizeAPI_0.4.25.sol#997) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1062,
                    "vulnerability_to_line": 1070,
                    "vulnerability_code": "    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n\n\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n\n        require(proofVerified);\n\n\n\n        _;\n",
                    "message": "Modifier 'usingOraclize.oraclize_randomDS_proofVerify' (oraclizeAPI_0.4.25.sol#1062-1070) is not in mixedCase\n"
                },
                {
                    "name": "unused-state",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": "usingOraclize.day (oraclizeAPI_0.4.25.sol#290) is never used in usingOraclize\nusingOraclize.week (oraclizeAPI_0.4.25.sol#291) is never used in usingOraclize\nusingOraclize.month (oraclizeAPI_0.4.25.sol#292) is never used in usingOraclize\nusingOraclize.proofType_NONE (oraclizeAPI_0.4.25.sol#293) is never used in usingOraclize\nusingOraclize.proofType_TLSNotary (oraclizeAPI_0.4.25.sol#294) is never used in usingOraclize\nusingOraclize.proofType_Ledger (oraclizeAPI_0.4.25.sol#295) is never used in usingOraclize\nusingOraclize.proofType_Android (oraclizeAPI_0.4.25.sol#296) is never used in usingOraclize\nusingOraclize.proofType_Native (oraclizeAPI_0.4.25.sol#297) is never used in usingOraclize\nusingOraclize.proofStorage_IPFS (oraclizeAPI_0.4.25.sol#298) is never used in usingOraclize\nusingOraclize.networkID_mainnet (oraclizeAPI_0.4.25.sol#300) is never used in usingOraclize\nusingOraclize.networkID_testnet (oraclizeAPI_0.4.25.sol#301) is never used in usingOraclize\nusingOraclize.networkID_morden (oraclizeAPI_0.4.25.sol#302) is never used in usingOraclize\nusingOraclize.networkID_consensys (oraclizeAPI_0.4.25.sol#303) is never used in usingOraclize\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 327,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 328,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 332,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 333,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 337,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 338,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 342,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 343,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 347,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 348,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 351,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 352,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 355,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 356,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 231,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 234,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 237,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 240,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x40;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1007,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint offset = 4+(uint(dersig[3]) - 0x20);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1011,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1051,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        tosign3[0] = 0xFE;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_DEPRECATED_CONSTRUCTIONS",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 823,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 800,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < minLength; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 823,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint i = 0; i < h.length; i ++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 850,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 852,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 879,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i=0; i<bresult.length; i++){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 928,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < arr.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (i < (32 + fromOffset + length)) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_LOCKED_MONEY",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract OraclizeI {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.22;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_INT = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 221,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 222,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_BYTES = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_STRING = 3;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 225,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_MAP = 5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 91,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function init(buffer memory buf, uint _capacity) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(buffer memory buf, uint8 data) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 196,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1229,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safeMemoryCleaner() internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
                    "vulnerability_from_line": 769,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getCodeSize(address _addr) view internal returns(uint _size) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1161,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UNCHECKED_CALL",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        __callback(myid, result, new bytes(0));\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 46,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource) public returns (uint _dsprice);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 124,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function encodeString(Buffer.buffer memory buf, string value) internal pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 365,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function __callback(bytes32 myid, string result, bytes proof) public {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 374,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 378,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 382,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 387,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 392,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 397,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 402,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 407,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 417,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 422,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 428,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 434,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 440,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 446,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 451,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 461,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 473,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 479,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 485,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 491,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 498,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 505,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 520,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 528,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 536,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 544,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 552,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 561,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 570,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 579,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 594,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 600,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 606,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 612,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 622,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 633,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 651,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 657,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 664,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 678,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 702,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 718,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 727,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 745,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 775,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseAddr(string _a) internal pure returns (address){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 795,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strCompare(string _a, string _b) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 813,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function indexOf(string _haystack, string _needle) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 865,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function strConcat(string _a, string _b) internal pure returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 870,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 875,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function parseInt(string _a, uint _b) internal pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 893,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function uint2str(uint i) internal pure returns (string){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 911,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stra2cbor(string[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 911,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function stra2cbor(string[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 936,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_setNetworkName(string _network_name) internal {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 940,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_getNetworkName() internal view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 999,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1027,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1072,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1082,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1094,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1137,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1189,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 132,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 146,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 155,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 176,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 953,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 963,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 975,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1013,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1148,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1172,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1200,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1230,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant day = 60*60*24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant week = 60*60*24*7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint constant month = 60*60*24*30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_NONE = 0x00;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_TLSNotary = 0x10;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Ledger = 0x30;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 296,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Android = 0x40;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofType_Native = 0xF0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 298,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    byte constant proofStorage_IPFS = 0x01;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 299,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_auto = 0;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 300,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_mainnet = 1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 301,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_testnet = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_morden = 2;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint8 constant networkID_consensys = 161;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeAddrResolverI OAR;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 307,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    OraclizeI oraclize;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 935,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    string oraclize_network_name;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 996,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bytes32) oraclize_randomDS_args;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 997,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/base64.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 26,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Base64._base64decode (base64.sol#16-63) is declared view but contains assembly code\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Base64._base64decode uses assembly (base64.sol#16-63)\n\t- base64.sol#58-62\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": 63,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n\n        byte v1;\n\n        byte v2;\n\n        byte v3;\n\n        byte v4;\n\n        uint length = _encoded.length;\n\n        bytes memory result = new bytes(length);\n\n        uint index;\n\n\n\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\n\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\n\n\n\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\n\n              length -= 2;\n\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\n\n              length -= 1;\n\n          }\n\n          uint count = length >> 2 << 2;\n\n          for (uint i = 0; i < count;) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n              result[index++] = (v3 << 6 | v4) & 255;\n\n          }\n\n          if (length - count == 2) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n          } else if (length - count == 3) {\n\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\n\n\n\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\n\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\n\n          }\n\n\n\n        // Set to correct length.\n\n        assembly {\n\n            mstore(result, index)\n\n        }\n\n\n\n        return result;\n",
                    "message": "Function 'Base64._base64decode' (base64.sol#16-63) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": "Parameter '_encoded' of Base64._base64decode (base64.sol#16) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 16,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _base64decode(bytes _encoded) internal pure returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 58,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 12,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes constant BASE64_DECODE_CHAR = hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\";\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/ERC165.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_1"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function supportsInterface(bytes4) external view returns (bool);\n",
                    "message": "Parameter '' of ERC165.supportsInterface (ERC165.sol#7) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/ens/ENS.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": []
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_4"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ ENS.sol#47) shadows:\n\t- ENS.owner (function @ ENS.sol#51)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ ENS.sol#48) shadows:\n\t- ENS.resolver (function @ ENS.sol#52)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ ENS.sol#49) shadows:\n\t- ENS.owner (function @ ENS.sol#51)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ ENS.sol#50) shadows:\n\t- ENS.ttl (function @ ENS.sol#53)\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/externals/ens/PublicResolver.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 140,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 141,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ens = ensAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 260,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                data = record.abis[contentType];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 262,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 263,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_24"
            ],
            "vulnerability_findings": [
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 47,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ PublicResolver.sol#47) shadows:\n\t- ENS.owner (function @ PublicResolver.sol#51)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ PublicResolver.sol#48) shadows:\n\t- ENS.resolver (function @ PublicResolver.sol#52)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 49,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ PublicResolver.sol#49) shadows:\n\t- ENS.owner (function @ PublicResolver.sol#51)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ PublicResolver.sol#50) shadows:\n\t- ENS.ttl (function @ PublicResolver.sol#53)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
                    "message": "PublicResolver.setAddr.addr (local variable @ PublicResolver.sol#150) shadows:\n\t- PublicResolver.addr (function @ PublicResolver.sol#303-305)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": "PublicResolver.setName.name (local variable @ PublicResolver.sol#185) shadows:\n\t- PublicResolver.name (function @ PublicResolver.sol#274-276)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": "Different versions of Solidity is used in PublicResolver.sol:\n\t- Version used: ['>=0.4.24', '^0.4.24']\n\t- PublicResolver.sol#30 declares pragma solidity>=0.4.24\n\t- PublicResolver.sol#87 declares pragma solidity^0.4.24\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 150,
                    "vulnerability_to_line": 153,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
                    "message": "PublicResolver.setAddr (PublicResolver.sol#150-153) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 163,
                    "vulnerability_to_line": 166,
                    "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
                    "message": "PublicResolver.setContent (PublicResolver.sol#163-166) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": 177,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
                    "message": "PublicResolver.setMultihash (PublicResolver.sol#174-177) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": 188,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
                    "message": "PublicResolver.setName (PublicResolver.sol#185-188) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": 204,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
                    "message": "PublicResolver.setABI (PublicResolver.sol#198-204) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 212,
                    "vulnerability_to_line": 215,
                    "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
                    "message": "PublicResolver.setPubkey (PublicResolver.sol#212-215) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": 227,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
                    "message": "PublicResolver.setText (PublicResolver.sol#224-227) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": 237,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
                    "message": "PublicResolver.text (PublicResolver.sol#235-237) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 245,
                    "vulnerability_to_line": 247,
                    "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
                    "message": "PublicResolver.pubkey (PublicResolver.sol#245-247) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "PublicResolver.ABI (PublicResolver.sol#257-266) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": 276,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
                    "message": "PublicResolver.name (PublicResolver.sol#274-276) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 285,
                    "vulnerability_to_line": 287,
                    "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
                    "message": "PublicResolver.content (PublicResolver.sol#285-287) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": 296,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
                    "message": "PublicResolver.multihash (PublicResolver.sol#294-296) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": 305,
                    "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
                    "message": "PublicResolver.addr (PublicResolver.sol#303-305) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 312,
                    "vulnerability_to_line": 321,
                    "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
                    "message": "PublicResolver.supportsInterface (PublicResolver.sol#312-321) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": 266,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "Function 'PublicResolver.ABI' (PublicResolver.sol#257-266) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 131,
                    "vulnerability_to_line": 134,
                    "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
                    "message": "Modifier 'PublicResolver.only_owner' (PublicResolver.sol#131-134) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 87,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 174,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 185,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 198,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 224,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 235,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 257,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 95,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 96,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 97,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 99,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 100,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 101,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 102,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 127,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 129,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/claimable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 50,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_9"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (claimable.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 7,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (claimable.sol#7) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 8,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (claimable.sol#8) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (claimable.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 9,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (claimable.sol#9) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": 54,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (claimable.sol#45-54) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (claimable.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (claimable.sol#45) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 45,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (claimable.sol#45) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 3,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/controller.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_35"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Claimable._claim (controller.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (controller.sol#150)\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (controller.sol#92-94) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (controller.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (controller.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (controller.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (controller.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (controller.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (controller.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (controller.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (controller.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (controller.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (controller.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (controller.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (controller.sol#147-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (controller.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (controller.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (controller.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address) external view returns (bool);\n",
                    "message": "Parameter '' of IController.isController (controller.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isController (controller.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.addAdmin (controller.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.removeAdmin (controller.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.addController (controller.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.removeController (controller.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isAdmin (controller.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._addAdmin' (controller.sol#272-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addAdmin (controller.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeAdmin' (controller.sol#283-288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeAdmin (controller.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": 299,
                    "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._addController' (controller.sol#291-299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addController (controller.sol#291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 307,
                    "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeController' (controller.sol#302-307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeController (controller.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of Controller.claim (controller.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of Controller.claim (controller.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of Controller.claim (controller.sol#310) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _adminCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isController;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _controllerCount;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/ownable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_7"
            ],
            "vulnerability_findings": [
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (ownable.sol#92-94) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (ownable.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (ownable.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (ownable.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (ownable.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (ownable.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (ownable.sol#98) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/tokenWhitelistable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TokenWhitelist is ENSResolvable, Controllable, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (i < parts.length - 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ens = ensAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ensRegistry = _ensReg_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ens = ENS(_ensRegistry);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerNode = _controllerNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _oracleNode = _oracleNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _stablecoin = _stabelcoinAddress_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _tokenWhitelistNode = _tokenWhitelistNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1805,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenInfoMap[_tokens[i]] = Token({\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.push(_tokens[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delete _tokenInfoMap[token];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (_tokenAddressArray[j] == token) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require (_isController(msg.sender) || msg.sender == oracleAddress, \"either oracle or controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokenInfoMap[_token].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                data = record.abis[contentType];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (l = 0; ptr < end; l++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (idx = 0; idx <= selflen - needlelen; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            cnt++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "DOCKER_RECEIVED_SIGNAL_12"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Claimable._claim (tokenWhitelistable.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (tokenWhitelistable.sol#150)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 821,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy (tokenWhitelistable.sol#804-821) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": 834,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice (tokenWhitelistable.sol#828-834) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": 883,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 (tokenWhitelistable.sol#874-883) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString (tokenWhitelistable.sol#899-906) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len (tokenWhitelistable.sol#916-937) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare (tokenWhitelistable.sol#957-985) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune (tokenWhitelistable.sol#1004-1038) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord (tokenWhitelistable.sol#1055-1097) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak (tokenWhitelistable.sol#1104-1108) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1133,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith (tokenWhitelistable.sol#1116-1133) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1163,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond (tokenWhitelistable.sol#1142-1163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith (tokenWhitelistable.sol#1171-1190) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until (tokenWhitelistable.sol#1199-1219) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr (tokenWhitelistable.sol#1223-1260) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": 1300,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr (tokenWhitelistable.sol#1264-1300) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": 1442,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat (tokenWhitelistable.sol#1435-1442) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": 1474,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join (tokenWhitelistable.sol#1452-1474) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint ret;\n",
                    "message": "ret in strings.len (tokenWhitelistable.sol#842) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ tokenWhitelistable.sol#361) shadows:\n\t- ENS.owner (function @ tokenWhitelistable.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ tokenWhitelistable.sol#362) shadows:\n\t- ENS.resolver (function @ tokenWhitelistable.sol#366)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ tokenWhitelistable.sol#363) shadows:\n\t- ENS.owner (function @ tokenWhitelistable.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ tokenWhitelistable.sol#364) shadows:\n\t- ENS.ttl (function @ tokenWhitelistable.sol#367)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
                    "message": "PublicResolver.setAddr.addr (local variable @ tokenWhitelistable.sol#464) shadows:\n\t- PublicResolver.addr (function @ tokenWhitelistable.sol#617-619)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": "PublicResolver.setName.name (local variable @ tokenWhitelistable.sol#499) shadows:\n\t- PublicResolver.name (function @ tokenWhitelistable.sol#588-590)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": "strings.memcpy.len (local variable @ tokenWhitelistable.sol#804) shadows:\n\t- strings.len (function @ tokenWhitelistable.sol#841-865)\n\t- strings.len (function @ tokenWhitelistable.sol#916-937)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 821,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy uses assembly (tokenWhitelistable.sol#804-821)\n\t- tokenWhitelistable.sol#807-810\n\t- tokenWhitelistable.sol#816-821\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": 834,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice uses assembly (tokenWhitelistable.sol#828-834)\n\t- tokenWhitelistable.sol#830-833\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": 883,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 uses assembly (tokenWhitelistable.sol#874-883)\n\t- tokenWhitelistable.sol#876-882\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString uses assembly (tokenWhitelistable.sol#899-906)\n\t- tokenWhitelistable.sol#902-904\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len uses assembly (tokenWhitelistable.sol#916-937)\n\t- tokenWhitelistable.sol#922-923\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare uses assembly (tokenWhitelistable.sol#957-985)\n\t- tokenWhitelistable.sol#967-971\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune uses assembly (tokenWhitelistable.sol#1004-1038)\n\t- tokenWhitelistable.sol#1015-1016\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord uses assembly (tokenWhitelistable.sol#1055-1097)\n\t- tokenWhitelistable.sol#1065-1066\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak uses assembly (tokenWhitelistable.sol#1104-1108)\n\t- tokenWhitelistable.sol#1105-1108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1133,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith uses assembly (tokenWhitelistable.sol#1116-1133)\n\t- tokenWhitelistable.sol#1126-1132\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1163,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond uses assembly (tokenWhitelistable.sol#1142-1163)\n\t- tokenWhitelistable.sol#1149-1155\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith uses assembly (tokenWhitelistable.sol#1171-1190)\n\t- tokenWhitelistable.sol#1183-1189\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until uses assembly (tokenWhitelistable.sol#1199-1219)\n\t- tokenWhitelistable.sol#1207-1212\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr uses assembly (tokenWhitelistable.sol#1223-1260)\n\t- tokenWhitelistable.sol#1232-1234\n\t- tokenWhitelistable.sol#1236-1238\n\t- tokenWhitelistable.sol#1242-1243\n\t- tokenWhitelistable.sol#1248-1250\n\t- tokenWhitelistable.sol#1252-1253\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": 1300,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr uses assembly (tokenWhitelistable.sol#1264-1300)\n\t- tokenWhitelistable.sol#1272-1274\n\t- tokenWhitelistable.sol#1276-1278\n\t- tokenWhitelistable.sol#1282-1283\n\t- tokenWhitelistable.sol#1288-1289\n\t- tokenWhitelistable.sol#1292-1293\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": 1442,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat uses assembly (tokenWhitelistable.sol#1435-1442)\n\t- tokenWhitelistable.sol#1438-1439\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": 1474,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join uses assembly (tokenWhitelistable.sol#1452-1474)\n\t- tokenWhitelistable.sol#1462-1464\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": "Different versions of Solidity is used in tokenWhitelistable.sol:\n\t- Version used: ['>=0.4.24', '^0.4.14', '^0.4.24', '^0.4.25']\n\t- tokenWhitelistable.sol#21 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#105 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#135 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#179 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#344 declares pragma solidity>=0.4.24\n\t- tokenWhitelistable.sol#401 declares pragma solidity^0.4.24\n\t- tokenWhitelistable.sol#658 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#710 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#796 declares pragma solidity^0.4.14\n\t- tokenWhitelistable.sol#1504 declares pragma solidity^0.4.24\n\t- tokenWhitelistable.sol#1590 declares pragma solidity^0.4.25\n\t- tokenWhitelistable.sol#1792 declares pragma solidity^0.4.25\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (tokenWhitelistable.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
                    "message": "PublicResolver.setAddr (tokenWhitelistable.sol#464-467) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 480,
                    "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
                    "message": "PublicResolver.setContent (tokenWhitelistable.sol#477-480) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
                    "message": "PublicResolver.setMultihash (tokenWhitelistable.sol#488-491) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
                    "message": "PublicResolver.setName (tokenWhitelistable.sol#499-502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
                    "message": "PublicResolver.setABI (tokenWhitelistable.sol#512-518) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
                    "message": "PublicResolver.setPubkey (tokenWhitelistable.sol#526-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
                    "message": "PublicResolver.setText (tokenWhitelistable.sol#538-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
                    "message": "PublicResolver.text (tokenWhitelistable.sol#549-551) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 561,
                    "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
                    "message": "PublicResolver.pubkey (tokenWhitelistable.sol#559-561) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "PublicResolver.ABI (tokenWhitelistable.sol#571-580) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 590,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
                    "message": "PublicResolver.name (tokenWhitelistable.sol#588-590) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
                    "message": "PublicResolver.content (tokenWhitelistable.sol#599-601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
                    "message": "PublicResolver.multihash (tokenWhitelistable.sol#608-610) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": 619,
                    "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
                    "message": "PublicResolver.addr (tokenWhitelistable.sol#617-619) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
                    "message": "PublicResolver.supportsInterface (tokenWhitelistable.sol#626-635) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in tokenWhitelistable.sol:\n\t- pragma solidity^0.4.14 (tokenWhitelistable.sol#796): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (tokenWhitelistable.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (tokenWhitelistable.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (tokenWhitelistable.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (tokenWhitelistable.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (tokenWhitelistable.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (tokenWhitelistable.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (tokenWhitelistable.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (tokenWhitelistable.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (tokenWhitelistable.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (tokenWhitelistable.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (tokenWhitelistable.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (tokenWhitelistable.sol#147-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (tokenWhitelistable.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (tokenWhitelistable.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (tokenWhitelistable.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address) external view returns (bool);\n",
                    "message": "Parameter '' of IController.isController (tokenWhitelistable.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isController (tokenWhitelistable.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.addAdmin (tokenWhitelistable.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.removeAdmin (tokenWhitelistable.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.addController (tokenWhitelistable.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.removeController (tokenWhitelistable.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isAdmin (tokenWhitelistable.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._addAdmin' (tokenWhitelistable.sol#272-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addAdmin (tokenWhitelistable.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeAdmin' (tokenWhitelistable.sol#283-288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeAdmin (tokenWhitelistable.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": 299,
                    "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._addController' (tokenWhitelistable.sol#291-299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addController (tokenWhitelistable.sol#291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 307,
                    "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeController' (tokenWhitelistable.sol#302-307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeController (tokenWhitelistable.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of Controller.claim (tokenWhitelistable.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of Controller.claim (tokenWhitelistable.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of Controller.claim (tokenWhitelistable.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "Function 'PublicResolver.ABI' (tokenWhitelistable.sol#571-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
                    "message": "Modifier 'PublicResolver.only_owner' (tokenWhitelistable.sol#445-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Parameter '_ensReg_' of ENSResolvable. (tokenWhitelistable.sol#671) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 686,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n\n        return PublicResolver(_ens.resolver(_nodeHash)).addr(_nodeHash);\n",
                    "message": "Function 'ENSResolvable._ensResolve' (tokenWhitelistable.sol#684-686) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n",
                    "message": "Parameter '_nodeHash' of ENSResolvable._ensResolve (tokenWhitelistable.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Parameter '_controllerNameHash_' of Controllable. (tokenWhitelistable.sol#720) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 738,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n",
                    "message": "Function 'Controllable._isController' (tokenWhitelistable.sol#736-738) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n",
                    "message": "Parameter '_account' of Controllable._isController (tokenWhitelistable.sol#736) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": 1475,
                    "vulnerability_code": "library strings {\n\n    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n\n    }\n\n\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire string.\n\n     * @param self The string to make a slice from.\n\n     * @return A newly allocated slice containing the entire string.\n\n     */\n\n    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length of a null-terminated bytes32 string.\n\n     * @param self The value to find the length of.\n\n     * @return The length of the string, from 0 to 32.\n\n     */\n\n    function len(bytes32 self) internal pure returns (uint) {\n\n        uint ret;\n\n        if (self == 0)\n\n            return 0;\n\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n\n            ret += 16;\n\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n\n        }\n\n        if (self & 0xffffffffffffffff == 0) {\n\n            ret += 8;\n\n            self = bytes32(uint(self) / 0x10000000000000000);\n\n        }\n\n        if (self & 0xffffffff == 0) {\n\n            ret += 4;\n\n            self = bytes32(uint(self) / 0x100000000);\n\n        }\n\n        if (self & 0xffff == 0) {\n\n            ret += 2;\n\n            self = bytes32(uint(self) / 0x10000);\n\n        }\n\n        if (self & 0xff == 0) {\n\n            ret += 1;\n\n        }\n\n        return 32 - ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n\n     *      null-terminated utf-8 string.\n\n     * @param self The bytes32 value to convert to a slice.\n\n     * @return A new slice containing the value of the input argument up to the\n\n     *         first null.\n\n     */\n\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a new slice containing the same data as the current slice.\n\n     * @param self The slice to copy.\n\n     * @return A new slice containing the same data as `self`.\n\n     */\n\n    function copy(slice memory self) internal pure returns (slice memory) {\n\n        return slice(self._len, self._ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Copies a slice to a new string.\n\n     * @param self The slice to copy.\n\n     * @return A newly allocated string containing the slice's text.\n\n     */\n\n    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length in runes of the slice. Note that this operation\n\n     *      takes time proportional to the length of the slice; avoid using it\n\n     *      in loops, and call `slice.empty()` if you only need to know whether\n\n     *      the slice is empty or not.\n\n     * @param self The slice to operate on.\n\n     * @return The length of the slice in runes.\n\n     */\n\n    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice is empty (has a length of 0).\n\n     * @param self The slice to operate on.\n\n     * @return True if the slice is empty, False otherwise.\n\n     */\n\n    function empty(slice memory self) internal pure returns (bool) {\n\n        return self._len == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a positive number if `other` comes lexicographically after\n\n     *      `self`, a negative number if it comes before, or zero if the\n\n     *      contents of the two slices are equal. Comparison is done per-rune,\n\n     *      on unicode codepoints.\n\n     * @param self The first slice to compare.\n\n     * @param other The second slice to compare.\n\n     * @return The result of the comparison.\n\n     */\n\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the two slices contain the same text.\n\n     * @param self The first slice to compare.\n\n     * @param self The second slice to compare.\n\n     * @return True if the slices are equal, false otherwise.\n\n     */\n\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n\n        return compare(self, other) == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n\n     *      slice to point to the next rune and returning `self`.\n\n     * @param self The slice to operate on.\n\n     * @param rune The slice that will contain the first rune.\n\n     * @return `rune`.\n\n     */\n\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the first rune in the slice, advancing the slice to point\n\n     *      to the next rune.\n\n     * @param self The slice to operate on.\n\n     * @return A slice containing only the first rune from `self`.\n\n     */\n\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n\n        nextRune(self, ret);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the number of the first codepoint in the slice.\n\n     * @param self The slice to operate on.\n\n     * @return The number of the first codepoint in the slice.\n\n     */\n\n    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the keccak-256 hash of the slice.\n\n     * @param self The slice to hash.\n\n     * @return The hash of the slice.\n\n     */\n\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if `self` starts with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice ends with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n\n     *      end of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    // Returns the memory address of the first byte of the first occurrence of\n\n    // `needle` in `self`, or the first byte after `self` if not found.\n\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n\n    }\n\n\n\n    // Returns the memory address of the first byte after the last occurrence of\n\n    // `needle` in `self`, or the address of `self` if not found.\n\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain everything from the first occurrence of\n\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n\n     *      if `needle` is not found.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len -= ptr - self._ptr;\n\n        self._ptr = ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain the part of the string from the start of\n\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n\n     *      is not found, `self` is set to the empty slice.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len = ptr - self._ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and `token` to everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = self._ptr;\n\n        token._len = ptr - self._ptr;\n\n        if (ptr == self._ptr + self._len) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n            self._ptr = ptr + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and returning everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` up to the first occurrence of `delim`.\n\n     */\n\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        split(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and `token` to everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = ptr;\n\n        token._len = self._len - (ptr - self._ptr);\n\n        if (ptr == self._ptr) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and returning everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` after the last occurrence of `delim`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        rsplit(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The number of occurrences of `needle` found in `self`.\n\n     */\n\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n\n        while (ptr <= self._ptr + self._len) {\n\n            cnt++;\n\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns True if `self` contains `needle`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return True if `needle` is found in `self`, false otherwise.\n\n     */\n\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a newly allocated string containing the concatenation of\n\n     *      `self` and `other`.\n\n     * @param self The first slice to concatenate.\n\n     * @param other The second slice to concatenate.\n\n     * @return The concatenation of the two strings.\n\n     */\n\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n\n     *      newly allocated string.\n\n     * @param self The delimiter to use.\n\n     * @param parts A list of slices to join.\n\n     * @return A newly allocated string containing all the slices in `parts`,\n\n     *         joined with `self`.\n\n     */\n\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n\n    }\n",
                    "message": "Contract 'strings' (tokenWhitelistable.sol#798-1475) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n",
                    "message": "Struct 'strings.slice' (tokenWhitelistable.sol#799-802) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address) external view returns (string, uint256, uint256, bool, bool, bool, uint256);\n",
                    "message": "Parameter '' of ITokenWhitelist.getTokenInfo (tokenWhitelistable.sol#1598) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '' of ITokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_0' of ITokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_1' of ITokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_oracleNameHash_' of TokenWhitelist. (tokenWhitelistable.sol#1644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_stabelcoinAddress_' of TokenWhitelist. (tokenWhitelistable.sol#1644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_symbols' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_magnitude' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_loadable' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_burnable' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_lastUpdate' of TokenWhitelist.addTokens (tokenWhitelistable.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokens(address[] _tokens) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.removeTokens (tokenWhitelistable.sol#1684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_token' of TokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_rate' of TokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelist.updateTokenRate (tokenWhitelistable.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of TokenWhitelist.claim (tokenWhitelistable.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of TokenWhitelist.claim (tokenWhitelistable.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of TokenWhitelist.claim (tokenWhitelistable.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address _a) external view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelist.getTokenInfo (tokenWhitelistable.sol#1735) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1803,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _tokenWhitelistNameHash_) internal {\n",
                    "message": "Parameter '_tokenWhitelistNameHash_' of TokenWhitelistable. (tokenWhitelistable.sol#1803) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": 1824,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getTokenInfo(_a);\n",
                    "message": "Function 'TokenWhitelistable._getTokenInfo' (tokenWhitelistable.sol#1822-1824) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._getTokenInfo (tokenWhitelistable.sol#1822) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": 1836,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).getStablecoinInfo();\n",
                    "message": "Function 'TokenWhitelistable._getStablecoinInfo' (tokenWhitelistable.sol#1834-1836) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1840,
                    "vulnerability_to_line": 1842,
                    "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).tokenAddressArray();\n",
                    "message": "Function 'TokenWhitelistable._tokenAddressArray' (tokenWhitelistable.sol#1840-1842) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": 1850,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n\n        ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).updateTokenRate(_token, _rate, _updateDate);\n",
                    "message": "Function 'TokenWhitelistable._updateTokenRate' (tokenWhitelistable.sol#1848-1850) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_token' of TokenWhitelistable._updateTokenRate (tokenWhitelistable.sol#1848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_rate' of TokenWhitelistable._updateTokenRate (tokenWhitelistable.sol#1848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1848,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _updateTokenRate(address _token, uint _rate, uint _updateDate) internal {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelistable._updateTokenRate (tokenWhitelistable.sol#1848) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1854,
                    "vulnerability_to_line": 1857,
                    "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n\n        ( , , , bool available, , , ) = _getTokenInfo(_a);\n\n        return available;\n",
                    "message": "Function 'TokenWhitelistable._isTokenAvailable' (tokenWhitelistable.sol#1854-1857) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1854,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenAvailable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenAvailable (tokenWhitelistable.sol#1854) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1861,
                    "vulnerability_to_line": 1864,
                    "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n\n        ( , , , , , bool burnable, ) = _getTokenInfo(_a);\n\n        return burnable;\n",
                    "message": "Function 'TokenWhitelistable._isTokenBurnable' (tokenWhitelistable.sol#1861-1864) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenBurnable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenBurnable (tokenWhitelistable.sol#1861) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1868,
                    "vulnerability_to_line": 1871,
                    "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n\n        ( , , , , bool loadable, , ) = _getTokenInfo(_a);\n\n        return loadable;\n",
                    "message": "Function 'TokenWhitelistable._isTokenLoadable' (tokenWhitelistable.sol#1868-1871) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1868,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isTokenLoadable(address _a) internal view returns (bool) {\n",
                    "message": "Parameter '_a' of TokenWhitelistable._isTokenLoadable (tokenWhitelistable.sol#1868) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1875,
                    "vulnerability_to_line": 1877,
                    "vulnerability_code": "    function _stablecoin() internal view returns (address) {\n\n        return ITokenWhitelist(_ensResolve(_tokenWhitelistNode)).stablecoin();\n",
                    "message": "Function 'TokenWhitelistable._stablecoin' (tokenWhitelistable.sol#1875-1877) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF8) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xFC) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1018,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1071,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x1F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1077,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x07;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b = (word / divisor) & 0xFF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = (ret * 64) | (b & 0x3F);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptr >= selfptr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (ptr <= self._ptr + self._len) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1792,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _adminCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isController;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _controllerCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS private _ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _ensRegistry;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _controllerNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => Token) private _tokenInfoMap;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] private _tokenAddressArray;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _stablecoin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _oracleNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1799,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _tokenWhitelistNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1822,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getTokenInfo(address _a) internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1834,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _getStablecoinInfo() internal view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 1840,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _tokenAddressArray() internal view returns (address[]) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 876,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { b := and(mload(ptr), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 967,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { word:= mload(mload(add(self, 32))) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/date.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 70,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            revert(\"not a valid month\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_2"
            ],
            "vulnerability_findings": [
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": 72,
                    "vulnerability_code": "    function _monthToNumber(string _month) internal pure returns (uint8) {\n\n        bytes32 month = keccak256(abi.encodePacked(_month));\n\n        if (month == _JANUARY) {\n\n            return 1;\n\n        } else if (month == _FEBRUARY) {\n\n            return 2;\n\n        } else if (month == _MARCH) {\n\n            return 3;\n\n        } else if (month == _APRIL) {\n\n            return 4;\n\n        } else if (month == _MAY) {\n\n            return 5;\n\n        } else if (month == _JUNE) {\n\n            return 6;\n\n        } else if (month == _JULY) {\n\n            return 7;\n\n        } else if (month == _AUGUST) {\n\n            return 8;\n\n        } else if (month == _SEPTEMBER) {\n\n            return 9;\n\n        } else if (month == _OCTOBER) {\n\n            return 10;\n\n        } else if (month == _NOVEMBER) {\n\n            return 11;\n\n        } else if (month == _DECEMBER) {\n\n            return 12;\n\n        } else {\n\n            revert(\"not a valid month\");\n\n        }\n",
                    "message": "Function 'Date._monthToNumber' (date.sol#43-72) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _monthToNumber(string _month) internal pure returns (uint8) {\n",
                    "message": "Parameter '_month' of Date._monthToNumber (date.sol#43) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 28,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _JANUARY = keccak256(\"Jan\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 29,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _FEBRUARY = keccak256(\"Feb\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 30,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _MARCH = keccak256(\"Mar\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 31,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _APRIL = keccak256(\"Apr\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _MAY = keccak256(\"May\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _JUNE = keccak256(\"Jun\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 34,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _JULY = keccak256(\"Jul\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 35,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _AUGUST = keccak256(\"Aug\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _SEPTEMBER = keccak256(\"Sep\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _OCTOBER = keccak256(\"Oct\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _NOVEMBER = keccak256(\"Nov\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 constant private _DECEMBER = keccak256(\"Dec\");\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_REVERT_REQUIRE",
                    "vulnerability_from_line": 67,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if (month == _DECEMBER) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _monthToNumber(string _month) internal pure returns (uint8) {\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/tokenWhitelist.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 1607,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract TokenWhitelist is ENSResolvable, Controllable, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1467,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (i < parts.length - 1) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ens = ensAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ensRegistry = _ensReg_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ens = ENS(_ensRegistry);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerNode = _controllerNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1645,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _oracleNode = _oracleNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1646,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _stablecoin = _stabelcoinAddress_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 1647,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1666,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenInfoMap[_tokens[i]] = Token({\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1676,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.push(_tokens[i]);\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1692,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            delete _tokenInfoMap[token];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1695,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                if (_tokenAddressArray[j] == token) {\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1696,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    _tokenAddressArray[j] = _tokenAddressArray[_tokenAddressArray.length.sub(1)];\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "state-variable-read-in-a-loop",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Replace state variable reads and writes within loops with local variable reads and writes."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "unnecessary-checked-arithmetic-in-loop",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1631,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require (_isController(msg.sender) || msg.sender == oracleAddress, \"either oracle or controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1662,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(!_tokenInfoMap[_tokens[i]].available, \"token already available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1688,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(_tokenInfoMap[_tokens[i]].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 1712,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokenInfoMap[_token].available, \"token is not available\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-multiple-require",
                    "vulnerability_from_line": 1658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length && _tokens.length == _loadable.length && _tokens.length == _loadable.length, \"parameter lengths do not match\");\n",
                    "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                data = record.abis[contentType];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1281,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 920,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (l = 0; ptr < end; l++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1086,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 1; i < length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1241,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    ptr++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1250,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                for (idx = 0; idx <= selflen - needlelen; idx++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            cnt++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_124"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Claimable._claim (tokenWhitelist.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (tokenWhitelist.sol#150)\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 821,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy (tokenWhitelist.sol#804-821) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": 834,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice (tokenWhitelist.sol#828-834) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": 883,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 (tokenWhitelist.sol#874-883) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString (tokenWhitelist.sol#899-906) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len (tokenWhitelist.sol#916-937) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare (tokenWhitelist.sol#957-985) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune (tokenWhitelist.sol#1004-1038) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord (tokenWhitelist.sol#1055-1097) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak (tokenWhitelist.sol#1104-1108) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1133,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith (tokenWhitelist.sol#1116-1133) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1163,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond (tokenWhitelist.sol#1142-1163) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith (tokenWhitelist.sol#1171-1190) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until (tokenWhitelist.sol#1199-1219) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr (tokenWhitelist.sol#1223-1260) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": 1300,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr (tokenWhitelist.sol#1264-1300) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": 1442,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat (tokenWhitelist.sol#1435-1442) is declared view but contains assembly code\n"
                },
                {
                    "name": "constant-function",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": 1474,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join (tokenWhitelist.sol#1452-1474) is declared view but contains assembly code\n"
                },
                {
                    "name": "uninitialized-local",
                    "vulnerability_from_line": 842,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        uint ret;\n",
                    "message": "ret in strings.len (tokenWhitelist.sol#842) is a local variable never initialiazed\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ tokenWhitelist.sol#361) shadows:\n\t- ENS.owner (function @ tokenWhitelist.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ tokenWhitelist.sol#362) shadows:\n\t- ENS.resolver (function @ tokenWhitelist.sol#366)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ tokenWhitelist.sol#363) shadows:\n\t- ENS.owner (function @ tokenWhitelist.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ tokenWhitelist.sol#364) shadows:\n\t- ENS.ttl (function @ tokenWhitelist.sol#367)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
                    "message": "PublicResolver.setAddr.addr (local variable @ tokenWhitelist.sol#464) shadows:\n\t- PublicResolver.addr (function @ tokenWhitelist.sol#617-619)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": "PublicResolver.setName.name (local variable @ tokenWhitelist.sol#499) shadows:\n\t- PublicResolver.name (function @ tokenWhitelist.sol#588-590)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": "strings.memcpy.len (local variable @ tokenWhitelist.sol#804) shadows:\n\t- strings.len (function @ tokenWhitelist.sol#841-865)\n\t- strings.len (function @ tokenWhitelist.sol#916-937)\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": 821,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n",
                    "message": "strings.memcpy uses assembly (tokenWhitelist.sol#804-821)\n\t- tokenWhitelist.sol#807-810\n\t- tokenWhitelist.sol#816-821\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": 834,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n",
                    "message": "strings.toSlice uses assembly (tokenWhitelist.sol#828-834)\n\t- tokenWhitelist.sol#830-833\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": 883,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n",
                    "message": "strings.toSliceB32 uses assembly (tokenWhitelist.sol#874-883)\n\t- tokenWhitelist.sol#876-882\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": 906,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n",
                    "message": "strings.toString uses assembly (tokenWhitelist.sol#899-906)\n\t- tokenWhitelist.sol#902-904\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": 937,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n",
                    "message": "strings.len uses assembly (tokenWhitelist.sol#916-937)\n\t- tokenWhitelist.sol#922-923\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": 985,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n",
                    "message": "strings.compare uses assembly (tokenWhitelist.sol#957-985)\n\t- tokenWhitelist.sol#967-971\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": 1038,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n",
                    "message": "strings.nextRune uses assembly (tokenWhitelist.sol#1004-1038)\n\t- tokenWhitelist.sol#1015-1016\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": 1097,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.ord uses assembly (tokenWhitelist.sol#1055-1097)\n\t- tokenWhitelist.sol#1065-1066\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": 1108,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n",
                    "message": "strings.keccak uses assembly (tokenWhitelist.sol#1104-1108)\n\t- tokenWhitelist.sol#1105-1108\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": 1133,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n",
                    "message": "strings.startsWith uses assembly (tokenWhitelist.sol#1116-1133)\n\t- tokenWhitelist.sol#1126-1132\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": 1163,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.beyond uses assembly (tokenWhitelist.sol#1142-1163)\n\t- tokenWhitelist.sol#1149-1155\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": 1190,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n",
                    "message": "strings.endsWith uses assembly (tokenWhitelist.sol#1171-1190)\n\t- tokenWhitelist.sol#1183-1189\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": 1219,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n",
                    "message": "strings.until uses assembly (tokenWhitelist.sol#1199-1219)\n\t- tokenWhitelist.sol#1207-1212\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": 1260,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n",
                    "message": "strings.findPtr uses assembly (tokenWhitelist.sol#1223-1260)\n\t- tokenWhitelist.sol#1232-1234\n\t- tokenWhitelist.sol#1236-1238\n\t- tokenWhitelist.sol#1242-1243\n\t- tokenWhitelist.sol#1248-1250\n\t- tokenWhitelist.sol#1252-1253\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": 1300,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n",
                    "message": "strings.rfindPtr uses assembly (tokenWhitelist.sol#1264-1300)\n\t- tokenWhitelist.sol#1272-1274\n\t- tokenWhitelist.sol#1276-1278\n\t- tokenWhitelist.sol#1282-1283\n\t- tokenWhitelist.sol#1288-1289\n\t- tokenWhitelist.sol#1292-1293\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": 1442,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n",
                    "message": "strings.concat uses assembly (tokenWhitelist.sol#1435-1442)\n\t- tokenWhitelist.sol#1438-1439\n"
                },
                {
                    "name": "assembly",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": 1474,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n",
                    "message": "strings.join uses assembly (tokenWhitelist.sol#1452-1474)\n\t- tokenWhitelist.sol#1462-1464\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": "Different versions of Solidity is used in tokenWhitelist.sol:\n\t- Version used: ['>=0.4.24', '^0.4.14', '^0.4.24', '^0.4.25']\n\t- tokenWhitelist.sol#21 declares pragma solidity^0.4.25\n\t- tokenWhitelist.sol#105 declares pragma solidity^0.4.25\n\t- tokenWhitelist.sol#135 declares pragma solidity^0.4.25\n\t- tokenWhitelist.sol#179 declares pragma solidity^0.4.25\n\t- tokenWhitelist.sol#344 declares pragma solidity>=0.4.24\n\t- tokenWhitelist.sol#401 declares pragma solidity^0.4.24\n\t- tokenWhitelist.sol#658 declares pragma solidity^0.4.25\n\t- tokenWhitelist.sol#710 declares pragma solidity^0.4.25\n\t- tokenWhitelist.sol#796 declares pragma solidity^0.4.14\n\t- tokenWhitelist.sol#1504 declares pragma solidity^0.4.24\n\t- tokenWhitelist.sol#1590 declares pragma solidity^0.4.25\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (tokenWhitelist.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
                    "message": "PublicResolver.setAddr (tokenWhitelist.sol#464-467) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 480,
                    "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
                    "message": "PublicResolver.setContent (tokenWhitelist.sol#477-480) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
                    "message": "PublicResolver.setMultihash (tokenWhitelist.sol#488-491) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
                    "message": "PublicResolver.setName (tokenWhitelist.sol#499-502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
                    "message": "PublicResolver.setABI (tokenWhitelist.sol#512-518) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
                    "message": "PublicResolver.setPubkey (tokenWhitelist.sol#526-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
                    "message": "PublicResolver.setText (tokenWhitelist.sol#538-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
                    "message": "PublicResolver.text (tokenWhitelist.sol#549-551) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 561,
                    "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
                    "message": "PublicResolver.pubkey (tokenWhitelist.sol#559-561) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "PublicResolver.ABI (tokenWhitelist.sol#571-580) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 590,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
                    "message": "PublicResolver.name (tokenWhitelist.sol#588-590) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
                    "message": "PublicResolver.content (tokenWhitelist.sol#599-601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
                    "message": "PublicResolver.multihash (tokenWhitelist.sol#608-610) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": 619,
                    "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
                    "message": "PublicResolver.addr (tokenWhitelist.sol#617-619) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
                    "message": "PublicResolver.supportsInterface (tokenWhitelist.sol#626-635) should be declared external\n"
                },
                {
                    "name": "solc-version",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": "Detected issues with version pragma in tokenWhitelist.sol:\n\t- pragma solidity^0.4.14 (tokenWhitelist.sol#796): it allows old versions\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (tokenWhitelist.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (tokenWhitelist.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (tokenWhitelist.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (tokenWhitelist.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (tokenWhitelist.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (tokenWhitelist.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (tokenWhitelist.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (tokenWhitelist.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (tokenWhitelist.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (tokenWhitelist.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (tokenWhitelist.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (tokenWhitelist.sol#147-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (tokenWhitelist.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (tokenWhitelist.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (tokenWhitelist.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address) external view returns (bool);\n",
                    "message": "Parameter '' of IController.isController (tokenWhitelist.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isController (tokenWhitelist.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.addAdmin (tokenWhitelist.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.removeAdmin (tokenWhitelist.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.addController (tokenWhitelist.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.removeController (tokenWhitelist.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isAdmin (tokenWhitelist.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._addAdmin' (tokenWhitelist.sol#272-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addAdmin (tokenWhitelist.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeAdmin' (tokenWhitelist.sol#283-288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeAdmin (tokenWhitelist.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": 299,
                    "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._addController' (tokenWhitelist.sol#291-299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addController (tokenWhitelist.sol#291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 307,
                    "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeController' (tokenWhitelist.sol#302-307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeController (tokenWhitelist.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of Controller.claim (tokenWhitelist.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of Controller.claim (tokenWhitelist.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of Controller.claim (tokenWhitelist.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "Function 'PublicResolver.ABI' (tokenWhitelist.sol#571-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
                    "message": "Modifier 'PublicResolver.only_owner' (tokenWhitelist.sol#445-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Parameter '_ensReg_' of ENSResolvable. (tokenWhitelist.sol#671) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 686,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n\n        return PublicResolver(_ens.resolver(_nodeHash)).addr(_nodeHash);\n",
                    "message": "Function 'ENSResolvable._ensResolve' (tokenWhitelist.sol#684-686) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n",
                    "message": "Parameter '_nodeHash' of ENSResolvable._ensResolve (tokenWhitelist.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Parameter '_controllerNameHash_' of Controllable. (tokenWhitelist.sol#720) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 738,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n",
                    "message": "Function 'Controllable._isController' (tokenWhitelist.sol#736-738) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n",
                    "message": "Parameter '_account' of Controllable._isController (tokenWhitelist.sol#736) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 798,
                    "vulnerability_to_line": 1475,
                    "vulnerability_code": "library strings {\n\n    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n\n    }\n\n\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n\n        // Copy word-length chunks while possible\n\n        for(; len >= 32; len -= 32) {\n\n            assembly {\n\n                mstore(dest, mload(src))\n\n            }\n\n            dest += 32;\n\n            src += 32;\n\n        }\n\n\n\n        // Copy remaining bytes\n\n        uint mask = 256 ** (32 - len) - 1;\n\n        assembly {\n\n            let srcpart := and(mload(src), not(mask))\n\n            let destpart := and(mload(dest), mask)\n\n            mstore(dest, or(destpart, srcpart))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire string.\n\n     * @param self The string to make a slice from.\n\n     * @return A newly allocated slice containing the entire string.\n\n     */\n\n    function toSlice(string memory self) internal pure returns (slice memory) {\n\n        uint ptr;\n\n        assembly {\n\n            ptr := add(self, 0x20)\n\n        }\n\n        return slice(bytes(self).length, ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length of a null-terminated bytes32 string.\n\n     * @param self The value to find the length of.\n\n     * @return The length of the string, from 0 to 32.\n\n     */\n\n    function len(bytes32 self) internal pure returns (uint) {\n\n        uint ret;\n\n        if (self == 0)\n\n            return 0;\n\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n\n            ret += 16;\n\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n\n        }\n\n        if (self & 0xffffffffffffffff == 0) {\n\n            ret += 8;\n\n            self = bytes32(uint(self) / 0x10000000000000000);\n\n        }\n\n        if (self & 0xffffffff == 0) {\n\n            ret += 4;\n\n            self = bytes32(uint(self) / 0x100000000);\n\n        }\n\n        if (self & 0xffff == 0) {\n\n            ret += 2;\n\n            self = bytes32(uint(self) / 0x10000);\n\n        }\n\n        if (self & 0xff == 0) {\n\n            ret += 1;\n\n        }\n\n        return 32 - ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n\n     *      null-terminated utf-8 string.\n\n     * @param self The bytes32 value to convert to a slice.\n\n     * @return A new slice containing the value of the input argument up to the\n\n     *         first null.\n\n     */\n\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n\n        assembly {\n\n            let ptr := mload(0x40)\n\n            mstore(0x40, add(ptr, 0x20))\n\n            mstore(ptr, self)\n\n            mstore(add(ret, 0x20), ptr)\n\n        }\n\n        ret._len = len(self);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a new slice containing the same data as the current slice.\n\n     * @param self The slice to copy.\n\n     * @return A new slice containing the same data as `self`.\n\n     */\n\n    function copy(slice memory self) internal pure returns (slice memory) {\n\n        return slice(self._len, self._ptr);\n\n    }\n\n\n\n    /*\n\n     * @dev Copies a slice to a new string.\n\n     * @param self The slice to copy.\n\n     * @return A newly allocated string containing the slice's text.\n\n     */\n\n    function toString(slice memory self) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        memcpy(retptr, self._ptr, self._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the length in runes of the slice. Note that this operation\n\n     *      takes time proportional to the length of the slice; avoid using it\n\n     *      in loops, and call `slice.empty()` if you only need to know whether\n\n     *      the slice is empty or not.\n\n     * @param self The slice to operate on.\n\n     * @return The length of the slice in runes.\n\n     */\n\n    function len(slice memory self) internal pure returns (uint l) {\n\n        // Starting at ptr-31 means the LSB will be the byte we care about\n\n        uint ptr = self._ptr - 31;\n\n        uint end = ptr + self._len;\n\n        for (l = 0; ptr < end; l++) {\n\n            uint8 b;\n\n            assembly { b := and(mload(ptr), 0xFF) }\n\n            if (b < 0x80) {\n\n                ptr += 1;\n\n            } else if(b < 0xE0) {\n\n                ptr += 2;\n\n            } else if(b < 0xF0) {\n\n                ptr += 3;\n\n            } else if(b < 0xF8) {\n\n                ptr += 4;\n\n            } else if(b < 0xFC) {\n\n                ptr += 5;\n\n            } else {\n\n                ptr += 6;\n\n            }\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice is empty (has a length of 0).\n\n     * @param self The slice to operate on.\n\n     * @return True if the slice is empty, False otherwise.\n\n     */\n\n    function empty(slice memory self) internal pure returns (bool) {\n\n        return self._len == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a positive number if `other` comes lexicographically after\n\n     *      `self`, a negative number if it comes before, or zero if the\n\n     *      contents of the two slices are equal. Comparison is done per-rune,\n\n     *      on unicode codepoints.\n\n     * @param self The first slice to compare.\n\n     * @param other The second slice to compare.\n\n     * @return The result of the comparison.\n\n     */\n\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n\n        uint shortest = self._len;\n\n        if (other._len < self._len)\n\n            shortest = other._len;\n\n\n\n        uint selfptr = self._ptr;\n\n        uint otherptr = other._ptr;\n\n        for (uint idx = 0; idx < shortest; idx += 32) {\n\n            uint a;\n\n            uint b;\n\n            assembly {\n\n                a := mload(selfptr)\n\n                b := mload(otherptr)\n\n            }\n\n            if (a != b) {\n\n                // Mask out irrelevant bytes and check again\n\n                uint256 mask = uint256(-1); // 0xffff...\n\n                if(shortest < 32) {\n\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n\n                }\n\n                uint256 diff = (a & mask) - (b & mask);\n\n                if (diff != 0)\n\n                    return int(diff);\n\n            }\n\n            selfptr += 32;\n\n            otherptr += 32;\n\n        }\n\n        return int(self._len) - int(other._len);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the two slices contain the same text.\n\n     * @param self The first slice to compare.\n\n     * @param self The second slice to compare.\n\n     * @return True if the slices are equal, false otherwise.\n\n     */\n\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n\n        return compare(self, other) == 0;\n\n    }\n\n\n\n    /*\n\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n\n     *      slice to point to the next rune and returning `self`.\n\n     * @param self The slice to operate on.\n\n     * @param rune The slice that will contain the first rune.\n\n     * @return `rune`.\n\n     */\n\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n\n        rune._ptr = self._ptr;\n\n\n\n        if (self._len == 0) {\n\n            rune._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        uint l;\n\n        uint b;\n\n        // Load the first byte of the rune into the LSBs of b\n\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n\n        if (b < 0x80) {\n\n            l = 1;\n\n        } else if(b < 0xE0) {\n\n            l = 2;\n\n        } else if(b < 0xF0) {\n\n            l = 3;\n\n        } else {\n\n            l = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (l > self._len) {\n\n            rune._len = self._len;\n\n            self._ptr += self._len;\n\n            self._len = 0;\n\n            return rune;\n\n        }\n\n\n\n        self._ptr += l;\n\n        self._len -= l;\n\n        rune._len = l;\n\n        return rune;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the first rune in the slice, advancing the slice to point\n\n     *      to the next rune.\n\n     * @param self The slice to operate on.\n\n     * @return A slice containing only the first rune from `self`.\n\n     */\n\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n\n        nextRune(self, ret);\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the number of the first codepoint in the slice.\n\n     * @param self The slice to operate on.\n\n     * @return The number of the first codepoint in the slice.\n\n     */\n\n    function ord(slice memory self) internal pure returns (uint ret) {\n\n        if (self._len == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint word;\n\n        uint length;\n\n        uint divisor = 2 ** 248;\n\n\n\n        // Load the rune into the MSBs of b\n\n        assembly { word:= mload(mload(add(self, 32))) }\n\n        uint b = word / divisor;\n\n        if (b < 0x80) {\n\n            ret = b;\n\n            length = 1;\n\n        } else if(b < 0xE0) {\n\n            ret = b & 0x1F;\n\n            length = 2;\n\n        } else if(b < 0xF0) {\n\n            ret = b & 0x0F;\n\n            length = 3;\n\n        } else {\n\n            ret = b & 0x07;\n\n            length = 4;\n\n        }\n\n\n\n        // Check for truncated codepoints\n\n        if (length > self._len) {\n\n            return 0;\n\n        }\n\n\n\n        for (uint i = 1; i < length; i++) {\n\n            divisor = divisor / 256;\n\n            b = (word / divisor) & 0xFF;\n\n            if (b & 0xC0 != 0x80) {\n\n                // Invalid UTF-8 sequence\n\n                return 0;\n\n            }\n\n            ret = (ret * 64) | (b & 0x3F);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns the keccak-256 hash of the slice.\n\n     * @param self The slice to hash.\n\n     * @return The hash of the slice.\n\n     */\n\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n\n        assembly {\n\n            ret := keccak256(mload(add(self, 32)), mload(self))\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if `self` starts with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        if (self._ptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let selfptr := mload(add(self, 0x20))\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        bool equal = true;\n\n        if (self._ptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let selfptr := mload(add(self, 0x20))\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n            self._ptr += needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns true if the slice ends with `needle`.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return True if the slice starts with the provided text, false otherwise.\n\n     */\n\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        if (self._len < needle._len) {\n\n            return false;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n\n\n        if (selfptr == needle._ptr) {\n\n            return true;\n\n        }\n\n\n\n        bool equal;\n\n        assembly {\n\n            let length := mload(needle)\n\n            let needleptr := mload(add(needle, 0x20))\n\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n        }\n\n\n\n        return equal;\n\n    }\n\n\n\n    /*\n\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n\n     *      end of `self`. Otherwise, `self` is unmodified.\n\n     * @param self The slice to operate on.\n\n     * @param needle The slice to search for.\n\n     * @return `self`\n\n     */\n\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        if (self._len < needle._len) {\n\n            return self;\n\n        }\n\n\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        bool equal = true;\n\n        if (selfptr != needle._ptr) {\n\n            assembly {\n\n                let length := mload(needle)\n\n                let needleptr := mload(add(needle, 0x20))\n\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n\n            }\n\n        }\n\n\n\n        if (equal) {\n\n            self._len -= needle._len;\n\n        }\n\n\n\n        return self;\n\n    }\n\n\n\n    // Returns the memory address of the first byte of the first occurrence of\n\n    // `needle` in `self`, or the first byte after `self` if not found.\n\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr = selfptr;\n\n        uint idx;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                uint end = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr >= end)\n\n                        return selfptr + selflen;\n\n                    ptr++;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr;\n\n                    ptr += 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr + selflen;\n\n    }\n\n\n\n    // Returns the memory address of the first byte after the last occurrence of\n\n    // `needle` in `self`, or the address of `self` if not found.\n\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n\n        uint ptr;\n\n\n\n        if (needlelen <= selflen) {\n\n            if (needlelen <= 32) {\n\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n\n\n\n                bytes32 needledata;\n\n                assembly { needledata := and(mload(needleptr), mask) }\n\n\n\n                ptr = selfptr + selflen - needlelen;\n\n                bytes32 ptrdata;\n\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n\n\n                while (ptrdata != needledata) {\n\n                    if (ptr <= selfptr)\n\n                        return selfptr;\n\n                    ptr--;\n\n                    assembly { ptrdata := and(mload(ptr), mask) }\n\n                }\n\n                return ptr + needlelen;\n\n            } else {\n\n                // For long needles, use hashing\n\n                bytes32 hash;\n\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                ptr = selfptr + (selflen - needlelen);\n\n                while (ptr >= selfptr) {\n\n                    bytes32 testHash;\n\n                    assembly { testHash := keccak256(ptr, needlelen) }\n\n                    if (hash == testHash)\n\n                        return ptr + needlelen;\n\n                    ptr -= 1;\n\n                }\n\n            }\n\n        }\n\n        return selfptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain everything from the first occurrence of\n\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n\n     *      if `needle` is not found.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len -= ptr - self._ptr;\n\n        self._ptr = ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Modifies `self` to contain the part of the string from the start of\n\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n\n     *      is not found, `self` is set to the empty slice.\n\n     * @param self The slice to search and modify.\n\n     * @param needle The text to search for.\n\n     * @return `self`.\n\n     */\n\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        self._len = ptr - self._ptr;\n\n        return self;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and `token` to everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = self._ptr;\n\n        token._len = ptr - self._ptr;\n\n        if (ptr == self._ptr + self._len) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n            self._ptr = ptr + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything after the first\n\n     *      occurrence of `needle`, and returning everything before it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` up to the first occurrence of `delim`.\n\n     */\n\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        split(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and `token` to everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and `token` is set to the entirety of `self`.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @param token An output parameter to which the first token is written.\n\n     * @return `token`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n\n        token._ptr = ptr;\n\n        token._len = self._len - (ptr - self._ptr);\n\n        if (ptr == self._ptr) {\n\n            // Not found\n\n            self._len = 0;\n\n        } else {\n\n            self._len -= token._len + needle._len;\n\n        }\n\n        return token;\n\n    }\n\n\n\n    /*\n\n     * @dev Splits the slice, setting `self` to everything before the last\n\n     *      occurrence of `needle`, and returning everything after it. If\n\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n\n     *      and the entirety of `self` is returned.\n\n     * @param self The slice to split.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The part of `self` after the last occurrence of `delim`.\n\n     */\n\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n\n        rsplit(self, needle, token);\n\n    }\n\n\n\n    /*\n\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return The number of occurrences of `needle` found in `self`.\n\n     */\n\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n\n        while (ptr <= self._ptr + self._len) {\n\n            cnt++;\n\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * @dev Returns True if `self` contains `needle`.\n\n     * @param self The slice to search.\n\n     * @param needle The text to search for in `self`.\n\n     * @return True if `needle` is found in `self`, false otherwise.\n\n     */\n\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n\n    }\n\n\n\n    /*\n\n     * @dev Returns a newly allocated string containing the concatenation of\n\n     *      `self` and `other`.\n\n     * @param self The first slice to concatenate.\n\n     * @param other The second slice to concatenate.\n\n     * @return The concatenation of the two strings.\n\n     */\n\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n\n        string memory ret = new string(self._len + other._len);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n\n        memcpy(retptr + self._len, other._ptr, other._len);\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n\n     *      newly allocated string.\n\n     * @param self The delimiter to use.\n\n     * @param parts A list of slices to join.\n\n     * @return A newly allocated string containing all the slices in `parts`,\n\n     *         joined with `self`.\n\n     */\n\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n\n        if (parts.length == 0)\n\n            return \"\";\n\n\n\n        uint length = self._len * (parts.length - 1);\n\n        for(uint i = 0; i < parts.length; i++)\n\n            length += parts[i]._len;\n\n\n\n        string memory ret = new string(length);\n\n        uint retptr;\n\n        assembly { retptr := add(ret, 32) }\n\n\n\n        for(i = 0; i < parts.length; i++) {\n\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n\n            retptr += parts[i]._len;\n\n            if (i < parts.length - 1) {\n\n                memcpy(retptr, self._ptr, self._len);\n\n                retptr += self._len;\n\n            }\n\n        }\n\n\n\n        return ret;\n\n    }\n",
                    "message": "Contract 'strings' (tokenWhitelist.sol#798-1475) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 799,
                    "vulnerability_to_line": 802,
                    "vulnerability_code": "    struct slice {\n\n        uint _len;\n\n        uint _ptr;\n",
                    "message": "Struct 'strings.slice' (tokenWhitelist.sol#799-802) is not in CapWords\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1598,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address) external view returns (string, uint256, uint256, bool, bool, bool, uint256);\n",
                    "message": "Parameter '' of ITokenWhitelist.getTokenInfo (tokenWhitelist.sol#1598) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '' of ITokenWhitelist.updateTokenRate (tokenWhitelist.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_0' of ITokenWhitelist.updateTokenRate (tokenWhitelist.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1601,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address, uint, uint) external;\n",
                    "message": "Parameter '_scope_1' of ITokenWhitelist.updateTokenRate (tokenWhitelist.sol#1601) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_oracleNameHash_' of TokenWhitelist. (tokenWhitelist.sol#1644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1644,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ens_, bytes32 _oracleNameHash_, bytes32 _controllerNameHash_, address _owner_, bool _transferable_, address _stabelcoinAddress_) ENSResolvable(_ens_) Controllable(_controllerNameHash_) Ownable(_owner_, _transferable_) public {\n",
                    "message": "Parameter '_stabelcoinAddress_' of TokenWhitelist. (tokenWhitelist.sol#1644) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.addTokens (tokenWhitelist.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_symbols' of TokenWhitelist.addTokens (tokenWhitelist.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_magnitude' of TokenWhitelist.addTokens (tokenWhitelist.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_loadable' of TokenWhitelist.addTokens (tokenWhitelist.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_burnable' of TokenWhitelist.addTokens (tokenWhitelist.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1656,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, bool[] _loadable, bool[] _burnable, uint _lastUpdate) external onlyController {\n",
                    "message": "Parameter '_lastUpdate' of TokenWhitelist.addTokens (tokenWhitelist.sol#1656) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeTokens(address[] _tokens) external onlyController {\n",
                    "message": "Parameter '_tokens' of TokenWhitelist.removeTokens (tokenWhitelist.sol#1684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_token' of TokenWhitelist.updateTokenRate (tokenWhitelist.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_rate' of TokenWhitelist.updateTokenRate (tokenWhitelist.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyControllerOrOracle {\n",
                    "message": "Parameter '_updateDate' of TokenWhitelist.updateTokenRate (tokenWhitelist.sol#1710) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of TokenWhitelist.claim (tokenWhitelist.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of TokenWhitelist.claim (tokenWhitelist.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of TokenWhitelist.claim (tokenWhitelist.sol#1722) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 1735,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function getTokenInfo(address _a) external view returns (string, uint256, uint256, bool, bool, bool, uint256) {\n",
                    "message": "Parameter '_a' of TokenWhitelist.getTokenInfo (tokenWhitelist.sol#1735) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 845,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 847,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 849,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffffffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 851,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000000000000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 853,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffffffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 855,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x100000000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 857,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xffff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 859,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            self = bytes32(uint(self) / 0x10000);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 861,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (self & 0xff == 0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 923,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 925,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 927,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 929,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xF8) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 931,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            } else if(b < 0xFC) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1016,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1018,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1020,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1067,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (b < 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1070,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xE0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1071,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x1F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1073,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        } else if(b < 0xF0) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1074,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x0F;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1077,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = b & 0x07;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1088,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            b = (word / divisor) & 0xFF;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1089,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if (b & 0xC0 != 0x80) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 1093,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            ret = (ret * 64) | (b & 0x3F);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
                    "vulnerability_from_line": 1700,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            _tokenAddressArray.length--;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
                    "vulnerability_from_line": 1694,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            for (uint j = 0; j < _tokenAddressArray.length.sub(1); j++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1046,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1400,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
                    "vulnerability_from_line": 1410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1457,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(uint i = 0; i < parts.length; i++)\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for(i = 0; i < parts.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1660,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1686,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        for (uint i = 0; i < _tokens.length; i++) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1238,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptrdata != needledata) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1290,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                while (ptr >= selfptr) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
                    "vulnerability_from_line": 1412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        while (ptr <= self._ptr + self._len) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 796,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.14;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1504,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 1590,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _adminCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isController;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _controllerCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS private _ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _ensRegistry;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _controllerNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1626,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping(address => Token) private _tokenInfoMap;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1627,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address[] private _tokenAddressArray;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1636,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _stablecoin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 1639,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _oracleNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SAFEMATH",
                    "vulnerability_from_line": 1609,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    using SafeMath for uint256;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 804,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function memcpy(uint dest, uint src, uint len) private pure {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 828,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSlice(string memory self) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 874,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 899,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function toString(slice memory self) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 916,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function len(slice memory self) internal pure returns (uint l) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 957,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function compare(slice memory self, slice memory other) internal pure returns (int) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1004,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1055,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ord(slice memory self) internal pure returns (uint ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1104,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1116,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1142,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1171,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1199,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1223,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1264,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1435,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
                    "vulnerability_from_line": 1452,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 807,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 816,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 830,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 876,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 902,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 922,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly { b := and(mload(ptr), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 967,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1015,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1065,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { word:= mload(mload(add(self, 32))) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1126,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1149,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1183,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1207,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            assembly {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1236,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1242,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1248,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1252,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { needledata := and(mload(needleptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1282,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { ptrdata := and(mload(ptr), mask) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1288,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                assembly { hash := keccak256(needleptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                    assembly { testHash := keccak256(ptr, needlelen) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1438,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
                    "vulnerability_from_line": 1462,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        assembly { retptr := add(ret, 32) }\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
                    "message": null
                }
            ]
        }
    },
    "contracts-b99b7d1670f9ad7b90335e8391fe63fd7e20de9b/contracts/internals/controllable.sol": {
        "semgrep": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "use-ownable2step",
                    "vulnerability_from_line": 193,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "contract Controller is IController, Ownable, Claimable {\n",
                    "message": "By demanding that the receiver of the owner permissions actively accept via a contract call of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the contract ownership from accidentally being transferred  to an address that cannot handle it."
                },
                {
                    "name": "array-length-outside-loop",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 37,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = _account_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 38,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _isTransferable = _transferable_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 39,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        // Emit the LockedOwnership event if no longer transferable.\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 40,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        if (!_isTransferable) {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 41,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            emit LockedOwnership(_account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 42,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 43,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        emit TransferredOwnership(address(0), _account_);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 44,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 210,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ownerAddress_, bool _transferable_) Ownable(_ownerAddress_, _transferable_) public { }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 454,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(ENS ensAddr) public {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 455,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        ens = ensAddr;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 456,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 672,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ensRegistry = _ensReg_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 673,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _ens = ENS(_ensRegistry);\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 674,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 721,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerNode = _controllerNameHash_;\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "non-payable-constructor",
                    "vulnerability_from_line": 722,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    }\n",
                    "message": "Consider making costructor payable to save gas."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 48,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isOwner(msg.sender), \"sender is not an owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 57,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 83,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isTransferable, \"ownership is not transferable\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 214,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isAdmin(msg.sender), \"sender is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 220,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 284,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isAdmin[_account], \"provided account is not an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-custom-error-not-require",
                    "vulnerability_from_line": 726,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController(msg.sender), \"sender is not a controller\");\n",
                    "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 574,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 575,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                data = record.abis[contentType];\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 576,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "                return;\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-nested-if",
                    "vulnerability_from_line": 577,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            }\n",
                    "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 286,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-decrement-not-postfix",
                    "vulnerability_from_line": 305,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount--;\n",
                    "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 278,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _adminCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-prefix-increment-not-postfix",
                    "vulnerability_from_line": 297,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _controllerCount++;\n",
                    "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 59,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"owner cannot be set to zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 152,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 273,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 274,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 275,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 276,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 292,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isAdmin[_account], \"provided account is already an admin\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 293,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isController[_account], \"provided account is already a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 294,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(!_isOwner(_account), \"provided account is already the owner\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 295,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_account != address(0), \"provided account is the zero address\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                },
                {
                    "name": "use-short-revert-string",
                    "vulnerability_from_line": 303,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        require(_isController[_account], \"provided account is not a controller\");\n",
                    "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
                }
            ]
        },
        "slither": {
            "successfull_analysis": true,
            "errors": [
                "EXIT_CODE_65"
            ],
            "vulnerability_findings": [
                {
                    "name": "arbitrary-send",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Claimable._claim (controllable.sol#147-156) sends eth to arbitrary user\n\tDangerous calls:\n\t- _to.transfer(_amount) (controllable.sol#150)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 361,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n",
                    "message": "ENS.setSubnodeOwner.owner (local variable @ controllable.sol#361) shadows:\n\t- ENS.owner (function @ controllable.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 362,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setResolver(bytes32 node, address resolver) external;\n",
                    "message": "ENS.setResolver.resolver (local variable @ controllable.sol#362) shadows:\n\t- ENS.resolver (function @ controllable.sol#366)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 363,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setOwner(bytes32 node, address owner) external;\n",
                    "message": "ENS.setOwner.owner (local variable @ controllable.sol#363) shadows:\n\t- ENS.owner (function @ controllable.sol#365)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 364,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setTTL(bytes32 node, uint64 ttl) external;\n",
                    "message": "ENS.setTTL.ttl (local variable @ controllable.sol#364) shadows:\n\t- ENS.ttl (function @ controllable.sol#367)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n",
                    "message": "PublicResolver.setAddr.addr (local variable @ controllable.sol#464) shadows:\n\t- PublicResolver.addr (function @ controllable.sol#617-619)\n"
                },
                {
                    "name": "shadowing-local",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": "PublicResolver.setName.name (local variable @ controllable.sol#499) shadows:\n\t- PublicResolver.name (function @ controllable.sol#588-590)\n"
                },
                {
                    "name": "pragma",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": "Different versions of Solidity is used in controllable.sol:\n\t- Version used: ['>=0.4.24', '^0.4.24', '^0.4.25']\n\t- controllable.sol#21 declares pragma solidity^0.4.25\n\t- controllable.sol#105 declares pragma solidity^0.4.25\n\t- controllable.sol#135 declares pragma solidity^0.4.25\n\t- controllable.sol#179 declares pragma solidity^0.4.25\n\t- controllable.sol#344 declares pragma solidity>=0.4.24\n\t- controllable.sol#401 declares pragma solidity^0.4.24\n\t- controllable.sol#658 declares pragma solidity^0.4.25\n\t- controllable.sol#710 declares pragma solidity^0.4.25\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 92,
                    "vulnerability_to_line": 94,
                    "vulnerability_code": "    function owner() public view returns (address) {\n\n        return _owner;\n",
                    "message": "Ownable.owner (controllable.sol#92-94) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 464,
                    "vulnerability_to_line": 467,
                    "vulnerability_code": "    function setAddr(bytes32 node, address addr) public only_owner(node) {\n\n        records[node].addr = addr;\n\n        emit AddrChanged(node, addr);\n",
                    "message": "PublicResolver.setAddr (controllable.sol#464-467) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 477,
                    "vulnerability_to_line": 480,
                    "vulnerability_code": "    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n\n        records[node].content = hash;\n\n        emit ContentChanged(node, hash);\n",
                    "message": "PublicResolver.setContent (controllable.sol#477-480) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": 491,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n\n        records[node].multihash = hash;\n\n        emit MultihashChanged(node, hash);\n",
                    "message": "PublicResolver.setMultihash (controllable.sol#488-491) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": 502,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n\n        records[node].name = name;\n\n        emit NameChanged(node, name);\n",
                    "message": "PublicResolver.setName (controllable.sol#499-502) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": 518,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n\n        // Content types must be powers of 2\n\n        require(((contentType - 1) & contentType) == 0);\n\n        \n\n        records[node].abis[contentType] = data;\n\n        emit ABIChanged(node, contentType);\n",
                    "message": "PublicResolver.setABI (controllable.sol#512-518) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 526,
                    "vulnerability_to_line": 529,
                    "vulnerability_code": "    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n\n        records[node].pubkey = PublicKey(x, y);\n\n        emit PubkeyChanged(node, x, y);\n",
                    "message": "PublicResolver.setPubkey (controllable.sol#526-529) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": 541,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n\n        records[node].text[key] = value;\n\n        emit TextChanged(node, key, key);\n",
                    "message": "PublicResolver.setText (controllable.sol#538-541) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": 551,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n\n        return records[node].text[key];\n",
                    "message": "PublicResolver.text (controllable.sol#549-551) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 559,
                    "vulnerability_to_line": 561,
                    "vulnerability_code": "    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n\n        return (records[node].pubkey.x, records[node].pubkey.y);\n",
                    "message": "PublicResolver.pubkey (controllable.sol#559-561) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "PublicResolver.ABI (controllable.sol#571-580) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": 590,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n\n        return records[node].name;\n",
                    "message": "PublicResolver.name (controllable.sol#588-590) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 599,
                    "vulnerability_to_line": 601,
                    "vulnerability_code": "    function content(bytes32 node) public view returns (bytes32) {\n\n        return records[node].content;\n",
                    "message": "PublicResolver.content (controllable.sol#599-601) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": 610,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n\n        return records[node].multihash;\n",
                    "message": "PublicResolver.multihash (controllable.sol#608-610) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 617,
                    "vulnerability_to_line": 619,
                    "vulnerability_code": "    function addr(bytes32 node) public view returns (address) {\n\n        return records[node].addr;\n",
                    "message": "PublicResolver.addr (controllable.sol#617-619) should be declared external\n"
                },
                {
                    "name": "external-function",
                    "vulnerability_from_line": 626,
                    "vulnerability_to_line": 635,
                    "vulnerability_code": "    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n\n        return interfaceID == ADDR_INTERFACE_ID ||\n\n        interfaceID == CONTENT_INTERFACE_ID ||\n\n        interfaceID == NAME_INTERFACE_ID ||\n\n        interfaceID == ABI_INTERFACE_ID ||\n\n        interfaceID == PUBKEY_INTERFACE_ID ||\n\n        interfaceID == TEXT_INTERFACE_ID ||\n\n        interfaceID == MULTIHASH_INTERFACE_ID ||\n\n        interfaceID == INTERFACE_META_ID;\n",
                    "message": "PublicResolver.supportsInterface (controllable.sol#626-635) should be declared external\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_account_' of Ownable. (controllable.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 36,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _account_, bool _transferable_) internal {\n",
                    "message": "Parameter '_transferable_' of Ownable. (controllable.sol#36) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_account' of Ownable.transferOwnership (controllable.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 55,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transferOwnership(address _account, bool _transferable) external onlyOwner {\n",
                    "message": "Parameter '_transferable' of Ownable.transferOwnership (controllable.sol#55) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": 100,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n\n        return _address == _owner;\n",
                    "message": "Function 'Ownable._isOwner' (controllable.sol#98-100) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 98,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isOwner(address _address) internal view returns (bool) {\n",
                    "message": "Parameter '_address' of Ownable._isOwner (controllable.sol#98) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.approve (controllable.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 109,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function approve(address, uint256) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.approve (controllable.sol#109) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 110,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function balanceOf(address) external view returns (uint);\n",
                    "message": "Parameter '' of ERC20.balanceOf (controllable.sol#110) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '' of ERC20.transfer (controllable.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 111,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function transfer(address, uint) external returns (bool);\n",
                    "message": "Parameter '_scope_0' of ERC20.transfer (controllable.sol#111) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": 156,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n\n        // address(0) is used to denote ETH\n\n        if (_asset == address(0)) {\n\n            _to.transfer(_amount);\n\n        } else {\n\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\n\n        }\n\n\n\n        emit Claimed(_to, _asset, _amount);\n",
                    "message": "Function 'Claimable._claim' (controllable.sol#147-156) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_to' of Claimable._claim (controllable.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_asset' of Claimable._claim (controllable.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 147,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _claim(address _to, address _asset, uint _amount) internal {\n",
                    "message": "Parameter '_amount' of Claimable._claim (controllable.sol#147) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 184,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address) external view returns (bool);\n",
                    "message": "Parameter '' of IController.isController (controllable.sol#184) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 267,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isController(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isController (controllable.sol#267) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 226,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.addAdmin (controllable.sol#226) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 232,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeAdmin(address _account) external onlyOwner {\n",
                    "message": "Parameter '_account' of Controller.removeAdmin (controllable.sol#232) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 243,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function addController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.addController (controllable.sol#243) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 249,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function removeController(address _account) external onlyAdmin {\n",
                    "message": "Parameter '_account' of Controller.removeController (controllable.sol#249) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 261,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function isAdmin(address _account) public view returns (bool) {\n",
                    "message": "Parameter '_account' of Controller.isAdmin (controllable.sol#261) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": 280,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isAdmin[_account] = true;\n\n        _adminCount++;\n\n        emit AddedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._addAdmin' (controllable.sol#272-280) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 272,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addAdmin (controllable.sol#272) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": 288,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n\n        require(_isAdmin[_account], \"provided account is not an admin\");\n\n        _isAdmin[_account] = false;\n\n        _adminCount--;\n\n        emit RemovedAdmin(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeAdmin' (controllable.sol#283-288) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 283,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeAdmin(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeAdmin (controllable.sol#283) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": 299,
                    "vulnerability_code": "    function _addController(address _account) private {\n\n        require(!_isAdmin[_account], \"provided account is already an admin\");\n\n        require(!_isController[_account], \"provided account is already a controller\");\n\n        require(!_isOwner(_account), \"provided account is already the owner\");\n\n        require(_account != address(0), \"provided account is the zero address\");\n\n        _isController[_account] = true;\n\n        _controllerCount++;\n\n        emit AddedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._addController' (controllable.sol#291-299) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 291,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _addController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._addController (controllable.sol#291) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": 307,
                    "vulnerability_code": "    function _removeController(address _account) private {\n\n        require(_isController[_account], \"provided account is not a controller\");\n\n        _isController[_account] = false;\n\n        _controllerCount--;\n\n        emit RemovedController(msg.sender, _account);\n",
                    "message": "Function 'Controller._removeController' (controllable.sol#302-307) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 302,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _removeController(address _account) private {\n",
                    "message": "Parameter '_account' of Controller._removeController (controllable.sol#302) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_to' of Controller.claim (controllable.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_asset' of Controller.claim (controllable.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 310,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function claim(address _to, address _asset, uint _amount) external onlyOwner {\n",
                    "message": "Parameter '_amount' of Controller.claim (controllable.sol#310) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": 580,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n\n        Record storage record = records[node];\n\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n\n                data = record.abis[contentType];\n\n                return;\n\n            }\n\n        }\n\n        contentType = 0;\n",
                    "message": "Function 'PublicResolver.ABI' (controllable.sol#571-580) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 445,
                    "vulnerability_to_line": 448,
                    "vulnerability_code": "    modifier only_owner(bytes32 node) {\n\n        require(ens.owner(node) == msg.sender);\n\n        _;\n",
                    "message": "Modifier 'PublicResolver.only_owner' (controllable.sol#445-448) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 671,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(address _ensReg_) internal {\n",
                    "message": "Parameter '_ensReg_' of ENSResolvable. (controllable.sol#671) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": 686,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n\n        return PublicResolver(_ens.resolver(_nodeHash)).addr(_nodeHash);\n",
                    "message": "Function 'ENSResolvable._ensResolve' (controllable.sol#684-686) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 684,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _ensResolve(bytes32 _nodeHash) internal view returns (address) {\n",
                    "message": "Parameter '_nodeHash' of ENSResolvable._ensResolve (controllable.sol#684) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 720,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    constructor(bytes32 _controllerNameHash_) internal {\n",
                    "message": "Parameter '_controllerNameHash_' of Controllable. (controllable.sol#720) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": 738,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n\n        return IController(_ensResolve(_controllerNode)).isController(_account);\n",
                    "message": "Function 'Controllable._isController' (controllable.sol#736-738) is not in mixedCase\n"
                },
                {
                    "name": "naming-convention",
                    "vulnerability_from_line": 736,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function _isController(address _account) internal view returns (bool) {\n",
                    "message": "Parameter '_account' of Controllable._isController (controllable.sol#736) is not in mixedCase\n"
                }
            ]
        },
        "smartcheck": {
            "successfull_analysis": true,
            "errors": [],
            "vulnerability_findings": [
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_ADDRESS_HARDCODED",
                    "vulnerability_from_line": 85,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "        _owner = address(0);\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 21,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 105,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 135,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 179,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 344,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity >=0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 401,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.24;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 658,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRAGMAS_VERSION",
                    "vulnerability_from_line": 710,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "pragma solidity ^0.4.25;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 32,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _owner;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 33,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bool private _isTransferable;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 201,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isAdmin;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 202,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _adminCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 204,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (address => bool) private _isController;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 205,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    uint private _controllerCount;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 665,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS private _ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 668,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    address private _ensRegistry;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
                    "vulnerability_from_line": 716,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes32 private _controllerNode;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 488,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 499,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setName(bytes32 node, string name) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 512,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 538,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function setText(bytes32 node, string key, string value) public only_owner(node) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 549,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function text(bytes32 node, string key) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 571,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 588,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function name(bytes32 node) public view returns (string) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_UPGRADE_TO_050",
                    "vulnerability_from_line": 608,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    function multihash(bytes32 node) public view returns (bytes) {\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 409,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 410,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 411,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 412,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 413,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 414,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 415,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 416,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 441,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    ENS ens;\n",
                    "message": null
                },
                {
                    "name": "SOLIDITY_VISIBILITY",
                    "vulnerability_from_line": 443,
                    "vulnerability_to_line": null,
                    "vulnerability_code": "    mapping (bytes32 => Record) records;\n",
                    "message": null
                }
            ]
        }
    }
}